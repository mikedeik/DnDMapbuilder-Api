This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  commands/
    execute_prompt_plan.md
  settings.local.json
.github/
  workflows/
    main.yml
  FIX_DOCKER_PERMISSIONS.md
  GITHUB_ACTIONS_GUIDE.md
  GITLAB_VS_GITHUB_COMPARISON.md
  MULTI_PLATFORM_BUILD.md
src/
  DnDMapBuilder.Api/
    Controllers/
      AuthController.cs
      CampaignsController.cs
      OtherControllers.cs
    appsettings.json
    DnDMapBuilder.Api.csproj
    Dockerfile
    Program.cs
  DnDMapBuilder.AppHost/
    AppHost.cs
    appsettings.json
    DnDMapBuilder.AppHost.csproj
  DnDMapBuilder.Application/
    Interfaces/
      IServices.cs
    Mappings/
      MappingExtensions.cs
    Services/
      AuthService.cs
      CampaignService.cs
      FileStorageService.cs
      GameMapAndTokenServices.cs
      JwtService.cs
      MissionService.cs
    DnDMapBuilder.Application.csproj
  DnDMapBuilder.Aspire.ServiceDefaults/
    DnDMapBuilder.Aspire.ServiceDefaults.csproj
    Extensions.cs
  DnDMapBuilder.Contracts/
    DTOs/
      DomainDtos.cs
    Requests/
      ApiRequests.cs
    Responses/
      ApiResponses.cs
    DnDMapBuilder.Contracts.csproj
  DnDMapBuilder.Data/
    Entities/
      DomainEntities.cs
    Migrations/
      20260114100522_InitialCreate.cs
      20260114100522_InitialCreate.Designer.cs
      20260115221337_PendingModelChanges.cs
      20260115221337_PendingModelChanges.Designer.cs
      20260116231211_UpdateAdminPasswordHash.cs
      20260116231211_UpdateAdminPasswordHash.Designer.cs
      20260116232059_RemoveSeedData.cs
      20260116232059_RemoveSeedData.Designer.cs
      20260117102707_AddImageFileStorageMetadata.cs
      20260117102707_AddImageFileStorageMetadata.Designer.cs
      20260117104633_SaveImageFiles.cs
      20260117104633_SaveImageFiles.Designer.cs
      DnDMapBuilderDbContextModelSnapshot.cs
    Repositories/
      IRepositories.cs
      Repositories.cs
    DbInitializer.cs
    DnDMapBuilder.Data.csproj
    DnDMapBuilderDbContext.cs
.gitignore
API_DOCUMENTATION.md
DnDMapBuilder.sln
docker-compose.yml
dotnet-tools.json
FILE_STRUCTURE.md
generate-certs.sh
PROJECT_SUMMARY.md
prompt_plan.md
QUICKSTART.md
README.md
SECURITY.md
setup.sh
STRUCTURE_DIAGRAM.md
verify-structure.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/commands/execute_prompt_plan.md">
## You are a senior .NET engineer implementing a new feature
- Read the @../prompt_plan.md file and identify pending steps
- Create a new branch with the feature name from the context session if it does not exist. You only work on this branch
- Implement the step and when done update the step status to done.
- continue with the next step.
</file>

<file path=".github/FIX_DOCKER_PERMISSIONS.md">
# Fixing Docker Permission Issues on Your Server

## The Problem

You're seeing this error:
```
permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock
```

This happens because your SSH user doesn't have permission to run Docker commands.

## Solution: Add User to Docker Group

SSH into your server and run these commands:

### Step 1: Add your user to the docker group
```bash
sudo usermod -aG docker $USER
```

If you're deploying with a specific user (e.g., `ubuntu`), replace `$USER`:
```bash
sudo usermod -aG docker ubuntu
```

### Step 2: Apply the group changes

You have two options:

**Option A: Log out and log back in** (Recommended)
```bash
exit
# Then SSH back in
```

**Option B: Activate the group without logging out**
```bash
newgrp docker
```

### Step 3: Verify it works
```bash
docker ps
```

If this runs without `sudo` and without errors, you're all set!

### Step 4: Test the full workflow
```bash
# Test login to GitHub Container Registry
echo "YOUR_GITHUB_PAT" | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin

# Test pulling an image
docker pull hello-world

# Test running a container
docker run hello-world
```

## Alternative Solution: Use Sudo (Not Recommended)

If you can't add the user to the docker group, you can modify the workflow to use `sudo`. However, this requires configuring passwordless sudo for Docker commands.

### Configure passwordless sudo for Docker

1. SSH into your server
2. Edit the sudoers file:
```bash
sudo visudo
```

3. Add this line at the end (replace `ubuntu` with your username):
```bash
ubuntu ALL=(ALL) NOPASSWD: /usr/bin/docker
```

4. Save and exit (Ctrl+X, then Y, then Enter)

5. Update the workflow to use `sudo`:

In `.github/workflows/ci-cd.yml`, replace all `docker` commands with `sudo docker`:
```bash
sudo docker login ...
sudo docker pull ...
sudo docker stop ...
sudo docker rm ...
sudo docker run ...
```

## Checking Current Docker Group Membership

To see if your user is already in the docker group:
```bash
groups $USER
```

Or for a specific user:
```bash
groups ubuntu
```

You should see `docker` in the output.

## Understanding Docker Socket Permissions

The Docker daemon runs as root and listens on `/var/run/docker.sock`. By default, only root and members of the `docker` group can access this socket.

To check socket permissions:
```bash
ls -l /var/run/docker.sock
```

Output should look like:
```
srw-rw---- 1 root docker 0 Jan 15 21:00 /var/run/docker.sock
```

The `docker` in the group column means users in the docker group can access it.

## Security Note

Adding a user to the docker group gives them root-equivalent privileges because Docker containers can be run with root access. Only add trusted users to the docker group.

For production environments, consider:
- Using a dedicated deployment user with minimal privileges
- Implementing proper secret rotation
- Using Docker's user namespaces for additional isolation
- Auditing Docker commands via logging

## Testing Your Fix

After adding your user to the docker group and logging back in, run:

```bash
# Should work without sudo
docker ps

# Should work without sudo
docker images

# Should work without sudo
docker pull alpine
```

If all three commands work without errors, your permissions are fixed!

## Still Having Issues?

### Issue: "Cannot connect to the Docker daemon"
**Solution**: Make sure Docker is running
```bash
sudo systemctl status docker
sudo systemctl start docker
sudo systemctl enable docker  # Enable on boot
```

### Issue: "credential helper" warning
This warning is harmless but can be fixed by installing a credential helper:
```bash
# For Ubuntu/Debian
sudo apt-get install pass gnupg2

# Configure Docker to use it
docker-credential-pass
```

Or ignore it - it won't affect deployment.

### Issue: "network dnd-network not found"
Create the Docker network first:
```bash
docker network create dnd-network
```

Or update the workflow to create it automatically:
```bash
docker network create dnd-network || true
```
</file>

<file path=".github/GITHUB_ACTIONS_GUIDE.md">
# GitHub Actions CI/CD Guide

## Overview

This guide explains how to use the GitHub Actions workflow for your DnD MapBuilder API, and how to configure secrets (similar to GitLab CI/CD variables).

## GitLab vs GitHub Actions: Key Differences

| Feature | GitLab CI/CD | GitHub Actions |
|---------|--------------|----------------|
| **Config File** | `.gitlab-ci.yml` (root) | `.github/workflows/*.yml` |
| **Variables/Secrets** | Settings > CI/CD > Variables | Settings > Secrets and variables > Actions |
| **Jobs** | Defined in stages | Defined in jobs (can run in parallel or sequence) |
| **Runners** | GitLab Runners | GitHub-hosted or self-hosted runners |
| **Docker Registry** | GitLab Container Registry | GitHub Container Registry (ghcr.io) |
| **Manual Trigger** | `when: manual` | `workflow_dispatch` |

## How the Workflow Works

The workflow has 3 jobs that run sequentially:

### 1. Build and Test (`build-and-test`)
- Triggers on: Push to `main`/`develop` or Pull Requests
- Checks out code
- Sets up .NET 10.0
- Restores dependencies
- Builds the solution
- Runs tests

### 2. Build Docker Image (`build-docker`)
- Runs only on push to `main` branch (after tests pass)
- Builds Docker image using your Dockerfile
- Pushes to GitHub Container Registry (ghcr.io)
- Tags images with branch name, commit SHA, and 'latest'

### 3. Deploy to Server (`deploy`)
- Runs only on push to `main` branch (after Docker build)
- Connects to your server via SSH
- Pulls the latest Docker image
- Stops old container
- Starts new container with environment variables
- Verifies deployment

## Setting Up Secrets (GitLab Variables Equivalent)

In GitHub, secrets are stored in: **Repository Settings > Secrets and variables > Actions**

### Required Secrets

#### Server Connection Secrets
```
SECRET NAME: SERVER_HOST
VALUE: your-server-ip-or-domain.com
DESCRIPTION: IP address or domain of your deployment server
```

```
SECRET NAME: SERVER_USERNAME
VALUE: ubuntu (or your SSH username)
DESCRIPTION: SSH username for server access
```

```
SECRET NAME: SSH_PRIVATE_KEY
VALUE: -----BEGIN OPENSSH PRIVATE KEY-----
...your private key content...
-----END OPENSSH PRIVATE KEY-----
DESCRIPTION: SSH private key for server authentication
```

```
SECRET NAME: SERVER_PORT
VALUE: 22 (optional, defaults to 22)
DESCRIPTION: SSH port if different from 22
```

#### Application Secrets
```
SECRET NAME: DB_CONNECTION_STRING
VALUE: Host=your-db-host;Database=dndmapbuilder;Username=dbuser;Password=dbpass
DESCRIPTION: PostgreSQL/SQL Server connection string
```

```
SECRET NAME: JWT_SECRET
VALUE: your-super-secret-jwt-key-at-least-32-characters-long
DESCRIPTION: Secret key for JWT token signing
```

```
SECRET NAME: JWT_ISSUER
VALUE: https://your-api-domain.com
DESCRIPTION: JWT token issuer
```

```
SECRET NAME: JWT_AUDIENCE
VALUE: https://your-api-domain.com
DESCRIPTION: JWT token audience
```

### How to Add Secrets

1. Go to your GitHub repository
2. Click **Settings** tab
3. In the left sidebar, click **Secrets and variables** > **Actions**
4. Click **New repository secret**
5. Enter the secret name and value
6. Click **Add secret**

### Secret Scopes

- **Repository secrets**: Available to all workflows in the repository (default)
- **Environment secrets**: Scoped to specific environments (production, staging)
- **Organization secrets**: Shared across multiple repositories

## Generating SSH Key Pair

If you don't have SSH keys set up:

```bash
# On your local machine
ssh-keygen -t ed25519 -C "github-actions-deploy" -f ~/.ssh/github_actions_deploy

# Copy public key to your server
ssh-copy-id -i ~/.ssh/github_actions_deploy.pub user@your-server.com

# Copy private key content to GitHub secret
cat ~/.ssh/github_actions_deploy
# Copy the entire output including BEGIN and END lines
```

## GitHub Container Registry Setup

GitHub Container Registry (ghcr.io) is free and automatically available. No extra setup needed!

The workflow uses `GITHUB_TOKEN` which is automatically provided by GitHub Actions.

### Making Your Image Public (Optional)

1. Go to your package: https://github.com/users/YOUR_USERNAME/packages/container/YOUR_REPO
2. Click **Package settings**
3. Change visibility to Public if desired

## Triggering the Workflow

### Automatic Triggers
- **Push to `main` or `develop`**: Runs build, test, Docker build (only on main), and deploy (only on main)
- **Pull Request to `main` or `develop`**: Runs build and test only

### Manual Trigger
1. Go to **Actions** tab in your repository
2. Select **CI/CD Pipeline** workflow
3. Click **Run workflow** button
4. Select branch and click **Run workflow**

## Monitoring Workflow Runs

1. Go to **Actions** tab in your repository
2. Click on a workflow run to see details
3. Click on individual jobs to see logs
4. Failed steps will be highlighted in red

## Environment Variables in Workflow

There are two types of variables:

### 1. Secrets (Sensitive Data)
```yaml
${{ secrets.DB_CONNECTION_STRING }}
```
- Encrypted and hidden in logs
- Used for passwords, keys, tokens

### 2. Environment Variables (Non-Sensitive)
```yaml
env:
  DOTNET_VERSION: '10.0.x'
```
- Visible in workflow file
- Used for versions, public URLs

### 3. GitHub Context Variables
```yaml
${{ github.repository }}  # owner/repo-name
${{ github.actor }}       # username who triggered
${{ github.ref }}         # branch reference
```

## Customizing the Workflow

### Change Deployment Branch
To deploy from `develop` instead of `main`:
```yaml
if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
```

### Add Staging Environment
```yaml
deploy-staging:
  if: github.ref == 'refs/heads/develop'
  environment: staging
  # ... steps
```

### Add Database Migrations
Add before deployment:
```yaml
- name: Run migrations
  uses: appleboy/ssh-action@v1.0.0
  with:
    host: ${{ secrets.SERVER_HOST }}
    username: ${{ secrets.SERVER_USERNAME }}
    key: ${{ secrets.SSH_PRIVATE_KEY }}
    script: |
      docker exec dnd-api dotnet ef database update
```

## Caching for Faster Builds

The workflow already includes Docker layer caching:
```yaml
cache-from: type=gha
cache-to: type=gha,mode=max
```

To add .NET dependency caching:
```yaml
- uses: actions/cache@v3
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
```

## Notifications

### Slack Notifications
Add to the end of deploy job:
```yaml
- name: Notify Slack
  uses: slackapi/slack-github-action@v1
  with:
    webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
    payload: |
      {
        "text": "Deployment completed: ${{ job.status }}"
      }
```

### Email Notifications
GitHub sends email notifications for failed workflows automatically.

## Troubleshooting

### SSH Connection Fails
- Verify `SERVER_HOST`, `SERVER_USERNAME`, and `SSH_PRIVATE_KEY` secrets
- Ensure server allows SSH from GitHub's IP ranges
- Check that public key is in `~/.ssh/authorized_keys` on server

### Docker Pull Fails
- Ensure GitHub token has package read permissions
- Make package public or use Personal Access Token with `read:packages` scope

### Container Won't Start
- Check secrets are correctly set
- Review container logs: `docker logs dnd-api`
- Verify environment variables format

## Security Best Practices

1. **Never commit secrets to code**
2. **Use environment-specific secrets** for production vs staging
3. **Rotate secrets regularly**
4. **Use least-privilege service accounts** for SSH access
5. **Enable branch protection** on `main` to require PR reviews
6. **Use environment protection rules** to require manual approval for production deploys

## Next Steps

1. Add secrets to your GitHub repository
2. Push this workflow to your `main` branch
3. Monitor the Actions tab for the first run
4. Adjust the workflow based on your specific needs
</file>

<file path=".github/GITLAB_VS_GITHUB_COMPARISON.md">
# GitLab CI/CD vs GitHub Actions: Side-by-Side Comparison

## Configuration File Structure

### GitLab CI/CD (.gitlab-ci.yml)
```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOTNET_VERSION: "10.0"

build_job:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:10.0
  script:
    - dotnet restore
    - dotnet build
  only:
    - main
    - develop

deploy_job:
  stage: deploy
  script:
    - ssh user@server "docker pull image"
  only:
    - main
  when: manual
```

### GitHub Actions (.github/workflows/ci-cd.yml)
```yaml
on:
  push:
    branches: [ main, develop ]

env:
  DOTNET_VERSION: '10.0.x'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: |
          dotnet restore
          dotnet build

  deploy:
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: ssh user@server "docker pull image"
    # workflow_dispatch enables manual trigger
```

## Variables and Secrets

### GitLab: CI/CD Variables
**Location**: Settings > CI/CD > Variables

```yaml
# In .gitlab-ci.yml
script:
  - echo $DB_CONNECTION_STRING
  - echo $CI_COMMIT_SHA  # GitLab predefined variable
```

**Variable Types**:
- Regular variables
- Protected variables (only for protected branches)
- Masked variables (hidden in logs)
- File variables (content saved to temp file)

### GitHub: Secrets and Variables
**Location**: Settings > Secrets and variables > Actions

```yaml
# In workflow file
run: |
  echo ${{ secrets.DB_CONNECTION_STRING }}
  echo ${{ github.sha }}  # GitHub context variable
```

**Types**:
- Secrets (encrypted, hidden in logs)
- Variables (plain text, visible)
- Environment secrets (scoped to environments)

## Key Concept Mapping

| GitLab Concept | GitHub Actions Equivalent | Notes |
|----------------|---------------------------|-------|
| `.gitlab-ci.yml` | `.github/workflows/*.yml` | GitHub allows multiple workflow files |
| `stages:` | `jobs:` with `needs:` | GitHub jobs run in parallel by default |
| `stage: build` | `jobs: build:` | Define job dependencies with `needs:` |
| `script:` | `steps:` with `run:` | GitHub uses steps within jobs |
| `image:` | `runs-on:` or `container:` | GitHub has hosted runners |
| `only:` / `except:` | `if:` conditions | GitHub uses expressions |
| `when: manual` | `workflow_dispatch` event | Different trigger mechanism |
| `artifacts:` | `actions/upload-artifact` | GitHub uses actions |
| `cache:` | `actions/cache` | GitHub uses actions |
| `before_script:` | Common step at start | No built-in concept |
| `after_script:` | Add step with `if: always()` | No built-in concept |
| `variables:` | `env:` | GitHub also has `secrets` |
| `$CI_*` variables | `${{ github.* }}` context | Different syntax and names |
| `extends:` | Reusable workflows | Different mechanism |
| `rules:` | `if:` conditions | GitHub uses expressions |
| `environment:` | `environment:` | Similar concept |
| `services:` | `services:` in job | Similar concept |
| `retry:` | `uses: nick-invision/retry@v2` | Needs action |

## Common Variables/Context Mapping

| GitLab Variable | GitHub Context | Value |
|-----------------|----------------|-------|
| `$CI_COMMIT_SHA` | `${{ github.sha }}` | Commit SHA |
| `$CI_COMMIT_REF_NAME` | `${{ github.ref_name }}` | Branch name |
| `$CI_PIPELINE_ID` | `${{ github.run_id }}` | Pipeline/Run ID |
| `$CI_JOB_ID` | `${{ github.job }}` | Job ID |
| `$CI_PROJECT_NAME` | `${{ github.repository }}` | Project name |
| `$CI_COMMIT_MESSAGE` | `${{ github.event.head_commit.message }}` | Commit message |
| `$CI_COMMIT_BRANCH` | `${{ github.ref_name }}` | Branch name |
| `$GITLAB_USER_LOGIN` | `${{ github.actor }}` | Username |
| `$CI_REGISTRY` | `ghcr.io` | Container registry |
| `$CI_REGISTRY_USER` | `${{ github.actor }}` | Registry username |
| `$CI_REGISTRY_PASSWORD` | `${{ secrets.GITHUB_TOKEN }}` | Registry password |

## SSH Deployment Comparison

### GitLab CI/CD
```yaml
deploy:
  stage: deploy
  before_script:
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVER_HOST >> ~/.ssh/known_hosts
  script:
    - ssh $SERVER_USER@$SERVER_HOST "
        docker pull $CI_REGISTRY_IMAGE:latest &&
        docker stop app || true &&
        docker run -d --name app $CI_REGISTRY_IMAGE:latest
      "
  only:
    - main
```

**GitLab Variables to Set**:
- `SSH_PRIVATE_KEY` (Type: File, Protected, Masked)
- `SERVER_HOST`
- `SERVER_USER`

### GitHub Actions
```yaml
deploy:
  runs-on: ubuntu-latest
  if: github.ref == 'refs/heads/main'
  steps:
    - uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          docker pull ghcr.io/${{ github.repository }}:latest
          docker stop app || true
          docker run -d --name app ghcr.io/${{ github.repository }}:latest
```

**GitHub Secrets to Set**:
- `SSH_PRIVATE_KEY`
- `SERVER_HOST`
- `SERVER_USERNAME`

## Docker Build & Push Comparison

### GitLab CI/CD
```yaml
docker-build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
```

**No extra variables needed** - GitLab provides `$CI_REGISTRY_*` automatically

### GitHub Actions
```yaml
docker-build:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4

    - uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ghcr.io/${{ github.repository }}:${{ github.sha }}
          ghcr.io/${{ github.repository }}:latest
```

**No extra secrets needed** - GitHub provides `GITHUB_TOKEN` automatically

## Environment-Specific Deployment

### GitLab CI/CD
```yaml
deploy_staging:
  stage: deploy
  script:
    - echo "Deploying to staging"
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

deploy_production:
  stage: deploy
  script:
    - echo "Deploying to production"
  environment:
    name: production
    url: https://example.com
  only:
    - main
  when: manual
```

### GitHub Actions
```yaml
deploy-staging:
  if: github.ref == 'refs/heads/develop'
  environment:
    name: staging
    url: https://staging.example.com
  runs-on: ubuntu-latest
  steps:
    - run: echo "Deploying to staging"

deploy-production:
  if: github.ref == 'refs/heads/main'
  environment:
    name: production
    url: https://example.com
  runs-on: ubuntu-latest
  steps:
    - run: echo "Deploying to production"
```

**Environment Protection Rules** (Settings > Environments):
- Required reviewers (similar to `when: manual`)
- Wait timer
- Deployment branches

## Conditional Execution

### GitLab CI/CD
```yaml
job:
  script:
    - echo "Running"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - changes:
        - src/**/*
  # OR using legacy syntax
  only:
    - main
    - merge_requests
  except:
    - tags
```

### GitHub Actions
```yaml
job:
  if: |
    github.ref == 'refs/heads/main' ||
    github.event_name == 'pull_request'
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4
    - run: echo "Running"
```

For path filtering:
```yaml
on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
```

## Matrix Builds

### GitLab CI/CD
```yaml
test:
  parallel:
    matrix:
      - DOTNET_VERSION: ['8.0', '9.0', '10.0']
  script:
    - dotnet test --framework net$DOTNET_VERSION
```

### GitHub Actions
```yaml
test:
  strategy:
    matrix:
      dotnet-version: ['8.0', '9.0', '10.0']
  runs-on: ubuntu-latest
  steps:
    - uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
    - run: dotnet test
```

## Migration Checklist

- [ ] Move `.gitlab-ci.yml` logic to `.github/workflows/`
- [ ] Convert GitLab variables to GitHub secrets
- [ ] Update `$CI_*` variables to `${{ github.* }}`
- [ ] Change `script:` to `steps:` with `run:`
- [ ] Convert `only:`/`except:` to `if:` conditions
- [ ] Replace `extends:` with reusable workflows if needed
- [ ] Update Docker registry from GitLab to GitHub (`ghcr.io`)
- [ ] Configure environment protection rules
- [ ] Set up branch protection rules
- [ ] Test SSH access from GitHub Actions runners
- [ ] Update documentation with new workflow triggers

## Quick Reference Card

```
# Access secrets
GitLab:  $MY_SECRET  or  ${{ env.MY_SECRET }}
GitHub:  ${{ secrets.MY_SECRET }}

# Access commit SHA
GitLab:  $CI_COMMIT_SHA
GitHub:  ${{ github.sha }}

# Access branch name
GitLab:  $CI_COMMIT_REF_NAME
GitHub:  ${{ github.ref_name }}

# Run on specific branch
GitLab:  only: [ main ]
GitHub:  if: github.ref == 'refs/heads/main'

# Manual trigger
GitLab:  when: manual
GitHub:  workflow_dispatch (in 'on:' section)

# Job dependencies
GitLab:  stage: deploy (stages run in order)
GitHub:  needs: [build, test]

# Docker registry
GitLab:  $CI_REGISTRY/group/project
GitHub:  ghcr.io/username/repository
```
</file>

<file path=".github/MULTI_PLATFORM_BUILD.md">
# Multi-Platform Docker Builds

## The Problem

You encountered this error:
```
no matching manifest for linux/arm64/v8 in the manifest list entries
```

This means your Docker image was built for **AMD64 (x86_64)** architecture, but your server runs on **ARM64** architecture.

## Architecture Types

- **AMD64 (x86_64)**: Standard Intel/AMD processors (most cloud servers, desktops, laptops)
- **ARM64 (aarch64)**: ARM-based processors (Raspberry Pi, Apple Silicon M1/M2, AWS Graviton, Oracle ARM instances)

## How to Check Your Server Architecture

SSH into your server and run:
```bash
uname -m
```

Output examples:
- `x86_64` = AMD64 architecture
- `aarch64` or `arm64` = ARM64 architecture

Or check with:
```bash
dpkg --print-architecture
```

## The Solution

Build Docker images for **multiple platforms** so they work on any server type.

### What Changed in the Workflow

In `.github/workflows/main.yml`, I added the `platforms` parameter:

```yaml
- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    context: .
    file: ./src/DnDMapBuilder.Api/Dockerfile
    platforms: linux/amd64,linux/arm64  # â† Added this line
    push: true
    tags: ${{ steps.meta.outputs.tags }}
    labels: ${{ steps.meta.outputs.labels }}
```

This tells Docker to build images for both:
- `linux/amd64` - Standard x86_64 servers
- `linux/arm64` - ARM-based servers

## How Multi-Platform Images Work

1. **Build Time**: GitHub Actions builds the image twice (once for each architecture)
2. **Push Time**: Both images are pushed to the registry with the same tag
3. **Pull Time**: Docker automatically selects the correct architecture for your server

When you run `docker pull ghcr.io/mikedeik/dndmapbuilder-api:latest`, Docker will:
- Pull the ARM64 version on ARM servers
- Pull the AMD64 version on x86_64 servers

## Verifying Multi-Platform Support

After the next build, check your image on GitHub Container Registry:

1. Go to: https://github.com/users/mikedeik/packages/container/dndmapbuilder-api
2. Click on a tag (e.g., `latest`)
3. Look for "OS/Arch" - you should see both:
   - `linux/amd64`
   - `linux/arm64`

Or check via CLI:
```bash
docker manifest inspect ghcr.io/mikedeik/dndmapbuilder-api:latest
```

You should see two manifests listed.

## Build Time Impact

Multi-platform builds take longer because:
- Each platform is built separately
- ARM builds on AMD64 runners use QEMU emulation (slower)

Typical build times:
- Single platform (amd64): 2-5 minutes
- Multi-platform (amd64 + arm64): 5-15 minutes

## Optimizations

### Option 1: Build Only for Your Server Architecture

If you only deploy to ARM64 servers, change to:
```yaml
platforms: linux/arm64
```

If you only deploy to AMD64 servers, change to:
```yaml
platforms: linux/amd64
```

Or remove the `platforms` line entirely (defaults to AMD64).

### Option 2: Use Native Runners

For faster ARM64 builds, use native ARM64 runners:
```yaml
build-docker:
  strategy:
    matrix:
      include:
        - platform: linux/amd64
          runner: ubuntu-latest
        - platform: linux/arm64
          runner: ubuntu-24.04-arm  # GitHub's ARM runners
```

Note: GitHub's ARM runners are currently in beta and may require a paid plan.

### Option 3: Conditional Builds

Build for multiple platforms only on releases:
```yaml
- name: Set platforms
  id: platforms
  run: |
    if [[ "${{ github.ref }}" == "refs/tags/v"* ]]; then
      echo "platforms=linux/amd64,linux/arm64" >> $GITHUB_OUTPUT
    else
      echo "platforms=linux/amd64" >> $GITHUB_OUTPUT
    fi

- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    platforms: ${{ steps.platforms.outputs.platforms }}
    # ... rest of config
```

## Troubleshooting

### Build fails with "exec format error"

This means you're trying to run an image built for a different architecture. Solution:
- Ensure multi-platform build is enabled
- Pull the latest image after the new build completes

### "Cannot connect to Docker daemon during build"

QEMU might not be set up properly. The workflow already includes `docker/setup-buildx-action@v3` which handles this automatically.

### Slow builds

ARM64 builds on AMD64 runners are slow due to QEMU emulation. This is normal. Consider:
- Building only for your target architecture
- Using native ARM runners (if available)
- Caching layers aggressively

## Common Server Types

| Provider | Service | Architecture |
|----------|---------|--------------|
| AWS | EC2 (t3, m5, c5) | AMD64 |
| AWS | EC2 (t4g, m6g, c6g) Graviton | ARM64 |
| DigitalOcean | Standard Droplets | AMD64 |
| Oracle Cloud | VM.Standard.E2.1.Micro (Free Tier) | AMD64 |
| Oracle Cloud | VM.Standard.A1.Flex (Free Tier) | ARM64 |
| Raspberry Pi | All models | ARM64 |
| Apple Silicon | M1/M2 Macs | ARM64 |
| Google Cloud | N1, N2, E2 | AMD64 |
| Google Cloud | T2A (Tau) | ARM64 |

## Next Steps

1. Commit and push the updated workflow
2. Let the build complete (will take longer this time)
3. Retry deployment - it should now work on your ARM64 server
</file>

<file path="src/DnDMapBuilder.Api/Controllers/AuthController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IAuthService _authService;

    public AuthController(IAuthService authService)
    {
        _authService = authService;
    }

    [HttpPost("register")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> Register([FromBody] RegisterRequest request)
    {
        var result = await _authService.RegisterAsync(request);
        
        if (result == null)
        {
            return BadRequest(new ApiResponse<AuthResponse>(
                false,
                null,
                "Registration failed. User may already exist."
            ));
        }

        return Ok(new ApiResponse<AuthResponse>(true, result, "Registration successful. Awaiting admin approval."));
    }

    [HttpPost("login")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> Login([FromBody] LoginRequest request)
    {
        var result = await _authService.LoginAsync(request);
        
        if (result == null)
        {
            return Unauthorized(new ApiResponse<AuthResponse>(
                false,
                null,
                "Invalid credentials or account not approved."
            ));
        }

        return Ok(new ApiResponse<AuthResponse>(true, result, "Login successful."));
    }

    [Authorize(Roles = "admin")]
    [HttpGet("pending-users")]
    public async Task<ActionResult<ApiResponse<IEnumerable<UserDto>>>> GetPendingUsers()
    {
        var users = await _authService.GetPendingUsersAsync();
        return Ok(new ApiResponse<IEnumerable<UserDto>>(true, users));
    }

    [Authorize(Roles = "admin")]
    [HttpPost("approve-user")]
    public async Task<ActionResult<ApiResponse<bool>>> ApproveUser([FromBody] ApproveUserRequest request)
    {
        var result = await _authService.ApproveUserAsync(request.UserId, request.Approved);
        
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "User not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "User status updated."));
    }
}
</file>

<file path="src/DnDMapBuilder.Api/Controllers/CampaignsController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class CampaignsController : ControllerBase
{
    private readonly ICampaignService _campaignService;

    public CampaignsController(ICampaignService campaignService)
    {
        _campaignService = campaignService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    [HttpGet]
    public async Task<ActionResult<ApiResponse<IEnumerable<CampaignDto>>>> GetUserCampaigns()
    {
        var campaigns = await _campaignService.GetUserCampaignsAsync(GetUserId());
        return Ok(new ApiResponse<IEnumerable<CampaignDto>>(true, campaigns));
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> GetCampaign(string id)
    {
        var campaign = await _campaignService.GetByIdAsync(id, GetUserId());
        
        if (campaign == null)
        {
            return NotFound(new ApiResponse<CampaignDto>(false, null, "Campaign not found."));
        }

        return Ok(new ApiResponse<CampaignDto>(true, campaign));
    }

    [HttpPost]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> CreateCampaign([FromBody] CreateCampaignRequest request)
    {
        var campaign = await _campaignService.CreateAsync(request, GetUserId());
        return CreatedAtAction(nameof(GetCampaign), new { id = campaign.Id }, new ApiResponse<CampaignDto>(true, campaign, "Campaign created."));
    }

    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> UpdateCampaign(string id, [FromBody] UpdateCampaignRequest request)
    {
        var campaign = await _campaignService.UpdateAsync(id, request, GetUserId());
        
        if (campaign == null)
        {
            return NotFound(new ApiResponse<CampaignDto>(false, null, "Campaign not found."));
        }

        return Ok(new ApiResponse<CampaignDto>(true, campaign, "Campaign updated."));
    }

    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteCampaign(string id)
    {
        var result = await _campaignService.DeleteAsync(id, GetUserId());
        
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Campaign not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Campaign deleted."));
    }
}
</file>

<file path="src/DnDMapBuilder.AppHost/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Aspire.Hosting.Dcp": "Warning"
    }
  }
}
</file>

<file path="src/DnDMapBuilder.AppHost/DnDMapBuilder.AppHost.csproj">
<Project Sdk="Aspire.AppHost.Sdk/13.1.0">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net10.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <UserSecretsId>341d30cb-17ac-469c-8407-79b6afe8eb3b</UserSecretsId>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Aspire.Hosting.SqlServer" Version="13.1.0" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Application/Services/AuthService.cs">
using BCrypt.Net;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;

namespace DnDMapBuilder.Application.Services;

public class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IJwtService _jwtService;

    public AuthService(IUserRepository userRepository, IJwtService jwtService)
    {
        _userRepository = userRepository;
        _jwtService = jwtService;
    }

    public async Task<AuthResponse?> RegisterAsync(RegisterRequest request)
    {
        // Check if user already exists
        var existingUser = await _userRepository.GetByEmailAsync(request.Email);
        if (existingUser != null)
        {
            return null; // User already exists
        }

        var existingUsername = await _userRepository.GetByUsernameAsync(request.Username);
        if (existingUsername != null)
        {
            return null; // Username already taken
        }

        // Create new user
        var user = new User
        {
            Id = Guid.NewGuid().ToString(),
            Username = request.Username,
            Email = request.Email,
            PasswordHash = BCrypt.Net.BCrypt.HashPassword(request.Password),
            Role = "user",
            Status = "pending", // Requires admin approval
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _userRepository.AddAsync(user);

        var token = _jwtService.GenerateToken(user.Id, user.Email, user.Role);

        return new AuthResponse(
            token,
            user.Id,
            user.Username,
            user.Email,
            user.Role,
            user.Status
        );
    }

    public async Task<AuthResponse?> LoginAsync(LoginRequest request)
    {
        var user = await _userRepository.GetByEmailAsync(request.Email);
        if (user == null)
        {
            return null; // User not found
        }

        if (!BCrypt.Net.BCrypt.Verify(request.Password, user.PasswordHash))
        {
            return null; // Invalid password
        }

        if (user.Status != "approved" && user.Role != "admin")
        {
            return null; // User not approved yet
        }

        var token = _jwtService.GenerateToken(user.Id, user.Email, user.Role);

        return new AuthResponse(
            token,
            user.Id,
            user.Username,
            user.Email,
            user.Role,
            user.Status
        );
    }

    public async Task<bool> ApproveUserAsync(string userId, bool approved)
    {
        var user = await _userRepository.GetByIdAsync(userId);
        if (user == null)
        {
            return false;
        }

        user.Status = approved ? "approved" : "rejected";
        user.UpdatedAt = DateTime.UtcNow;

        await _userRepository.UpdateAsync(user);
        return true;
    }

    public async Task<IEnumerable<UserDto>> GetPendingUsersAsync()
    {
        var users = await _userRepository.GetPendingUsersAsync();
        return users.Select(u => u.ToDto());
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/CampaignService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;

namespace DnDMapBuilder.Application.Services;

public class CampaignService : ICampaignService
{
    private readonly ICampaignRepository _campaignRepository;

    public CampaignService(ICampaignRepository campaignRepository)
    {
        _campaignRepository = campaignRepository;
    }

    public async Task<CampaignDto?> GetByIdAsync(string id, string userId)
    {
        var campaign = await _campaignRepository.GetCompleteAsync(id);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        return campaign.ToDto();
    }

    public async Task<IEnumerable<CampaignDto>> GetUserCampaignsAsync(string userId)
    {
        var campaigns = await _campaignRepository.GetByOwnerIdAsync(userId);
        return campaigns.Select(c => c.ToDto());
    }

    public async Task<CampaignDto> CreateAsync(CreateCampaignRequest request, string userId)
    {
        var campaign = new Campaign
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            Description = request.Description,
            OwnerId = userId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _campaignRepository.AddAsync(campaign);
        return campaign.ToDto();
    }

    public async Task<CampaignDto?> UpdateAsync(string id, UpdateCampaignRequest request, string userId)
    {
        var campaign = await _campaignRepository.GetByIdAsync(id);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        campaign.Name = request.Name;
        campaign.Description = request.Description;
        campaign.UpdatedAt = DateTime.UtcNow;

        await _campaignRepository.UpdateAsync(campaign);
        return campaign.ToDto();
    }

    public async Task<bool> DeleteAsync(string id, string userId)
    {
        var campaign = await _campaignRepository.GetByIdAsync(id);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return false;
        }

        await _campaignRepository.DeleteAsync(id);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/FileStorageService.cs">
using Microsoft.Extensions.Logging;
using DnDMapBuilder.Application.Interfaces;

namespace DnDMapBuilder.Application.Services;

public class LocalFileStorageService : IFileStorageService
{
    private readonly string _baseStoragePath;
    private readonly string _basePublicUrl;
    private readonly ILogger<LocalFileStorageService> _logger;

    public LocalFileStorageService(string baseStoragePath, string basePublicUrl, ILogger<LocalFileStorageService> logger)
    {
        _baseStoragePath = baseStoragePath ?? throw new ArgumentNullException(nameof(baseStoragePath));
        _basePublicUrl = basePublicUrl ?? throw new ArgumentNullException(nameof(basePublicUrl));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        EnsureStorageDirectoriesExist();
    }

    public async Task<string> UploadAsync(Stream file, string fileName, string contentType, string storageCategory)
    {
        if (file == null || file.Length == 0)
            throw new ArgumentException("File stream is empty", nameof(file));

        if (string.IsNullOrWhiteSpace(fileName))
            throw new ArgumentException("File name is required", nameof(fileName));

        if (string.IsNullOrWhiteSpace(contentType))
            throw new ArgumentException("Content type is required", nameof(contentType));

        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));

        // Validate MIME type
        var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
        if (!allowedMimeTypes.Contains(contentType.ToLower()))
            throw new InvalidOperationException($"MIME type '{contentType}' is not allowed");

        // Generate file ID with extension
        var fileExtension = Path.GetExtension(fileName);
        if (string.IsNullOrWhiteSpace(fileExtension))
            fileExtension = GetExtensionFromMimeType(contentType);

        var fileId = $"{Guid.NewGuid()}{fileExtension}";
        var categoryPath = Path.Combine(_baseStoragePath, storageCategory);
        var fullFilePath = Path.Combine(categoryPath, fileId);

        // Ensure directory exists
        if (!Directory.Exists(categoryPath))
            Directory.CreateDirectory(categoryPath);

        try
        {
            // Save file to disk using streaming (no full buffering)
            using (var fileStream = new FileStream(fullFilePath, FileMode.Create, FileAccess.Write, FileShare.None, 4096, useAsync: true))
            {
                await file.CopyToAsync(fileStream);
            }

            _logger.LogInformation($"File uploaded successfully: {fileId} to category {storageCategory}");
            return fileId;
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error uploading file: {ex.Message}");
            if (File.Exists(fullFilePath))
                File.Delete(fullFilePath);
            throw;
        }
    }

    public string GetPublicUrl(string fileId, string storageCategory)
    {
        if (string.IsNullOrWhiteSpace(fileId))
            throw new ArgumentException("File ID is required", nameof(fileId));

        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));

        // Prevent path traversal attacks
        if (fileId.Contains("..") || fileId.Contains("/") || fileId.Contains("\\"))
            throw new InvalidOperationException("Invalid file ID");

        return $"{_basePublicUrl}/{storageCategory}/{fileId}";
    }

    public async Task<bool> DeleteAsync(string fileId, string storageCategory)
    {
        if (string.IsNullOrWhiteSpace(fileId))
            throw new ArgumentException("File ID is required", nameof(fileId));

        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));

        // Prevent path traversal attacks
        if (fileId.Contains("..") || fileId.Contains("/") || fileId.Contains("\\"))
            throw new InvalidOperationException("Invalid file ID");

        var categoryPath = Path.Combine(_baseStoragePath, storageCategory);
        var fullFilePath = Path.Combine(categoryPath, fileId);

        try
        {
            if (File.Exists(fullFilePath))
            {
                File.Delete(fullFilePath);
                _logger.LogInformation($"File deleted successfully: {fileId} from category {storageCategory}");
                return true;
            }

            _logger.LogWarning($"File not found for deletion: {fileId} in category {storageCategory}");
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error deleting file: {ex.Message}");
            throw;
        }
    }

    private void EnsureStorageDirectoriesExist()
    {
        var categories = new[] { "maps", "tokens" };
        foreach (var category in categories)
        {
            var categoryPath = Path.Combine(_baseStoragePath, category);
            if (!Directory.Exists(categoryPath))
                Directory.CreateDirectory(categoryPath);
        }
    }

    private string GetExtensionFromMimeType(string mimeType)
    {
        return mimeType.ToLower() switch
        {
            "image/png" => ".png",
            "image/jpeg" => ".jpg",
            "image/webp" => ".webp",
            _ => ".bin"
        };
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/GameMapAndTokenServices.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;

namespace DnDMapBuilder.Application.Services;

public class GameMapService : IGameMapService
{
    private readonly IGameMapRepository _mapRepository;
    private readonly IMissionRepository _missionRepository;
    private readonly ICampaignRepository _campaignRepository;
    private readonly IMapTokenInstanceRepository _tokenInstanceRepository;

    public GameMapService(
        IGameMapRepository mapRepository,
        IMissionRepository missionRepository,
        ICampaignRepository campaignRepository,
        IMapTokenInstanceRepository tokenInstanceRepository)
    {
        _mapRepository = mapRepository;
        _missionRepository = missionRepository;
        _campaignRepository = campaignRepository;
        _tokenInstanceRepository = tokenInstanceRepository;
    }

    public async Task<GameMapDto?> GetByIdAsync(string id, string userId)
    {
        var map = await _mapRepository.GetWithTokensAsync(id);
        if (map == null)
        {
            return null;
        }

        if (!await HasAccessToMapAsync(map.MissionId, userId))
        {
            return null;
        }

        return map.ToDto();
    }

    public async Task<IEnumerable<GameMapDto>> GetByMissionIdAsync(string missionId, string userId)
    {
        if (!await HasAccessToMapAsync(missionId, userId))
        {
            return Enumerable.Empty<GameMapDto>();
        }

        var maps = await _mapRepository.GetByMissionIdAsync(missionId);
        return maps.Select(m => m.ToDto());
    }

    public async Task<GameMapDto> CreateAsync(CreateMapRequest request, string userId)
    {
        if (!await HasAccessToMapAsync(request.MissionId, userId))
        {
            throw new UnauthorizedAccessException("You don't have permission to add maps to this mission.");
        }

        var map = new GameMap
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            ImageUrl = request.ImageUrl,
            Rows = request.Rows,
            Cols = request.Cols,
            GridColor = request.GridColor,
            GridOpacity = request.GridOpacity,
            MissionId = request.MissionId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _mapRepository.AddAsync(map);
        return map.ToDto();
    }

    public async Task<GameMapDto?> UpdateAsync(string id, UpdateMapRequest request, string userId)
    {
        var map = await _mapRepository.GetByIdAsync(id);
        if (map == null)
        {
            return null;
        }

        if (!await HasAccessToMapAsync(map.MissionId, userId))
        {
            return null;
        }

        map.Name = request.Name;
        map.ImageUrl = request.ImageUrl;
        map.Rows = request.Rows;
        map.Cols = request.Cols;
        map.GridColor = request.GridColor;
        map.GridOpacity = request.GridOpacity;
        map.UpdatedAt = DateTime.UtcNow;

        // Update tokens
        await _tokenInstanceRepository.DeleteByMapIdAsync(map.Id);
        
        foreach (var tokenReq in request.Tokens)
        {
            var tokenInstance = new MapTokenInstance
            {
                Id = Guid.NewGuid().ToString(),
                TokenId = tokenReq.TokenId,
                MapId = map.Id,
                X = tokenReq.X,
                Y = tokenReq.Y,
                CreatedAt = DateTime.UtcNow
            };
            await _tokenInstanceRepository.AddAsync(tokenInstance);
        }

        await _mapRepository.UpdateAsync(map);
        
        var updatedMap = await _mapRepository.GetWithTokensAsync(id);
        return updatedMap?.ToDto();
    }

    public async Task<bool> DeleteAsync(string id, string userId)
    {
        var map = await _mapRepository.GetByIdAsync(id);
        if (map == null)
        {
            return false;
        }

        if (!await HasAccessToMapAsync(map.MissionId, userId))
        {
            return false;
        }

        await _mapRepository.DeleteAsync(id);
        return true;
    }

    private async Task<bool> HasAccessToMapAsync(string missionId, string userId)
    {
        var mission = await _missionRepository.GetByIdAsync(missionId);
        if (mission == null)
        {
            return false;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId);
        return campaign != null && campaign.OwnerId == userId;
    }
}

public class TokenDefinitionService : ITokenDefinitionService
{
    private readonly ITokenDefinitionRepository _tokenRepository;

    public TokenDefinitionService(ITokenDefinitionRepository tokenRepository)
    {
        _tokenRepository = tokenRepository;
    }

    public async Task<TokenDefinitionDto?> GetByIdAsync(string id, string userId)
    {
        var token = await _tokenRepository.GetByIdAsync(id);
        if (token == null || token.UserId != userId)
        {
            return null;
        }

        return token.ToDto();
    }

    public async Task<IEnumerable<TokenDefinitionDto>> GetUserTokensAsync(string userId)
    {
        var tokens = await _tokenRepository.GetByUserIdAsync(userId);
        return tokens.Select(t => t.ToDto());
    }

    public async Task<TokenDefinitionDto> CreateAsync(CreateTokenDefinitionRequest request, string userId)
    {
        var token = new TokenDefinition
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            ImageUrl = request.ImageUrl,
            Size = request.Size,
            Type = request.Type,
            UserId = userId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _tokenRepository.AddAsync(token);
        return token.ToDto();
    }

    public async Task<TokenDefinitionDto?> UpdateAsync(string id, UpdateTokenDefinitionRequest request, string userId)
    {
        var token = await _tokenRepository.GetByIdAsync(id);
        if (token == null || token.UserId != userId)
        {
            return null;
        }

        token.Name = request.Name;
        token.ImageUrl = request.ImageUrl;
        token.Size = request.Size;
        token.Type = request.Type;
        token.UpdatedAt = DateTime.UtcNow;

        await _tokenRepository.UpdateAsync(token);
        return token.ToDto();
    }

    public async Task<bool> DeleteAsync(string id, string userId)
    {
        var token = await _tokenRepository.GetByIdAsync(id);
        if (token == null || token.UserId != userId)
        {
            return false;
        }

        await _tokenRepository.DeleteAsync(id);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/JwtService.cs">
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;
using DnDMapBuilder.Application.Interfaces;

namespace DnDMapBuilder.Application.Services;

public class JwtService : IJwtService
{
    private readonly string _secret;
    private readonly string _issuer;
    private readonly string _audience;
    private readonly int _expirationMinutes;

    public JwtService(string secret, string issuer, string audience, int expirationMinutes = 1440)
    {
        _secret = secret;
        _issuer = issuer;
        _audience = audience;
        _expirationMinutes = expirationMinutes;
    }

    public string GenerateToken(string userId, string email, string role)
    {
        var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_secret));
        var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId),
            new Claim(JwtRegisteredClaimNames.Email, email),
            new Claim(ClaimTypes.Role, role),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var token = new JwtSecurityToken(
            issuer: _issuer,
            audience: _audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_expirationMinutes),
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    public string? ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_secret);

        try
        {
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = _issuer,
                ValidateAudience = true,
                ValidAudience = _audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };

            var principal = tokenHandler.ValidateToken(token, validationParameters, out var validatedToken);
            var jwtToken = (JwtSecurityToken)validatedToken;
            var userId = jwtToken.Claims.First(x => x.Type == JwtRegisteredClaimNames.Sub).Value;

            return userId;
        }
        catch
        {
            return null;
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/MissionService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;

namespace DnDMapBuilder.Application.Services;

public class MissionService : IMissionService
{
    private readonly IMissionRepository _missionRepository;
    private readonly ICampaignRepository _campaignRepository;

    public MissionService(IMissionRepository missionRepository, ICampaignRepository campaignRepository)
    {
        _missionRepository = missionRepository;
        _campaignRepository = campaignRepository;
    }

    public async Task<MissionDto?> GetByIdAsync(string id, string userId)
    {
        var mission = await _missionRepository.GetWithMapsAsync(id);
        if (mission == null)
        {
            return null;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        return mission.ToDto();
    }

    public async Task<IEnumerable<MissionDto>> GetByCampaignIdAsync(string campaignId, string userId)
    {
        var campaign = await _campaignRepository.GetByIdAsync(campaignId);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return Enumerable.Empty<MissionDto>();
        }

        var missions = await _missionRepository.GetByCampaignIdAsync(campaignId);
        return missions.Select(m => m.ToDto());
    }

    public async Task<MissionDto> CreateAsync(CreateMissionRequest request, string userId)
    {
        var campaign = await _campaignRepository.GetByIdAsync(request.CampaignId);
        if (campaign == null || campaign.OwnerId != userId)
        {
            throw new UnauthorizedAccessException("You don't have permission to add missions to this campaign.");
        }

        var mission = new Mission
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            Description = request.Description,
            CampaignId = request.CampaignId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _missionRepository.AddAsync(mission);
        return mission.ToDto();
    }

    public async Task<MissionDto?> UpdateAsync(string id, UpdateMissionRequest request, string userId)
    {
        var mission = await _missionRepository.GetByIdAsync(id);
        if (mission == null)
        {
            return null;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        mission.Name = request.Name;
        mission.Description = request.Description;
        mission.UpdatedAt = DateTime.UtcNow;

        await _missionRepository.UpdateAsync(mission);
        return mission.ToDto();
    }

    public async Task<bool> DeleteAsync(string id, string userId)
    {
        var mission = await _missionRepository.GetByIdAsync(id);
        if (mission == null)
        {
            return false;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return false;
        }

        await _missionRepository.DeleteAsync(id);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/DnDMapBuilder.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
    <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="8.3.0" />
    <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.3.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Aspire.ServiceDefaults/DnDMapBuilder.Aspire.ServiceDefaults.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsAspireSharedProject>true</IsAspireSharedProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Http.Resilience" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.ServiceDiscovery" Version="9.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.10.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" Version="1.10.0" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Aspire.ServiceDefaults/Extensions.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

namespace Microsoft.Extensions.Hosting;

public static class Extensions
{
    public static IHostApplicationBuilder AddServiceDefaults(this IHostApplicationBuilder builder)
    {
        builder.ConfigureOpenTelemetry();

        builder.AddDefaultHealthChecks();

        builder.Services.AddServiceDiscovery();

        builder.Services.ConfigureHttpClientDefaults(http =>
        {
            http.AddStandardResilienceHandler();
            http.AddServiceDiscovery();
        });

        return builder;
    }

    public static IHostApplicationBuilder ConfigureOpenTelemetry(this IHostApplicationBuilder builder)
    {
        builder.Logging.AddOpenTelemetry(logging =>
        {
            logging.IncludeFormattedMessage = true;
            logging.IncludeScopes = true;
        });

        builder.Services.AddOpenTelemetry()
            .WithMetrics(metrics =>
            {
                metrics.AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation()
                    .AddRuntimeInstrumentation();
            })
            .WithTracing(tracing =>
            {
                tracing.AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation();
            });

        builder.AddOpenTelemetryExporters();

        return builder;
    }

    private static IHostApplicationBuilder AddOpenTelemetryExporters(this IHostApplicationBuilder builder)
    {
        var useOtlpExporter = !string.IsNullOrWhiteSpace(builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"]);

        if (useOtlpExporter)
        {
            builder.Services.AddOpenTelemetry().UseOtlpExporter();
        }

        return builder;
    }

    public static IHostApplicationBuilder AddDefaultHealthChecks(this IHostApplicationBuilder builder)
    {
        builder.Services.AddHealthChecks()
            .AddCheck("self", () => HealthCheckResult.Healthy(), ["live"]);

        return builder;
    }

    public static WebApplication MapDefaultEndpoints(this WebApplication app)
    {
        app.MapHealthChecks("/health");
        app.MapHealthChecks("/alive", new HealthCheckOptions
        {
            Predicate = r => r.Tags.Contains("live")
        });

        return app;
    }
}
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/ApiResponses.cs">
namespace DnDMapBuilder.Contracts.Responses;

public record AuthResponse(
    string Token,
    string UserId,
    string Username,
    string Email,
    string Role,
    string Status
);

public record ApiResponse<T>(
    bool Success,
    T? Data,
    string? Message = null,
    List<string>? Errors = null
);

public record PaginatedResponse<T>(
    List<T> Items,
    int Page,
    int PageSize,
    int TotalCount,
    int TotalPages
);
</file>

<file path="src/DnDMapBuilder.Contracts/DnDMapBuilder.Contracts.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260114100522_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Username = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false),
                    Email = table.Column<string>(type: "nvarchar(255)", maxLength: 255, nullable: false),
                    PasswordHash = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Role = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    Status = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Campaigns",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    Description = table.Column<string>(type: "nvarchar(2000)", maxLength: 2000, nullable: false),
                    OwnerId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Campaigns", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Campaigns_Users_OwnerId",
                        column: x => x.OwnerId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "TokenDefinitions",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    ImageUrl = table.Column<string>(type: "nvarchar(1000)", maxLength: 1000, nullable: false),
                    Size = table.Column<int>(type: "int", nullable: false),
                    Type = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    UserId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_TokenDefinitions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_TokenDefinitions_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Missions",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    Description = table.Column<string>(type: "nvarchar(2000)", maxLength: 2000, nullable: false),
                    CampaignId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Missions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Missions_Campaigns_CampaignId",
                        column: x => x.CampaignId,
                        principalTable: "Campaigns",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "GameMaps",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    ImageUrl = table.Column<string>(type: "nvarchar(1000)", maxLength: 1000, nullable: true),
                    Rows = table.Column<int>(type: "int", nullable: false),
                    Cols = table.Column<int>(type: "int", nullable: false),
                    GridColor = table.Column<string>(type: "nvarchar(20)", maxLength: 20, nullable: false),
                    GridOpacity = table.Column<double>(type: "float", nullable: false),
                    MissionId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_GameMaps", x => x.Id);
                    table.ForeignKey(
                        name: "FK_GameMaps_Missions_MissionId",
                        column: x => x.MissionId,
                        principalTable: "Missions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "MapTokenInstances",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    TokenId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    MapId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    X = table.Column<int>(type: "int", nullable: false),
                    Y = table.Column<int>(type: "int", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_MapTokenInstances", x => x.Id);
                    table.ForeignKey(
                        name: "FK_MapTokenInstances_GameMaps_MapId",
                        column: x => x.MapId,
                        principalTable: "GameMaps",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                        column: x => x.TokenId,
                        principalTable: "TokenDefinitions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.InsertData(
                table: "Users",
                columns: new[] { "Id", "CreatedAt", "Email", "PasswordHash", "Role", "Status", "UpdatedAt", "Username" },
                values: new object[] { "admin-seed-id", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin@dndmapbuilder.com", "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S", "admin", "approved", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin" });

            migrationBuilder.CreateIndex(
                name: "IX_Campaigns_OwnerId",
                table: "Campaigns",
                column: "OwnerId");

            migrationBuilder.CreateIndex(
                name: "IX_GameMaps_MissionId",
                table: "GameMaps",
                column: "MissionId");

            migrationBuilder.CreateIndex(
                name: "IX_MapTokenInstances_MapId",
                table: "MapTokenInstances",
                column: "MapId");

            migrationBuilder.CreateIndex(
                name: "IX_MapTokenInstances_TokenId",
                table: "MapTokenInstances",
                column: "TokenId");

            migrationBuilder.CreateIndex(
                name: "IX_Missions_CampaignId",
                table: "Missions",
                column: "CampaignId");

            migrationBuilder.CreateIndex(
                name: "IX_TokenDefinitions_UserId",
                table: "TokenDefinitions",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_Users_Email",
                table: "Users",
                column: "Email",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Users_Username",
                table: "Users",
                column: "Username",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "MapTokenInstances");

            migrationBuilder.DropTable(
                name: "GameMaps");

            migrationBuilder.DropTable(
                name: "TokenDefinitions");

            migrationBuilder.DropTable(
                name: "Missions");

            migrationBuilder.DropTable(
                name: "Campaigns");

            migrationBuilder.DropTable(
                name: "Users");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260114100522_InitialCreate.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260114100522_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260115221337_PendingModelChanges.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class PendingModelChanges : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260115221337_PendingModelChanges.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260115221337_PendingModelChanges")]
    partial class PendingModelChanges
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116231211_UpdateAdminPasswordHash.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class UpdateAdminPasswordHash : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.UpdateData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id",
                column: "PasswordHash",
                value: "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.UpdateData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id",
                column: "PasswordHash",
                value: "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116231211_UpdateAdminPasswordHash.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260116231211_UpdateAdminPasswordHash")]
    partial class UpdateAdminPasswordHash
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116232059_RemoveSeedData.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class RemoveSeedData : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DeleteData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.InsertData(
                table: "Users",
                columns: new[] { "Id", "CreatedAt", "Email", "PasswordHash", "Role", "Status", "UpdatedAt", "Username" },
                values: new object[] { "admin-seed-id", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin@dndmapbuilder.com", "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq", "admin", "approved", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin" });
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116232059_RemoveSeedData.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260116232059_RemoveSeedData")]
    partial class RemoveSeedData
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117102707_AddImageFileStorageMetadata.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class AddImageFileStorageMetadata : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "ImageContentType",
                table: "TokenDefinitions",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "ImageFileId",
                table: "TokenDefinitions",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<long>(
                name: "ImageFileSize",
                table: "TokenDefinitions",
                type: "bigint",
                nullable: false,
                defaultValue: 0L);

            migrationBuilder.AddColumn<string>(
                name: "ImageContentType",
                table: "GameMaps",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "ImageFileId",
                table: "GameMaps",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<long>(
                name: "ImageFileSize",
                table: "GameMaps",
                type: "bigint",
                nullable: false,
                defaultValue: 0L);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "ImageContentType",
                table: "TokenDefinitions");

            migrationBuilder.DropColumn(
                name: "ImageFileId",
                table: "TokenDefinitions");

            migrationBuilder.DropColumn(
                name: "ImageFileSize",
                table: "TokenDefinitions");

            migrationBuilder.DropColumn(
                name: "ImageContentType",
                table: "GameMaps");

            migrationBuilder.DropColumn(
                name: "ImageFileId",
                table: "GameMaps");

            migrationBuilder.DropColumn(
                name: "ImageFileSize",
                table: "GameMaps");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117102707_AddImageFileStorageMetadata.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117102707_AddImageFileStorageMetadata")]
    partial class AddImageFileStorageMetadata
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117104633_SaveImageFiles.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class SaveImageFiles : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117104633_SaveImageFiles.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117104633_SaveImageFiles")]
    partial class SaveImageFiles
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/IRepositories.cs">
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories;

public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(string id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<T> AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(string id);
    Task<bool> ExistsAsync(string id);
}

public interface IUserRepository : IRepository<User>
{
    Task<User?> GetByEmailAsync(string email);
    Task<User?> GetByUsernameAsync(string username);
    Task<IEnumerable<User>> GetPendingUsersAsync();
    Task<IEnumerable<User>> GetUsersByRoleAsync(string role);
}

public interface ICampaignRepository : IRepository<Campaign>
{
    Task<IEnumerable<Campaign>> GetByOwnerIdAsync(string ownerId);
    Task<Campaign?> GetWithMissionsAsync(string id);
    Task<Campaign?> GetCompleteAsync(string id); // With all related data
}

public interface IMissionRepository : IRepository<Mission>
{
    Task<IEnumerable<Mission>> GetByCampaignIdAsync(string campaignId);
    Task<Mission?> GetWithMapsAsync(string id);
}

public interface IGameMapRepository : IRepository<GameMap>
{
    Task<IEnumerable<GameMap>> GetByMissionIdAsync(string missionId);
    Task<GameMap?> GetWithTokensAsync(string id);
}

public interface ITokenDefinitionRepository : IRepository<TokenDefinition>
{
    Task<IEnumerable<TokenDefinition>> GetByUserIdAsync(string userId);
    Task<IEnumerable<TokenDefinition>> GetByTypeAsync(string type);
}

public interface IMapTokenInstanceRepository : IRepository<MapTokenInstance>
{
    Task<IEnumerable<MapTokenInstance>> GetByMapIdAsync(string mapId);
    Task DeleteByMapIdAsync(string mapId);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Repositories.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories;

public class Repository<T> : IRepository<T> where T : class
{
    protected readonly DnDMapBuilderDbContext _context;
    protected readonly DbSet<T> _dbSet;

    public Repository(DnDMapBuilderDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public virtual async Task<T?> GetByIdAsync(string id)
    {
        return await _dbSet.FindAsync(id);
    }

    public virtual async Task<IEnumerable<T>> GetAllAsync()
    {
        return await _dbSet.ToListAsync();
    }

    public virtual async Task<T> AddAsync(T entity)
    {
        await _dbSet.AddAsync(entity);
        await _context.SaveChangesAsync();
        return entity;
    }

    public virtual async Task UpdateAsync(T entity)
    {
        _dbSet.Update(entity);
        await _context.SaveChangesAsync();
    }

    public virtual async Task DeleteAsync(string id)
    {
        var entity = await GetByIdAsync(id);
        if (entity != null)
        {
            _dbSet.Remove(entity);
            await _context.SaveChangesAsync();
        }
    }

    public virtual async Task<bool> ExistsAsync(string id)
    {
        return await _dbSet.FindAsync(id) != null;
    }
}

public class UserRepository : Repository<User>, IUserRepository
{
    public UserRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<User?> GetByEmailAsync(string email)
    {
        return await _dbSet.FirstOrDefaultAsync(u => u.Email == email);
    }

    public async Task<User?> GetByUsernameAsync(string username)
    {
        return await _dbSet.FirstOrDefaultAsync(u => u.Username == username);
    }

    public async Task<IEnumerable<User>> GetPendingUsersAsync()
    {
        return await _dbSet.Where(u => u.Status == "pending").ToListAsync();
    }

    public async Task<IEnumerable<User>> GetUsersByRoleAsync(string role)
    {
        return await _dbSet.Where(u => u.Role == role).ToListAsync();
    }
}

public class CampaignRepository : Repository<Campaign>, ICampaignRepository
{
    public CampaignRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<Campaign>> GetByOwnerIdAsync(string ownerId)
    {
        return await _dbSet
            .Where(c => c.OwnerId == ownerId)
            .Include(c => c.Missions)
            .ToListAsync();
    }

    public async Task<Campaign?> GetWithMissionsAsync(string id)
    {
        return await _dbSet
            .Include(c => c.Missions)
            .FirstOrDefaultAsync(c => c.Id == id);
    }

    public async Task<Campaign?> GetCompleteAsync(string id)
    {
        return await _dbSet
            .Include(c => c.Missions)
                .ThenInclude(m => m.Maps)
                    .ThenInclude(map => map.Tokens)
            .FirstOrDefaultAsync(c => c.Id == id);
    }
}

public class MissionRepository : Repository<Mission>, IMissionRepository
{
    public MissionRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<Mission>> GetByCampaignIdAsync(string campaignId)
    {
        return await _dbSet
            .Where(m => m.CampaignId == campaignId)
            .Include(m => m.Maps)
            .ToListAsync();
    }

    public async Task<Mission?> GetWithMapsAsync(string id)
    {
        return await _dbSet
            .Include(m => m.Maps)
            .FirstOrDefaultAsync(m => m.Id == id);
    }
}

public class GameMapRepository : Repository<GameMap>, IGameMapRepository
{
    public GameMapRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<GameMap>> GetByMissionIdAsync(string missionId)
    {
        return await _dbSet
            .Where(m => m.MissionId == missionId)
            .Include(m => m.Tokens)
            .ToListAsync();
    }

    public async Task<GameMap?> GetWithTokensAsync(string id)
    {
        return await _dbSet
            .Include(m => m.Tokens)
            .FirstOrDefaultAsync(m => m.Id == id);
    }
}

public class TokenDefinitionRepository : Repository<TokenDefinition>, ITokenDefinitionRepository
{
    public TokenDefinitionRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<TokenDefinition>> GetByUserIdAsync(string userId)
    {
        return await _dbSet
            .Where(t => t.UserId == userId)
            .ToListAsync();
    }

    public async Task<IEnumerable<TokenDefinition>> GetByTypeAsync(string type)
    {
        return await _dbSet
            .Where(t => t.Type == type)
            .ToListAsync();
    }
}

public class MapTokenInstanceRepository : Repository<MapTokenInstance>, IMapTokenInstanceRepository
{
    public MapTokenInstanceRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<MapTokenInstance>> GetByMapIdAsync(string mapId)
    {
        return await _dbSet
            .Where(t => t.MapId == mapId)
            .Include(t => t.Token)
            .ToListAsync();
    }

    public async Task DeleteByMapIdAsync(string mapId)
    {
        var tokens = await _dbSet.Where(t => t.MapId == mapId).ToListAsync();
        _dbSet.RemoveRange(tokens);
        await _context.SaveChangesAsync();
    }
}
</file>

<file path="src/DnDMapBuilder.Data/DbInitializer.cs">
using DnDMapBuilder.Data.Entities;
using Microsoft.EntityFrameworkCore;

namespace DnDMapBuilder.Data;

public static class DbInitializer
{
    public static async Task InitializeAsync(DnDMapBuilderDbContext context)
    {
        // Ensure database is created
        await context.Database.MigrateAsync();

        // Check if admin user already exists
        var adminEmail = Environment.GetEnvironmentVariable("ADMIN_EMAIL")
            ?? throw new InvalidOperationException("ADMIN_EMAIL environment variable is required");

        var adminPassword = Environment.GetEnvironmentVariable("ADMIN_DEFAULT_PASSWORD")
            ?? throw new InvalidOperationException("ADMIN_DEFAULT_PASSWORD environment variable is required");

        var existingAdmin = await context.Users
            .FirstOrDefaultAsync(u => u.Role == "admin" && u.Email == adminEmail);

        if (existingAdmin == null)
        {
            // Create new admin user
            var admin = new User
            {
                Id = Guid.NewGuid().ToString(),
                Username = "admin",
                Email = adminEmail,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(adminPassword, 11),
                Role = "admin",
                Status = "approved",
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            context.Users.Add(admin);
            await context.SaveChangesAsync();

            Console.WriteLine($"âœ“ Admin user created: {adminEmail}");
        }
        else
        {
            // Update existing admin user's password
            existingAdmin.PasswordHash = BCrypt.Net.BCrypt.HashPassword(adminPassword, 11);
            existingAdmin.UpdatedAt = DateTime.UtcNow;

            await context.SaveChangesAsync();

            Console.WriteLine($"âœ“ Admin user password updated: {adminEmail}");
        }
    }
}
</file>

<file path="API_DOCUMENTATION.md">
# DnD Map Builder API Documentation

## Overview

This API provides endpoints for managing D&D campaigns, missions, maps, and tokens with JWT-based authentication.

## Base URL

- Development: `https://localhost:5001`
- Production: Update according to your deployment

## Authentication

All endpoints except `/api/auth/register` and `/api/auth/login` require authentication.

### How to Authenticate

1. Register a new user or login
2. Copy the `token` from the response
3. Include it in the `Authorization` header: `Bearer <token>`

Example:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

## API Endpoints

### Authentication

#### Register

```http
POST /api/auth/register
Content-Type: application/json

{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "SecurePassword123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": "user-id",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user",
    "status": "pending"
  },
  "message": "Registration successful. Awaiting admin approval."
}
```

**Note:** New users require admin approval before they can access protected resources.

#### Login

```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "SecurePassword123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": "user-id",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user",
    "status": "approved"
  },
  "message": "Login successful."
}
```

#### Get Pending Users (Admin Only)

```http
GET /api/auth/pending-users
Authorization: Bearer <admin-token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "user-id",
      "username": "new_user",
      "email": "newuser@example.com",
      "role": "user",
      "status": "pending"
    }
  ]
}
```

#### Approve User (Admin Only)

```http
POST /api/auth/approve-user
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "userId": "user-id",
  "approved": true
}
```

### Campaigns

#### Get All User Campaigns

```http
GET /api/campaigns
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "campaign-id",
      "name": "Lost Mines of Phandelver",
      "description": "A classic D&D adventure",
      "missions": [...],
      "ownerId": "user-id",
      "createdAt": "2024-01-15T10:30:00Z",
      "updatedAt": "2024-01-15T10:30:00Z"
    }
  ]
}
```

#### Get Campaign by ID

```http
GET /api/campaigns/{id}
Authorization: Bearer <token>
```

#### Create Campaign

```http
POST /api/campaigns
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Curse of Strahd",
  "description": "A gothic horror adventure in Barovia"
}
```

#### Update Campaign

```http
PUT /api/campaigns/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Curse of Strahd - Updated",
  "description": "Updated description"
}
```

#### Delete Campaign

```http
DELETE /api/campaigns/{id}
Authorization: Bearer <token>
```

### Missions

#### Get Mission by ID

```http
GET /api/missions/{id}
Authorization: Bearer <token>
```

#### Get Missions by Campaign

```http
GET /api/missions/campaign/{campaignId}
Authorization: Bearer <token>
```

#### Create Mission

```http
POST /api/missions
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Village of Barovia",
  "description": "Explore the mysterious village",
  "campaignId": "campaign-id"
}
```

#### Update Mission

```http
PUT /api/missions/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Village of Barovia - Updated",
  "description": "Updated description"
}
```

#### Delete Mission

```http
DELETE /api/missions/{id}
Authorization: Bearer <token>
```

### Maps

#### Get Map by ID

```http
GET /api/maps/{id}
Authorization: Bearer <token>
```

**Response includes all placed tokens on the map.**

#### Get Maps by Mission

```http
GET /api/maps/mission/{missionId}
Authorization: Bearer <token>
```

#### Create Map

```http
POST /api/maps
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Tavern Interior",
  "imageUrl": "https://example.com/tavern.jpg",
  "rows": 20,
  "cols": 30,
  "gridColor": "#000000",
  "gridOpacity": 0.3,
  "missionId": "mission-id"
}
```

#### Update Map (Including Tokens)

```http
PUT /api/maps/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Tavern Interior - Night",
  "imageUrl": "https://example.com/tavern-night.jpg",
  "rows": 20,
  "cols": 30,
  "tokens": [
    {
      "tokenId": "token-definition-id",
      "x": 5,
      "y": 10
    },
    {
      "tokenId": "another-token-id",
      "x": 15,
      "y": 8
    }
  ],
  "gridColor": "#000000",
  "gridOpacity": 0.5
}
```

**Note:** The tokens array replaces all existing tokens on the map.

#### Delete Map

```http
DELETE /api/maps/{id}
Authorization: Bearer <token>
```

### Token Definitions

#### Get All User Tokens

```http
GET /api/tokens
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "token-id",
      "name": "Warrior",
      "imageUrl": "https://example.com/warrior.png",
      "size": 1,
      "type": "player",
      "userId": "user-id"
    }
  ]
}
```

#### Get Token by ID

```http
GET /api/tokens/{id}
Authorization: Bearer <token>
```

#### Create Token

```http
POST /api/tokens
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Dragon",
  "imageUrl": "https://example.com/dragon.png",
  "size": 3,
  "type": "enemy"
}
```

**Token Sizes:**
- `1`: 1x1 grid square (Medium creature)
- `2`: 2x2 grid squares (Large creature)
- `3`: 3x3 grid squares (Huge creature)

**Token Types:**
- `player`: Player character or ally
- `enemy`: Enemy or monster

#### Update Token

```http
PUT /api/tokens/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Ancient Dragon",
  "imageUrl": "https://example.com/ancient-dragon.png",
  "size": 3,
  "type": "enemy"
}
```

#### Delete Token

```http
DELETE /api/tokens/{id}
Authorization: Bearer <token>
```

**Note:** Deleting a token definition does not remove it from existing maps.

## Error Responses

### 400 Bad Request
```json
{
  "success": false,
  "data": null,
  "message": "Validation error or bad request",
  "errors": ["Error detail 1", "Error detail 2"]
}
```

### 401 Unauthorized
```json
{
  "success": false,
  "data": null,
  "message": "Invalid credentials or account not approved."
}
```

### 403 Forbidden
```json
{
  "success": false,
  "data": null,
  "message": "You don't have permission to perform this action."
}
```

### 404 Not Found
```json
{
  "success": false,
  "data": null,
  "message": "Resource not found."
}
```

### 500 Internal Server Error
```json
{
  "success": false,
  "data": null,
  "message": "An internal error occurred."
}
```

## Data Models

### User
```typescript
{
  id: string;
  username: string;
  email: string;
  role: "admin" | "user";
  status: "pending" | "approved" | "rejected";
}
```

### Campaign
```typescript
{
  id: string;
  name: string;
  description: string;
  missions: Mission[];
  ownerId: string;
  createdAt: string; // ISO 8601
  updatedAt: string; // ISO 8601
}
```

### Mission
```typescript
{
  id: string;
  name: string;
  description: string;
  maps: GameMap[];
  campaignId: string;
}
```

### GameMap
```typescript
{
  id: string;
  name: string;
  imageUrl: string | null;
  rows: number;
  cols: number;
  tokens: MapTokenInstance[];
  gridColor: string; // Hex color
  gridOpacity: number; // 0.0 - 1.0
  missionId: string;
}
```

### TokenDefinition
```typescript
{
  id: string;
  name: string;
  imageUrl: string;
  size: 1 | 2 | 3;
  type: "player" | "enemy";
  userId: string;
}
```

### MapTokenInstance
```typescript
{
  instanceId: string;
  tokenId: string; // References TokenDefinition
  x: number;
  y: number;
}
```

## Rate Limiting

Currently, no rate limiting is implemented. Consider adding rate limiting in production.

## CORS

CORS is configured to allow all origins in development. Update CORS policy for production deployment.

## Versioning

Current API version: v1

Future versions will be accessible via `/api/v2/...`
</file>

<file path="dotnet-tools.json">
{
  "version": 1,
  "isRoot": true,
  "tools": {
    "dotnet-ef": {
      "version": "10.0.2",
      "commands": [
        "dotnet-ef"
      ],
      "rollForward": false
    }
  }
}
</file>

<file path="FILE_STRUCTURE.md">
# DnD Map Builder - Complete File Structure

## Solution Structure

```
DnDMapBuilder/
â”‚
â”œâ”€â”€ DnDMapBuilder.sln                      # Visual Studio Solution File
â”œâ”€â”€ .gitignore                             # Git ignore patterns
â”œâ”€â”€ docker-compose.yml                     # Docker Compose configuration
â”œâ”€â”€ setup.sh                               # Quick setup script (chmod +x)
â”‚
â”œâ”€â”€ README.md                              # Main documentation
â”œâ”€â”€ QUICKSTART.md                          # Quick start guide
â”œâ”€â”€ API_DOCUMENTATION.md                   # Complete API reference
â”œâ”€â”€ PROJECT_SUMMARY.md                     # Project overview
â”œâ”€â”€ FILE_STRUCTURE.md                      # This file
â”‚
â””â”€â”€ src/                                   # Source code directory
    â”‚
    â”œâ”€â”€ DnDMapBuilder.Contracts/           # DTO & Contract Layer
    â”‚   â”œâ”€â”€ DnDMapBuilder.Contracts.csproj
    â”‚   â”œâ”€â”€ DTOs/
    â”‚   â”‚   â””â”€â”€ DomainDtos.cs             # Campaign, Mission, Map, Token DTOs
    â”‚   â”œâ”€â”€ Requests/
    â”‚   â”‚   â””â”€â”€ ApiRequests.cs            # Create/Update request models
    â”‚   â””â”€â”€ Responses/
    â”‚       â””â”€â”€ ApiResponses.cs           # API response wrappers
    â”‚
    â”œâ”€â”€ DnDMapBuilder.Data/                # Data Access Layer
    â”‚   â”œâ”€â”€ DnDMapBuilder.Data.csproj
    â”‚   â”œâ”€â”€ DnDMapBuilderDbContext.cs     # EF Core DbContext
    â”‚   â”œâ”€â”€ Entities/
    â”‚   â”‚   â””â”€â”€ DomainEntities.cs         # Database entities (User, Campaign, etc.)
    â”‚   â””â”€â”€ Repositories/
    â”‚       â”œâ”€â”€ IRepositories.cs          # Repository interfaces
    â”‚       â””â”€â”€ Repositories.cs           # Repository implementations
    â”‚
    â”œâ”€â”€ DnDMapBuilder.Application/         # Business Logic Layer
    â”‚   â”œâ”€â”€ DnDMapBuilder.Application.csproj
    â”‚   â”œâ”€â”€ Interfaces/
    â”‚   â”‚   â””â”€â”€ IServices.cs              # Service interfaces
    â”‚   â”œâ”€â”€ Mappings/
    â”‚   â”‚   â””â”€â”€ MappingExtensions.cs      # Entity to DTO mappings
    â”‚   â””â”€â”€ Services/
    â”‚       â”œâ”€â”€ AuthService.cs            # Authentication & user management
    â”‚       â”œâ”€â”€ CampaignService.cs        # Campaign operations
    â”‚       â”œâ”€â”€ MissionService.cs         # Mission operations
    â”‚       â”œâ”€â”€ GameMapAndTokenServices.cs # Map & token operations
    â”‚       â””â”€â”€ JwtService.cs             # JWT token generation/validation
    â”‚
    â”œâ”€â”€ DnDMapBuilder.Api/                 # Web API Layer
    â”‚   â”œâ”€â”€ DnDMapBuilder.Api.csproj
    â”‚   â”œâ”€â”€ Program.cs                    # Application entry point & DI configuration
    â”‚   â”œâ”€â”€ Dockerfile                    # Docker image definition
    â”‚   â”œâ”€â”€ appsettings.json              # Application configuration
    â”‚   â”œâ”€â”€ appsettings.Development.json  # Development configuration
    â”‚   â”œâ”€â”€ Controllers/
    â”‚   â”‚   â”œâ”€â”€ AuthController.cs         # /api/auth endpoints
    â”‚   â”‚   â”œâ”€â”€ CampaignsController.cs    # /api/campaigns endpoints
    â”‚   â”‚   â””â”€â”€ OtherControllers.cs       # Missions, Maps, Tokens endpoints
    â”‚   â””â”€â”€ Properties/
    â”‚       â””â”€â”€ launchSettings.json       # Launch profiles (HTTP/HTTPS)
    â”‚
    â”œâ”€â”€ DnDMapBuilder.Aspire.AppHost/      # Aspire Orchestration
    â”‚   â”œâ”€â”€ DnDMapBuilder.Aspire.AppHost.csproj
    â”‚   â””â”€â”€ Program.cs                    # Aspire app host configuration
    â”‚
    â””â”€â”€ DnDMapBuilder.Aspire.ServiceDefaults/ # Aspire Shared Services
        â”œâ”€â”€ DnDMapBuilder.Aspire.ServiceDefaults.csproj
        â””â”€â”€ Extensions.cs                 # OpenTelemetry & health checks
```

## File Descriptions

### Root Level

- **DnDMapBuilder.sln**: Visual Studio solution file that references all projects
- **.gitignore**: Specifies files/folders to ignore in version control
- **docker-compose.yml**: Docker Compose configuration for SQL Server + API
- **setup.sh**: Bash script for quick project setup (make executable with `chmod +x`)

### Documentation Files

- **README.md**: Complete setup instructions and project overview
- **QUICKSTART.md**: Fast setup guide with minimal steps
- **API_DOCUMENTATION.md**: Full API endpoint reference with examples
- **PROJECT_SUMMARY.md**: Architecture overview and technology stack

### Source Projects

#### 1. DnDMapBuilder.Contracts (No Dependencies)
**Purpose**: Define data contracts used across all layers

- `DTOs/DomainDtos.cs`: Data transfer objects for all domain models
- `Requests/ApiRequests.cs`: Request models for API endpoints
- `Responses/ApiResponses.cs`: Standardized response wrappers

#### 2. DnDMapBuilder.Data (Depends on: None)
**Purpose**: Database access and entity definitions

- `DnDMapBuilderDbContext.cs`: EF Core database context with configuration
- `Entities/DomainEntities.cs`: Database entity classes (User, Campaign, Mission, GameMap, TokenDefinition, MapTokenInstance)
- `Repositories/IRepositories.cs`: Repository interface definitions
- `Repositories/Repositories.cs`: Concrete repository implementations with EF Core

**Key Features**:
- Entity relationships configured with Fluent API
- Repository pattern for data access abstraction
- Seeded admin user for initial setup

#### 3. DnDMapBuilder.Application (Depends on: Contracts, Data)
**Purpose**: Business logic and service layer

- `Interfaces/IServices.cs`: Service contracts (IAuthService, ICampaignService, etc.)
- `Mappings/MappingExtensions.cs`: Extension methods for Entityâ†’DTO conversion
- `Services/AuthService.cs`: User registration, login, approval workflow
- `Services/JwtService.cs`: JWT token generation and validation
- `Services/CampaignService.cs`: Campaign CRUD operations
- `Services/MissionService.cs`: Mission CRUD operations
- `Services/GameMapAndTokenServices.cs`: Map and token CRUD operations

**Key Features**:
- User ownership validation
- Role-based authorization checks
- Password hashing with BCrypt
- JWT token management

#### 4. DnDMapBuilder.Api (Depends on: Application, Contracts, Data)
**Purpose**: REST API endpoints and HTTP handling

- `Program.cs`: Application startup, DI container configuration, middleware pipeline
- `Controllers/AuthController.cs`: Authentication endpoints
- `Controllers/CampaignsController.cs`: Campaign management endpoints
- `Controllers/OtherControllers.cs`: Missions, Maps, and Tokens endpoints
- `appsettings.json`: Database connection, JWT settings
- `Dockerfile`: Multi-stage Docker build definition

**Key Features**:
- JWT Bearer authentication
- Swagger/OpenAPI documentation
- CORS configuration
- Automatic database migration on startup

#### 5. DnDMapBuilder.Aspire.AppHost (Depends on: Api, ServiceDefaults)
**Purpose**: Local development orchestration

- `Program.cs`: Configure SQL Server and API containers

**Features**:
- SQL Server container with persistent volume
- Automatic service discovery
- Health check monitoring
- Aspire dashboard

#### 6. DnDMapBuilder.Aspire.ServiceDefaults (No Dependencies)
**Purpose**: Shared Aspire configuration

- `Extensions.cs`: OpenTelemetry, health checks, service discovery

## Total File Count

- **C# Project Files**: 6
- **C# Source Files**: 19
- **Configuration Files**: 5
- **Documentation Files**: 5
- **Docker Files**: 2
- **Scripts**: 1

**Total**: 38 files

## File Sizes (Approximate)

- Total solution size: ~115 KB (code only)
- Largest file: `Repositories.cs` (~6 KB)
- Average file size: ~3 KB

## Technology Stack by Project

### DnDMapBuilder.Contracts
- .NET 9.0
- No external dependencies

### DnDMapBuilder.Data
- .NET 9.0
- Entity Framework Core 9.0
- SQL Server provider

### DnDMapBuilder.Application
- .NET 9.0
- BCrypt.Net-Next
- System.IdentityModel.Tokens.Jwt

### DnDMapBuilder.Api
- ASP.NET Core 9.0
- JWT Bearer Authentication
- Swashbuckle (Swagger)
- Entity Framework Core Design Tools

### Aspire Projects
- .NET 9.0
- Aspire.Hosting
- OpenTelemetry

## Quick Navigation

| Task | File to Modify |
|------|---------------|
| Add new API endpoint | `src/DnDMapBuilder.Api/Controllers/` |
| Add business logic | `src/DnDMapBuilder.Application/Services/` |
| Add database entity | `src/DnDMapBuilder.Data/Entities/DomainEntities.cs` |
| Add repository method | `src/DnDMapBuilder.Data/Repositories/` |
| Change DB schema | `src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs` |
| Add DTO | `src/DnDMapBuilder.Contracts/DTOs/` |
| Configure JWT | `src/DnDMapBuilder.Api/appsettings.json` |
| Change connection string | `src/DnDMapBuilder.Api/appsettings.json` |
| Modify Aspire setup | `src/DnDMapBuilder.Aspire.AppHost/Program.cs` |

## Missing Files (By Design)

The following are **NOT** included as they're generated/downloaded:
- `bin/` and `obj/` directories (build output)
- `packages/` directory (NuGet packages)
- `.vs/` directory (Visual Studio cache)
- `*.user` files (user-specific settings)
- Database migration files (generate with EF Core tools)
- `node_modules/` (not applicable for this project)

## Next Steps After Download

1. Extract the ZIP file
2. Navigate to the `DnDMapBuilder` directory
3. Choose a run method:
   - Aspire: Run `setup.sh` and select option 1
   - Docker: Run `docker-compose up`
   - Direct: Configure SQL Server and run `dotnet run`
4. Access Swagger UI to test the API

## Verifying the Structure

Run this command in the root directory to verify all files are present:

```bash
find . -name "*.csproj" | wc -l  # Should show 6
find . -name "*.cs" | wc -l      # Should show 19
```

## Support Files

All necessary support files are included:
- âœ… Solution file (.sln)
- âœ… Project files (.csproj)
- âœ… Configuration files (appsettings.json, launchSettings.json)
- âœ… Docker files (Dockerfile, docker-compose.yml)
- âœ… Documentation (4 markdown files)
- âœ… Setup script (setup.sh)
- âœ… Git ignore (.gitignore)

The solution is **complete and ready to build**!
</file>

<file path="generate-certs.sh">
#!/bin/bash

# Create certs directory if it doesn't exist
mkdir -p certs

# Generate self-signed certificate for .NET API
echo "Generating self-signed certificate for .NET API..."
openssl req -x509 -newkey rsa:4096 -keyout certs/aspnetapp.key -out certs/aspnetapp.crt \
  -days 365 -nodes -subj "/CN=localhost" -addext "subjectAltName=DNS:localhost,DNS:dnd-api"

# Convert to PFX format (required by .NET)
openssl pkcs12 -export -in certs/aspnetapp.crt -inkey certs/aspnetapp.key \
  -out certs/aspnetapp.pfx -name aspnetapp -passout pass:crypticpassword

echo "âœ“ Generated aspnetapp.pfx"
echo "Certificate location: certs/aspnetapp.pfx"
echo ""
</file>

<file path="PROJECT_SUMMARY.md">
# DnD Map Builder - Complete Backend Solution

## ðŸŽ¯ Project Overview

A full-featured ASP.NET Web API backend for the DnD Map Builder application, implementing user authentication, campaign management, mission planning, map creation, and token management.

## ðŸ“ Solution Structure

```
DnDMapBuilder/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ DnDMapBuilder.Contracts/          # DTOs, Requests, Responses
â”‚   â”œâ”€â”€ DnDMapBuilder.Data/               # EF Core, Entities, Repositories
â”‚   â”œâ”€â”€ DnDMapBuilder.Application/        # Business Logic & Services
â”‚   â”œâ”€â”€ DnDMapBuilder.Api/                # Web API Controllers
â”‚   â”œâ”€â”€ DnDMapBuilder.Aspire.AppHost/     # Aspire Orchestration
â”‚   â””â”€â”€ DnDMapBuilder.Aspire.ServiceDefaults/  # Aspire Service Defaults
â”œâ”€â”€ DnDMapBuilder.sln                     # Solution file
â”œâ”€â”€ docker-compose.yml                    # Docker Compose configuration
â”œâ”€â”€ setup.sh                              # Quick setup script
â”œâ”€â”€ README.md                             # Main documentation
â”œâ”€â”€ API_DOCUMENTATION.md                  # Complete API reference
â”œâ”€â”€ QUICKSTART.md                         # Quick start guide
â””â”€â”€ .gitignore
```

## ðŸ—ï¸ Architecture

### Clean Architecture Pattern

1. **Contracts Layer** (`DnDMapBuilder.Contracts`)
   - DTOs (Data Transfer Objects)
   - Request/Response models
   - API contracts
   - No dependencies on other layers

2. **Data Layer** (`DnDMapBuilder.Data`)
   - Entity Framework Core
   - Database entities
   - DbContext configuration
   - Repository pattern implementation
   - Database migrations

3. **Application Layer** (`DnDMapBuilder.Application`)
   - Business logic
   - Service implementations
   - Mapping extensions
   - JWT service
   - Depends on: Contracts, Data

4. **API Layer** (`DnDMapBuilder.Api`)
   - Controllers
   - Authentication/Authorization
   - Middleware
   - Swagger configuration
   - Depends on: Application, Contracts, Data

5. **Aspire Orchestration** (`DnDMapBuilder.Aspire.*`)
   - Container orchestration
   - Service discovery
   - Health checks
   - Telemetry

## ðŸ”‘ Key Features

### Authentication & Authorization
- JWT-based authentication
- Role-based authorization (Admin, User)
- User approval workflow
- Secure password hashing with BCrypt

### Campaign Management
- Create, read, update, delete campaigns
- User-owned campaigns
- Complete campaign hierarchy (Campaign â†’ Mission â†’ Map)

### Mission Management
- Organize missions within campaigns
- Mission descriptions and metadata
- Cascade delete with campaigns

### Map Builder
- Grid-based map system
- Custom map images
- Configurable grid (rows, columns, color, opacity)
- Token placement on maps

### Token Library
- User-specific token definitions
- Token types (player, enemy)
- Token sizes (1x1, 2x2, 3x3 grid squares)
- Image URL support

## ðŸ—„ï¸ Database Schema

### Users
- Id, Username, Email, PasswordHash
- Role (admin/user)
- Status (pending/approved/rejected)
- Timestamps

### Campaigns
- Id, Name, Description
- OwnerId â†’ Users
- Timestamps

### Missions
- Id, Name, Description
- CampaignId â†’ Campaigns

### GameMaps
- Id, Name, ImageUrl
- Rows, Cols, GridColor, GridOpacity
- MissionId â†’ Missions

### TokenDefinitions
- Id, Name, ImageUrl, Size, Type
- UserId â†’ Users

### MapTokenInstances
- Id, TokenId â†’ TokenDefinitions
- MapId â†’ GameMaps
- X, Y coordinates

## ðŸš€ Deployment Options

### Option 1: .NET Aspire (Recommended)
```bash
cd src/DnDMapBuilder.Aspire.AppHost
dotnet user-secrets set "Parameters:sql-password" "YourPassword"
dotnet run
```

**Advantages:**
- Automatic container orchestration
- Built-in service discovery
- Health monitoring dashboard
- Telemetry and logging
- Development-optimized

### Option 2: Docker Compose
```bash
docker-compose up --build
```

**Advantages:**
- Simple deployment
- Consistent environment
- Easy to share
- Production-ready

### Option 3: Direct Deployment
- Requires SQL Server instance
- Manual configuration
- More control over environment

## ðŸ” Security Features

1. **JWT Authentication**
   - Secure token generation
   - Token expiration
   - Role-based claims

2. **Password Security**
   - BCrypt hashing
   - Salt per password
   - Secure password storage

3. **Authorization**
   - Role-based access control
   - User ownership validation
   - Admin-only endpoints

4. **API Security**
   - HTTPS support
   - CORS configuration
   - Input validation

## ðŸ“Š API Endpoints Summary

### Authentication (`/api/auth`)
- POST `/register` - Register new user
- POST `/login` - User login
- GET `/pending-users` - Get pending approvals (Admin)
- POST `/approve-user` - Approve/reject user (Admin)

### Campaigns (`/api/campaigns`)
- GET `/` - List user campaigns
- GET `/{id}` - Get campaign details
- POST `/` - Create campaign
- PUT `/{id}` - Update campaign
- DELETE `/{id}` - Delete campaign

### Missions (`/api/missions`)
- GET `/{id}` - Get mission
- GET `/campaign/{campaignId}` - List campaign missions
- POST `/` - Create mission
- PUT `/{id}` - Update mission
- DELETE `/{id}` - Delete mission

### Maps (`/api/maps`)
- GET `/{id}` - Get map with tokens
- GET `/mission/{missionId}` - List mission maps
- POST `/` - Create map
- PUT `/{id}` - Update map and tokens
- DELETE `/{id}` - Delete map

### Tokens (`/api/tokens`)
- GET `/` - List user tokens
- GET `/{id}` - Get token
- POST `/` - Create token
- PUT `/{id}` - Update token
- DELETE `/{id}` - Delete token

## ðŸ› ï¸ Technology Stack

- **.NET 9.0** - Latest .NET framework
- **ASP.NET Core** - Web API framework
- **Entity Framework Core 9.0** - ORM
- **SQL Server 2022** - Database
- **JWT Bearer** - Authentication
- **BCrypt.Net** - Password hashing
- **Swagger/OpenAPI** - API documentation
- **.NET Aspire** - Cloud-native orchestration
- **Docker** - Containerization

## ðŸ“¦ NuGet Packages

### API Project
- Microsoft.AspNetCore.Authentication.JwtBearer
- Microsoft.AspNetCore.OpenApi
- Swashbuckle.AspNetCore

### Application Project
- BCrypt.Net-Next
- System.IdentityModel.Tokens.Jwt

### Data Project
- Microsoft.EntityFrameworkCore
- Microsoft.EntityFrameworkCore.SqlServer
- Microsoft.EntityFrameworkCore.Tools

### Aspire Projects
- Aspire.Hosting.AppHost
- Aspire.Hosting.SqlServer
- OpenTelemetry packages

## ðŸŽ¨ Design Patterns Used

1. **Repository Pattern** - Data access abstraction
2. **Service Layer Pattern** - Business logic separation
3. **Dependency Injection** - Loose coupling
4. **DTO Pattern** - Data transfer optimization
5. **Clean Architecture** - Layer separation
6. **Factory Pattern** - Object creation
7. **Strategy Pattern** - Service implementations

## ðŸ”„ Data Flow

```
Client Request
    â†“
API Controller (Authentication/Authorization)
    â†“
Application Service (Business Logic)
    â†“
Repository (Data Access)
    â†“
Entity Framework Core
    â†“
SQL Server Database
    â†“
Response (via DTOs)
```

## ðŸ“ Default Credentials

**Admin Account** (Pre-seeded):
- Email: `admin@dndmapbuilder.com`
- Password: `Admin123!`
- Role: `admin`
- Status: `approved`

## ðŸ§ª Testing the API

### Using Swagger UI
1. Navigate to `https://localhost:5001/swagger`
2. Login to get a token
3. Click "Authorize" and enter: `Bearer <token>`
4. Test endpoints interactively

### Using cURL
```bash
# Login
curl -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@dndmapbuilder.com","password":"Admin123!"}'

# Create Campaign (replace <token>)
curl -X POST https://localhost:5001/api/campaigns \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","description":"Test campaign"}'
```

## ðŸ“ˆ Future Enhancements

Potential features to add:
- [ ] Real-time collaboration (SignalR)
- [ ] File upload for map images
- [ ] Export/import campaigns
- [ ] Campaign sharing between users
- [ ] Map templates
- [ ] Advanced token properties (HP, AC, etc.)
- [ ] Combat tracker
- [ ] Dice roller integration
- [ ] Character sheets
- [ ] Unit tests
- [ ] Integration tests
- [ ] Rate limiting
- [ ] API versioning
- [ ] GraphQL endpoint

## ðŸ“š Documentation Files

1. **README.md** - Complete setup and overview
2. **API_DOCUMENTATION.md** - Full API reference
3. **QUICKSTART.md** - Fast setup guide
4. **setup.sh** - Automated setup script

## ðŸ¤ Integration with Frontend

The React frontend can integrate with this API by:

1. **Authentication**
   ```typescript
   // Replace localStorage auth with API calls
   const login = async (email, password) => {
     const response = await fetch('https://api-url/api/auth/login', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ email, password })
     });
     const { data } = await response.json();
     localStorage.setItem('token', data.token);
   };
   ```

2. **Data Fetching**
   ```typescript
   // Fetch campaigns
   const getCampaigns = async () => {
     const token = localStorage.getItem('token');
     const response = await fetch('https://api-url/api/campaigns', {
       headers: { 'Authorization': `Bearer ${token}` }
     });
     return await response.json();
   };
   ```

3. **Replace local storage state** with API-backed state management

## âœ… Production Checklist

Before deploying to production:

- [ ] Change JWT secret key
- [ ] Update SQL Server credentials
- [ ] Configure HTTPS certificates
- [ ] Set up proper CORS policy
- [ ] Enable rate limiting
- [ ] Configure logging (Application Insights, Serilog)
- [ ] Set up CI/CD pipeline
- [ ] Database backup strategy
- [ ] Monitoring and alerting
- [ ] Load balancing (if needed)
- [ ] CDN for static assets
- [ ] Security headers
- [ ] Input validation
- [ ] Error handling
- [ ] API documentation versioning

## ðŸŽ“ Learning Resources

To understand this codebase:
1. Review the clean architecture layers
2. Follow a request from Controller â†’ Service â†’ Repository â†’ Database
3. Examine the entity relationships in DbContext
4. Study the JWT authentication flow
5. Explore the Aspire orchestration setup

## ðŸ“„ License

MIT License - Feel free to use and modify

---

**Created**: January 2026  
**.NET Version**: 9.0  
**Database**: SQL Server 2022  
**Architecture**: Clean Architecture with Repository Pattern
</file>

<file path="prompt_plan.md">
# backend_prompt_plan.md

## Context
This backend belongs to a DnD map builder application. The current implementation incorrectly stores and retrieves images (maps and tokens) from the database, likely using base64 or JSON-embedded blobs. This causes corruption, size issues, and retrieval bugs. The fix is to move to **proper file transfer and storage**, with the database storing only metadata and file references.

---

## Goals
- Use multipart file upload instead of embedding images in JSON.
- Store images in a file system or object storage (local disk, S3-compatible, etc.).
- Persist only metadata (URL/path, size, type, ownership) in the database.
- Ensure backward-safe migration path if existing data exists.

---

## Step-by-step Implementation Plan

### Step 1: Audit Current Image Handling
**status: done**
- Identify all endpoints that accept or return images (maps, tokens).
- Confirm how images are currently:
  - Sent from frontend (base64, data URLs, JSON fields)
  - Stored in DB (byte array, string, JSON column)
- List affected entities (e.g., Map, Token).

**Findings:**
- Images are currently stored as URL strings only (nvarchar(1000) in SQL Server)
- Maps endpoint (POST/PUT/GET) with optional ImageUrl field
- Tokens endpoint (POST/PUT/GET) with required ImageUrl field
- Affected entities: GameMap, TokenDefinition
- No file upload system exists - all images are external URL references
- No binary storage, multipart/form-data handling, or file validation currently

---

### Step 2: Define File Storage Strategy
**status: done**
- Decide storage target:
  - Local filesystem (e.g., `/uploads/maps`, `/uploads/tokens`)
  - OR object storage abstraction (recommended for future scaling).
- Define naming strategy:
  - UUID-based filenames
  - Preserve original extension
- Define public vs private access rules.

**Strategy Decisions:**
- **Storage Target**: Abstraction layer with local filesystem as initial implementation
  - Directory structure: `wwwroot/uploads/maps/`, `wwwroot/uploads/tokens/`
  - Future: Can swap to S3/Azure Blob without API changes
- **Naming Strategy**:
  - Format: `{UUID}_{originalFileName}` (preserves context and extension)
  - Example: `a1b2c3d4-e5f6_dragon_token.png`
- **Access Rules**:
  - Maps: Public URLs (served via static middleware)
  - Tokens: User-specific ownership (check authorization on retrieval)
- **File Size Limits**:
  - Maps: 5MB max
  - Tokens: 2MB max
- **Allowed MIME Types**: `image/png`, `image/jpeg`, `image/webp`

---

### Step 3: Introduce File Storage Abstraction
**status: done**
- Create a `IFileStorageService` (or equivalent):
  - `UploadAsync(Stream file, FileMetadata metadata)`
  - `DeleteAsync(fileId)`
  - `GetPublicUrl(fileId)`
- Implement initial version using local filesystem.
- Ensure streaming is used (no full file buffering in memory).

**Implementation:**
- Created `IFileStorageService` interface in Application/Interfaces/IServices.cs
- Implemented `LocalFileStorageService` in Application/Services/FileStorageService.cs
- Uses async streaming (4096 buffer) - no full file buffering in memory
- Stores files in `wwwroot/uploads/{category}/{fileId}`
- Validates MIME types (png, jpeg, webp)
- Prevents path traversal attacks
- Registered as Singleton in Program.cs with logging
- Added static file middleware for serving uploads

---

### Step 4: Update Domain Models
**status: done**
- Remove image binary/base64 fields from entities.
- Add fields such as:
  - `ImageFileId`
  - `ImageUrl`
  - `ContentType`
  - `FileSize`
- Update ORM mappings and migrations accordingly.

**Implementation:**
- Updated GameMap entity: added ImageFileId, ImageContentType, ImageFileSize (kept ImageUrl for backward compatibility)
- Updated TokenDefinition entity: added ImageFileId, ImageContentType, ImageFileSize (kept ImageUrl for backward compatibility)
- Created migration: 20260117102707_AddImageFileStorageMetadata.cs
- Backward compatible: existing ImageUrl field remains for gradual migration

---

### Step 5: Update API Contracts
**status: done**
- Replace JSON-based image fields with:
  - `multipart/form-data` endpoints
- Separate responsibilities:
  - One endpoint for metadata (map config, token position, etc.)
  - One endpoint for file upload
- Example:
  - `POST /maps` (metadata only)
  - `POST /maps/{id}/image` (multipart file upload)

**Implementation:**
- Updated GameMapDto: added ImageFileId, ImageContentType, ImageFileSize fields
- Updated TokenDefinitionDto: added ImageFileId, ImageContentType, ImageFileSize fields
- Added ImageUploadResponse contract for file upload responses
- Updated mapping extensions to include new metadata fields
- IFormFile handling will be done directly in controllers (not in Contracts layer)

---

### Step 6: Implement Upload Endpoints
**status: done**
- Add endpoints using `multipart/form-data`.
- Validate:
  - File size limits
  - MIME types (png, jpg, webp)
- Store file via `IFileStorageService`.
- Persist file reference to DB.

**Implementation:**
- Added `POST /api/maps/{id}/image` endpoint in MapsController
  - Validates file size (5MB max for maps)
  - Validates MIME types (png, jpeg, webp)
  - Verifies ownership before upload
  - Stores file via IFileStorageService
  - Updates map metadata in DB
- Added `POST /api/tokens/{id}/image` endpoint in TokensController
  - Validates file size (2MB max for tokens)
  - Same validation and security checks as maps
- Both endpoints return ImageUploadResponse with file info
- Error handling for validation and storage failures

---

### Step 7: Implement Retrieval Strategy
**status: done**
- Serve images via:
  - Static file middleware (local disk)
  - OR signed URLs (if object storage)
- Ensure API returns image URLs, not raw bytes.

**Implementation:**
- Static file middleware already added to Program.cs
- Images served via `/uploads/{category}/{fileId}` routes
- File storage service returns public URLs for each file
- API endpoints return image URLs in DTO fields (ImageUrl)
- No raw bytes returned - only URL references
- Supports future S3/Azure Blob integration via IFileStorageService abstraction

---

### Step 8: Migration / Backward Compatibility
**status: done**
- Decide whether existing stored images must be migrated.
- If yes:
  - Write one-time migration script:
    - Read old image data
    - Save as file
    - Update DB references
- If no:
  - Explicitly drop legacy fields.

**Implementation:**
- **Backward Compatible Approach**: Existing ImageUrl field retained
- New file storage fields added as nullable (ImageFileId, ImageContentType, ImageFileSize)
- Old endpoints still work with existing ImageUrl data
- New upload endpoints populate both old and new fields
- Existing data can coexist during gradual migration
- Future: One-time migration script can convert existing URLs to file storage if needed
- No data loss - legacy fields preserved for rollback capability

---

### Step 9: Security & Validation
**status: done**
- Enforce authorization checks on upload/delete.
- Prevent path traversal.
- Validate file headers (not just extensions).

**Implementation:**
- **Authorization**:
  - [Authorize] attribute on all upload endpoints
  - GetUserId() verifies user identity from JWT claims
  - Ownership check: verify user owns map/token before allowing upload
- **Path Traversal Prevention**:
  - FileStorageService validates fileId to prevent ".." or "/" characters
  - Files stored in UUID format only (e.g., a1b2c3d4-e5f6.png)
  - No user-controlled path manipulation possible
- **File Validation**:
  - MIME type validation against allowlist (png, jpeg, webp)
  - File size limits enforced (5MB for maps, 2MB for tokens)
  - Validates IFormFile.Length before processing
  - Safe file operations with proper error handling
- **Storage Security**:
  - Files saved to isolated directory (wwwroot/uploads/)
  - Streaming used to avoid full-file memory buffering
  - Proper exception handling and cleanup on failures

---

### Step 10: Documentation for Frontend Team
**status: done**
- Document new endpoints and payload expectations.
- Provide example `curl` and Postman requests.

**Documentation:**

#### Map Image Upload
- **Endpoint**: `POST /api/maps/{mapId}/image`
- **Authentication**: Required (Bearer token)
- **Content-Type**: `multipart/form-data`
- **Parameters**:
  - `image` (file): The image file to upload (PNG, JPEG, or WebP)
- **File Limits**: Max 5MB
- **Response**:
  ```json
  {
    "success": true,
    "data": {
      "fileId": "a1b2c3d4-e5f6-7890.png",
      "url": "/uploads/maps/a1b2c3d4-e5f6-7890.png",
      "contentType": "image/png",
      "fileSize": 123456
    },
    "message": "Image uploaded successfully."
  }
  ```

#### Token Image Upload
- **Endpoint**: `POST /api/tokens/{tokenId}/image`
- **Authentication**: Required (Bearer token)
- **Content-Type**: `multipart/form-data`
- **Parameters**:
  - `image` (file): The image file to upload (PNG, JPEG, or WebP)
- **File Limits**: Max 2MB
- **Response**: Same format as map image upload

#### cURL Examples
```bash
# Upload map image
curl -X POST "https://api.example.com/api/maps/map-id-123/image" \
  -H "Authorization: Bearer <token>" \
  -F "image=@path/to/map.png"

# Upload token image
curl -X POST "https://api.example.com/api/tokens/token-id-456/image" \
  -H "Authorization: Bearer <token>" \
  -F "image=@path/to/token.png"
```

#### Client Implementation Notes
- Use `FormData` in JavaScript/fetch:
  ```javascript
  const formData = new FormData();
  formData.append('image', fileInput.files[0]);

  const response = await fetch(`/api/maps/${mapId}/image`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`
    },
    body: formData
  });
  ```

#### Retrieval
- Map/token images are returned in API responses via `ImageUrl` field
- Images are publicly accessible at: `/uploads/{category}/{fileId}`
- No additional API calls needed for retrieval - use URL directly in img tags

---
</file>

<file path="QUICKSTART.md">
# Quick Start Guide

## TL;DR - Fastest Way to Run

### Using .NET Aspire (Recommended)

```bash
# 1. Navigate to the project
cd DnDMapBuilder

# 2. Set SQL password
cd src/DnDMapBuilder.Aspire.AppHost
dotnet user-secrets set "Parameters:sql-password" "YourStrong@Passw0rd"

# 3. Run
dotnet run

# 4. Open the Aspire dashboard URL shown in console
# The API will be available at the URL shown for 'api' service
```

### Using Docker Compose

```bash
# From project root
docker-compose up --build
```

API available at: `http://localhost:5000`

### Using Direct API (Requires SQL Server)

```bash
# 1. Update connection string in src/DnDMapBuilder.Api/appsettings.json

# 2. Run migrations
cd src/DnDMapBuilder.Api
dotnet ef database update --project ../DnDMapBuilder.Data

# 3. Run API
dotnet run
```

## First Steps After Running

### 1. Access Swagger UI

Navigate to: `https://localhost:<port>/swagger`

### 2. Login as Admin

**Default Admin Credentials:**
- Email: `admin@dndmapbuilder.com`
- Password: `Admin123!`

### 3. Test the API

```bash
# Login
curl -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@dndmapbuilder.com","password":"Admin123!"}'

# Copy the token from response

# Create a campaign
curl -X POST https://localhost:5001/api/campaigns \
  -H "Authorization: Bearer <your-token>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Campaign","description":"My first campaign"}'
```

## Common Issues

### Issue: Port already in use

**Solution:** Change the port in `launchSettings.json` or stop the service using that port.

### Issue: SQL Server connection failed

**Aspire:** Wait for SQL Server container to be healthy (check Aspire dashboard)

**Docker Compose:** Check `docker-compose logs sqlserver`

**Direct:** Verify SQL Server is running: `sqlcmd -S localhost -U sa -P <password> -Q "SELECT @@VERSION"`

### Issue: Database migrations not applied

```bash
cd src/DnDMapBuilder.Api
dotnet ef database update --project ../DnDMapBuilder.Data
```

## Project Structure Quick Reference

```
src/
â”œâ”€â”€ DnDMapBuilder.Api/              â† API Controllers & Startup
â”‚   â”œâ”€â”€ Controllers/                â† REST endpoints
â”‚   â”œâ”€â”€ Program.cs                  â† Application entry point
â”‚   â””â”€â”€ appsettings.json           â† Configuration
â”œâ”€â”€ DnDMapBuilder.Application/      â† Business logic
â”‚   â”œâ”€â”€ Services/                   â† Service implementations
â”‚   â””â”€â”€ Interfaces/                 â† Service contracts
â”œâ”€â”€ DnDMapBuilder.Contracts/        â† DTOs & Models
â”‚   â”œâ”€â”€ DTOs/                       â† Data transfer objects
â”‚   â”œâ”€â”€ Requests/                   â† Request models
â”‚   â””â”€â”€ Responses/                  â† Response models
â”œâ”€â”€ DnDMapBuilder.Data/             â† Data access
â”‚   â”œâ”€â”€ Entities/                   â† Database entities
â”‚   â”œâ”€â”€ Repositories/               â† Data repositories
â”‚   â””â”€â”€ DnDMapBuilderDbContext.cs  â† EF Core context
â””â”€â”€ DnDMapBuilder.Aspire.AppHost/   â† Orchestration
    â””â”€â”€ Program.cs                  â† Aspire configuration
```

## Next Steps

1. **Register a new user** via `/api/auth/register`
2. **Approve the user** as admin via `/api/auth/approve-user`
3. **Create campaigns, missions, and maps** using the authenticated user
4. **Define custom tokens** for your maps
5. **Build maps** and place tokens

## Useful Commands

```bash
# Restore dependencies
dotnet restore

# Build solution
dotnet build

# Run migrations
dotnet ef migrations add <name> --project src/DnDMapBuilder.Data

# Update database
dotnet ef database update --project src/DnDMapBuilder.Data

# Clean build artifacts
dotnet clean

# Watch for changes and auto-rebuild
dotnet watch run --project src/DnDMapBuilder.Api
```

## Environment Variables

When not using Aspire, you can override settings with environment variables:

```bash
export ConnectionStrings__DefaultConnection="Server=...;Database=...;"
export JwtSettings__SecretKey="your-secret-key"
export ASPNETCORE_ENVIRONMENT="Development"
```

## Testing with Postman

1. Import the API into Postman using the Swagger JSON: `https://localhost:5001/swagger/v1/swagger.json`
2. Set up an environment variable for the token
3. Use `{{token}}` in the Authorization header

## Production Checklist

Before deploying to production:

- [ ] Change JWT SecretKey in appsettings.json
- [ ] Update SQL Server password
- [ ] Configure proper CORS policy
- [ ] Enable HTTPS
- [ ] Set up proper logging
- [ ] Configure rate limiting
- [ ] Review and update default admin credentials
- [ ] Set up database backups
- [ ] Configure monitoring
- [ ] Review security headers

## Support

For issues or questions:
1. Check the full README.md
2. Review API_DOCUMENTATION.md
3. Check application logs
4. Review Aspire dashboard for container health
</file>

<file path="README.md">
# DnD Map Builder - Backend API

A comprehensive ASP.NET Web API for managing D&D campaigns, missions, maps, and tokens with authentication and authorization.

## Architecture

The solution is organized into the following projects:

- **DnDMapBuilder.Contracts**: DTOs, Requests, and Response models
- **DnDMapBuilder.Data**: Entity Framework Core, Entities, DbContext, and Repositories
- **DnDMapBuilder.Application**: Business logic and services
- **DnDMapBuilder.Api**: ASP.NET Core Web API with controllers
- **DnDMapBuilder.Aspire.AppHost**: .NET Aspire orchestration for local development
- **DnDMapBuilder.Aspire.ServiceDefaults**: Shared service defaults for Aspire

## Prerequisites

- .NET 9.0 SDK
- Docker Desktop (for local development with Aspire)
- Visual Studio 2022 or Visual Studio Code
- SQL Server (or use Docker container via Aspire)

## Getting Started

### Option 1: Run with .NET Aspire (Recommended)

.NET Aspire orchestrates the SQL Server database and API application in Docker containers.

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd DnDMapBuilder
   ```

2. **Set SQL Server password**
   
   When running for the first time, Aspire will prompt for a SQL Server password. You can also set it via:
   ```bash
   dotnet user-secrets set Parameters:sql-password "YourStrong@Passw0rd" --project src/DnDMapBuilder.Aspire.AppHost
   ```

3. **Run the Aspire AppHost**
   ```bash
   cd src/DnDMapBuilder.Aspire.AppHost
   dotnet run
   ```

4. **Access the application**
   - Aspire Dashboard: https://localhost:17001 (or check console output)
   - API: https://localhost:7001 (check Aspire dashboard for actual port)
   - Swagger UI: https://localhost:7001/swagger

### Option 2: Run API Directly

1. **Set up SQL Server**
   
   Update the connection string in `src/DnDMapBuilder.Api/appsettings.json`:
   ```json
   "ConnectionStrings": {
     "DefaultConnection": "Server=localhost;Database=DnDMapBuilder;User Id=sa;Password=YourPassword;TrustServerCertificate=True;"
   }
   ```

2. **Run migrations**
   ```bash
   cd src/DnDMapBuilder.Api
   dotnet ef database update
   ```

3. **Run the API**
   ```bash
   dotnet run
   ```

4. **Access Swagger UI**
   - Navigate to: https://localhost:5001/swagger

## Database Migrations

To create a new migration:

```bash
cd src/DnDMapBuilder.Api
dotnet ef migrations add <MigrationName> --project ../DnDMapBuilder.Data
```

To update the database:

```bash
dotnet ef database update --project ../DnDMapBuilder.Data
```

## Default Admin Account

A default admin account is seeded automatically:

- **Email**: admin@dndmapbuilder.com
- **Password**: Admin123!
- **Role**: admin
- **Status**: approved

## API Endpoints

### Authentication

- `POST /api/auth/register` - Register a new user (requires admin approval)
- `POST /api/auth/login` - Login and receive JWT token
- `GET /api/auth/pending-users` - Get pending user registrations (Admin only)
- `POST /api/auth/approve-user` - Approve/reject user registration (Admin only)

### Campaigns

- `GET /api/campaigns` - Get all campaigns for the authenticated user
- `GET /api/campaigns/{id}` - Get a specific campaign
- `POST /api/campaigns` - Create a new campaign
- `PUT /api/campaigns/{id}` - Update a campaign
- `DELETE /api/campaigns/{id}` - Delete a campaign

### Missions

- `GET /api/missions/{id}` - Get a specific mission
- `GET /api/missions/campaign/{campaignId}` - Get all missions for a campaign
- `POST /api/missions` - Create a new mission
- `PUT /api/missions/{id}` - Update a mission
- `DELETE /api/missions/{id}` - Delete a mission

### Maps

- `GET /api/maps/{id}` - Get a specific map
- `GET /api/maps/mission/{missionId}` - Get all maps for a mission
- `POST /api/maps` - Create a new map
- `PUT /api/maps/{id}` - Update a map (including tokens)
- `DELETE /api/maps/{id}` - Delete a map

### Tokens

- `GET /api/tokens` - Get all tokens for the authenticated user
- `GET /api/tokens/{id}` - Get a specific token
- `POST /api/tokens` - Create a new token
- `PUT /api/tokens/{id}` - Update a token
- `DELETE /api/tokens/{id}` - Delete a token

## Authentication

The API uses JWT Bearer token authentication. To authenticate:

1. Register or login via `/api/auth/register` or `/api/auth/login`
2. Copy the token from the response
3. In Swagger UI, click "Authorize" and enter: `Bearer <your-token>`
4. Or include the header in your requests: `Authorization: Bearer <your-token>`

## Configuration

### JWT Settings

Update in `appsettings.json`:

```json
"JwtSettings": {
  "SecretKey": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
  "Issuer": "DnDMapBuilderApi",
  "Audience": "DnDMapBuilderClient",
  "ExpirationMinutes": "1440"
}
```

### CORS

CORS is configured to allow all origins in development. Update the CORS policy in `Program.cs` for production.

## Docker Support

The Aspire AppHost automatically manages Docker containers for:

- SQL Server 2022 (with persistent data volume)
- The API application

Container orchestration is handled automatically by .NET Aspire.

## Project Structure

```
DnDMapBuilder/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ DnDMapBuilder.Api/           # Web API Controllers
â”‚   â”œâ”€â”€ DnDMapBuilder.Application/   # Business Logic & Services
â”‚   â”œâ”€â”€ DnDMapBuilder.Contracts/     # DTOs & Request/Response Models
â”‚   â”œâ”€â”€ DnDMapBuilder.Data/          # EF Core, Entities, Repositories
â”‚   â”œâ”€â”€ DnDMapBuilder.Aspire.AppHost/         # Aspire Orchestration
â”‚   â””â”€â”€ DnDMapBuilder.Aspire.ServiceDefaults/ # Shared Aspire Config
â””â”€â”€ DnDMapBuilder.sln
```

## Technologies Used

- .NET 9.0
- ASP.NET Core Web API
- Entity Framework Core 9.0
- SQL Server 2022
- JWT Authentication
- BCrypt.Net for password hashing
- .NET Aspire for orchestration
- Swagger/OpenAPI
- Docker

## Development

### Running Tests

```bash
dotnet test
```

### Code Style

The project follows standard C# coding conventions with nullable reference types enabled.

## License

This project is licensed under the MIT License.
</file>

<file path="SECURITY.md">
# Security Configuration

## Admin User Setup

The application seeds a default admin user on first run. This user is required to approve new user registrations.

### Environment Variables

Configure these environment variables to set secure admin credentials:

| Variable | Description | Required | Example |
|----------|-------------|----------|---------|
| `ADMIN_DEFAULT_PASSWORD` | Admin user password | Yes (Production) | Use a strong password |
| `ADMIN_EMAIL` | Admin user email | Yes (Production) | `your-email@domain.com` |

### GitHub Secrets Configuration

Add these secrets to your backend repository (`Settings â†’ Secrets and variables â†’ Actions â†’ Secrets`):

```
ADMIN_DEFAULT_PASSWORD: YourVerySecurePassword123!@#
ADMIN_EMAIL: your-admin@yourdomain.com
```

### Security Best Practices

#### 1. Never Use Default Credentials in Production

**Bad (Development Only):**
```bash
ADMIN_DEFAULT_PASSWORD=Admin123!
ADMIN_EMAIL=admin@dndmapbuilder.com
```

**Good (Production):**
```bash
ADMIN_DEFAULT_PASSWORD=X9$mK#pL2@qR8vN4zT7hW!eA6fG5yU
ADMIN_EMAIL=your-real-email@yourdomain.com
```

#### 2. Generate Strong Passwords

Use a password generator with at least:
- 20+ characters
- Mix of uppercase, lowercase, numbers, and symbols
- No dictionary words

Example generation:
```bash
# On Linux/Mac
openssl rand -base64 32

# Or use a password manager like:
# - 1Password
# - Bitwarden
# - LastPass
```

#### 3. Rotate Credentials Regularly

- Change admin password every 90 days
- Update the GitHub secret and redeploy
- The new password takes effect on next deployment

#### 4. Database Migrations

When you first deploy or change credentials:

**Development:**
```bash
# Use default credentials for local testing
dotnet ef database update
```

**Production:**
```bash
# Credentials are read from environment variables during container startup
# The seed data runs automatically on first database creation
```

#### 5. Initial Login

After deployment, login with your configured credentials:

**Email:** The value you set in `ADMIN_EMAIL`
**Password:** The value you set in `ADMIN_DEFAULT_PASSWORD`

**Important:** Change the password through the application UI immediately after first login (when this feature is implemented).

## Additional Security Measures

### JWT Configuration

Ensure your JWT secrets are secure:

```bash
# Generate a secure JWT secret:
openssl rand -base64 64
```

Add to GitHub Secrets:
- `JWT_SECRET`: Your generated secret
- `JWT_ISSUER`: Your domain (e.g., `dndmaps-api.hostname.gr`)
- `JWT_AUDIENCE`: Your frontend domain (e.g., `dndmaps.hostname.gr`)

### Database Connection

Use secure database credentials:
- Strong database password
- Restrict database access to your application server IP only
- Use SSL/TLS for database connections if possible

### Deployment Checklist

Before deploying to production, verify:

- [ ] `ADMIN_DEFAULT_PASSWORD` is set to a strong, unique password
- [ ] `ADMIN_EMAIL` is set to a real email you control
- [ ] `JWT_SECRET` is a secure random string (64+ characters)
- [ ] `DB_CONNECTION_STRING` uses a strong database password
- [ ] All secrets are stored in GitHub Secrets, not in code
- [ ] The repository `.env` files are in `.gitignore`
- [ ] No default credentials ("Admin123!") are used in production

## Troubleshooting

### Can't login with admin credentials

1. Check the container logs:
```bash
docker logs dnd-api --tail 100
```

2. Verify environment variables are set:
```bash
docker exec dnd-api printenv | grep ADMIN
```

3. Check the database has the admin user:
```bash
# Connect to your database and check Users table
SELECT Username, Email, Role, Status FROM Users WHERE Role = 'admin';
```

### Need to reset admin password

1. Update the `ADMIN_DEFAULT_PASSWORD` secret in GitHub
2. Drop and recreate the database (this will lose all data):
```bash
# SSH into your server
docker exec dnd-api dotnet ef database drop --force
docker restart dnd-api
```

Or manually update the password hash in the database:
```bash
# Generate new hash locally using BCrypt
# Then update the database
UPDATE Users SET PasswordHash = 'your-new-hash' WHERE Role = 'admin';
```

## Contact

For security issues, please contact the repository maintainer directly. Do not open public issues for security vulnerabilities.
</file>

<file path="setup.sh">
#!/bin/bash

# DnD Map Builder - Quick Setup Script

echo "=========================================="
echo "DnD Map Builder - Backend Setup"
echo "=========================================="
echo ""

# Check if .NET is installed
if ! command -v dotnet &> /dev/null; then
    echo "âŒ .NET SDK is not installed. Please install .NET 9.0 SDK first."
    echo "   Download from: https://dotnet.microsoft.com/download"
    exit 1
fi

echo "âœ… .NET SDK found: $(dotnet --version)"
echo ""

# Check if Docker is running (optional, for Aspire)
if command -v docker &> /dev/null; then
    if docker info &> /dev/null; then
        echo "âœ… Docker is running"
        DOCKER_AVAILABLE=true
    else
        echo "âš ï¸  Docker is installed but not running"
        DOCKER_AVAILABLE=false
    fi
else
    echo "âš ï¸  Docker is not installed (optional for Aspire)"
    DOCKER_AVAILABLE=false
fi
echo ""

# Ask user how they want to run the application
echo "How would you like to run the application?"
echo "1. Using .NET Aspire (Recommended - requires Docker)"
echo "2. Using Docker Compose"
echo "3. Run API directly (requires SQL Server)"
echo ""
read -p "Enter your choice (1-3): " choice

case $choice in
    1)
        if [ "$DOCKER_AVAILABLE" = false ]; then
            echo "âŒ Docker is required for Aspire. Please start Docker or choose another option."
            exit 1
        fi
        
        echo ""
        echo "Setting up .NET Aspire..."
        
        # Set SQL password
        read -sp "Enter SQL Server password (default: YourStrong@Passw0rd): " sql_password
        echo ""
        if [ -z "$sql_password" ]; then
            sql_password="YourStrong@Passw0rd"
        fi
        
        cd src/DnDMapBuilder.Aspire.AppHost
        dotnet user-secrets set "Parameters:sql-password" "$sql_password"
        
        echo ""
        echo "âœ… Setup complete!"
        echo ""
        echo "Starting .NET Aspire..."
        dotnet run
        ;;
        
    2)
        if [ "$DOCKER_AVAILABLE" = false ]; then
            echo "âŒ Docker is required for Docker Compose. Please start Docker or choose another option."
            exit 1
        fi
        
        echo ""
        echo "Starting with Docker Compose..."
        docker-compose up --build
        ;;
        
    3)
        echo ""
        echo "âš ï¸  Make sure SQL Server is running and accessible."
        echo ""
        read -p "Enter SQL Server host (default: localhost): " sql_host
        sql_host=${sql_host:-localhost}
        
        read -p "Enter SQL Server port (default: 1433): " sql_port
        sql_port=${sql_port:-1433}
        
        read -p "Enter SQL Server username (default: sa): " sql_user
        sql_user=${sql_user:-sa}
        
        read -sp "Enter SQL Server password: " sql_password
        echo ""
        
        # Update appsettings.json
        connection_string="Server=${sql_host},${sql_port};Database=DnDMapBuilder;User Id=${sql_user};Password=${sql_password};TrustServerCertificate=True;"
        
        cd src/DnDMapBuilder.Api
        
        # Create a temporary appsettings.Development.json with the connection string
        cat > appsettings.Development.json << EOF
{
  "ConnectionStrings": {
    "DefaultConnection": "${connection_string}"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "System": "Information",
      "Microsoft": "Information"
    }
  }
}
EOF
        
        echo ""
        echo "Running database migrations..."
        dotnet ef database update --project ../DnDMapBuilder.Data
        
        echo ""
        echo "âœ… Setup complete!"
        echo ""
        echo "Starting API..."
        dotnet run
        ;;
        
    *)
        echo "âŒ Invalid choice. Please run the script again."
        exit 1
        ;;
esac
</file>

<file path="STRUCTURE_DIAGRAM.md">
# Visual Structure

```
DnDMapBuilder/
â”‚
â”œâ”€â”€ ðŸ“„ DnDMapBuilder.sln
â”œâ”€â”€ ðŸ“„ .gitignore
â”œâ”€â”€ ðŸ³ docker-compose.yml
â”œâ”€â”€ ðŸ”§ setup.sh
â”œâ”€â”€ ðŸ”§ verify-structure.sh
â”‚
â”œâ”€â”€ ðŸ“š Documentation
â”‚   â”œâ”€â”€ ðŸ“– README.md
â”‚   â”œâ”€â”€ ðŸ“– QUICKSTART.md
â”‚   â”œâ”€â”€ ðŸ“– API_DOCUMENTATION.md
â”‚   â”œâ”€â”€ ðŸ“– PROJECT_SUMMARY.md
â”‚   â””â”€â”€ ðŸ“– FILE_STRUCTURE.md
â”‚
â””â”€â”€ ðŸ“ src/
    â”‚
    â”œâ”€â”€ ðŸ“¦ DnDMapBuilder.Contracts/
    â”‚   â”œâ”€â”€ ðŸ“„ DnDMapBuilder.Contracts.csproj
    â”‚   â”œâ”€â”€ ðŸ“ DTOs/
    â”‚   â”‚   â””â”€â”€ ðŸ“ DomainDtos.cs
    â”‚   â”œâ”€â”€ ðŸ“ Requests/
    â”‚   â”‚   â””â”€â”€ ðŸ“ ApiRequests.cs
    â”‚   â””â”€â”€ ðŸ“ Responses/
    â”‚       â””â”€â”€ ðŸ“ ApiResponses.cs
    â”‚
    â”œâ”€â”€ ðŸ“¦ DnDMapBuilder.Data/
    â”‚   â”œâ”€â”€ ðŸ“„ DnDMapBuilder.Data.csproj
    â”‚   â”œâ”€â”€ ðŸ“ DnDMapBuilderDbContext.cs
    â”‚   â”œâ”€â”€ ðŸ“ Entities/
    â”‚   â”‚   â””â”€â”€ ðŸ“ DomainEntities.cs
    â”‚   â””â”€â”€ ðŸ“ Repositories/
    â”‚       â”œâ”€â”€ ðŸ“ IRepositories.cs
    â”‚       â””â”€â”€ ðŸ“ Repositories.cs
    â”‚
    â”œâ”€â”€ ðŸ“¦ DnDMapBuilder.Application/
    â”‚   â”œâ”€â”€ ðŸ“„ DnDMapBuilder.Application.csproj
    â”‚   â”œâ”€â”€ ðŸ“ Interfaces/
    â”‚   â”‚   â””â”€â”€ ðŸ“ IServices.cs
    â”‚   â”œâ”€â”€ ðŸ“ Mappings/
    â”‚   â”‚   â””â”€â”€ ðŸ“ MappingExtensions.cs
    â”‚   â””â”€â”€ ðŸ“ Services/
    â”‚       â”œâ”€â”€ ðŸ“ AuthService.cs
    â”‚       â”œâ”€â”€ ðŸ“ JwtService.cs
    â”‚       â”œâ”€â”€ ðŸ“ CampaignService.cs
    â”‚       â”œâ”€â”€ ðŸ“ MissionService.cs
    â”‚       â””â”€â”€ ðŸ“ GameMapAndTokenServices.cs
    â”‚
    â”œâ”€â”€ ðŸ“¦ DnDMapBuilder.Api/
    â”‚   â”œâ”€â”€ ðŸ“„ DnDMapBuilder.Api.csproj
    â”‚   â”œâ”€â”€ ðŸ“ Program.cs
    â”‚   â”œâ”€â”€ ðŸ³ Dockerfile
    â”‚   â”œâ”€â”€ âš™ï¸ appsettings.json
    â”‚   â”œâ”€â”€ âš™ï¸ appsettings.Development.json
    â”‚   â”œâ”€â”€ ðŸ“ Controllers/
    â”‚   â”‚   â”œâ”€â”€ ðŸ“ AuthController.cs
    â”‚   â”‚   â”œâ”€â”€ ðŸ“ CampaignsController.cs
    â”‚   â”‚   â””â”€â”€ ðŸ“ OtherControllers.cs
    â”‚   â””â”€â”€ ðŸ“ Properties/
    â”‚       â””â”€â”€ âš™ï¸ launchSettings.json
    â”‚
    â”œâ”€â”€ ðŸ“¦ DnDMapBuilder.Aspire.AppHost/
    â”‚   â”œâ”€â”€ ðŸ“„ DnDMapBuilder.Aspire.AppHost.csproj
    â”‚   â””â”€â”€ ðŸ“ Program.cs
    â”‚
    â””â”€â”€ ðŸ“¦ DnDMapBuilder.Aspire.ServiceDefaults/
        â”œâ”€â”€ ðŸ“„ DnDMapBuilder.Aspire.ServiceDefaults.csproj
        â””â”€â”€ ðŸ“ Extensions.cs
```

## Legend

- ðŸ“„ Project/Solution Files (.csproj, .sln)
- ðŸ“ C# Source Files (.cs)
- ðŸ“– Documentation (.md)
- âš™ï¸ Configuration (.json)
- ðŸ³ Docker Files
- ðŸ”§ Scripts (.sh)
- ðŸ“¦ Project Folders
- ðŸ“ Code Organization Folders
- ðŸ“š Documentation Section

## Statistics

- **Total Projects**: 6
- **Total C# Files**: 20
- **Total Lines of Code**: ~2,500
- **Total Documentation Files**: 5
- **Total Configuration Files**: 4
- **Total Scripts**: 2

## Quick Access

| What You Need | Where to Find It |
|---------------|------------------|
| Start the app | `setup.sh` or `docker-compose.yml` |
| API endpoints | `src/DnDMapBuilder.Api/Controllers/` |
| Database setup | `src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs` |
| Business logic | `src/DnDMapBuilder.Application/Services/` |
| API contracts | `src/DnDMapBuilder.Contracts/` |
| Configuration | `src/DnDMapBuilder.Api/appsettings.json` |
| Documentation | Root `*.md` files |
</file>

<file path="verify-structure.sh">
#!/bin/bash

# DnD Map Builder - Structure Verification Script
# This script verifies that all necessary files are present

echo "=========================================="
echo "DnD Map Builder - Structure Verification"
echo "=========================================="
echo ""

ERRORS=0

# Function to check if file exists
check_file() {
    if [ -f "$1" ]; then
        echo "âœ… $1"
    else
        echo "âŒ MISSING: $1"
        ERRORS=$((ERRORS + 1))
    fi
}

# Function to check if directory exists
check_dir() {
    if [ -d "$1" ]; then
        echo "âœ… $1/"
    else
        echo "âŒ MISSING: $1/"
        ERRORS=$((ERRORS + 1))
    fi
}

echo "Checking root files..."
check_file "DnDMapBuilder.sln"
check_file ".gitignore"
check_file "docker-compose.yml"
check_file "setup.sh"
check_file "README.md"
check_file "QUICKSTART.md"
check_file "API_DOCUMENTATION.md"
check_file "PROJECT_SUMMARY.md"
check_file "FILE_STRUCTURE.md"
echo ""

echo "Checking project directories..."
check_dir "src/DnDMapBuilder.Contracts"
check_dir "src/DnDMapBuilder.Data"
check_dir "src/DnDMapBuilder.Application"
check_dir "src/DnDMapBuilder.Api"
check_dir "src/DnDMapBuilder.Aspire.AppHost"
check_dir "src/DnDMapBuilder.Aspire.ServiceDefaults"
echo ""

echo "Checking Contracts project..."
check_file "src/DnDMapBuilder.Contracts/DnDMapBuilder.Contracts.csproj"
check_file "src/DnDMapBuilder.Contracts/DTOs/DomainDtos.cs"
check_file "src/DnDMapBuilder.Contracts/Requests/ApiRequests.cs"
check_file "src/DnDMapBuilder.Contracts/Responses/ApiResponses.cs"
echo ""

echo "Checking Data project..."
check_file "src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj"
check_file "src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs"
check_file "src/DnDMapBuilder.Data/Entities/DomainEntities.cs"
check_file "src/DnDMapBuilder.Data/Repositories/IRepositories.cs"
check_file "src/DnDMapBuilder.Data/Repositories/Repositories.cs"
echo ""

echo "Checking Application project..."
check_file "src/DnDMapBuilder.Application/DnDMapBuilder.Application.csproj"
check_file "src/DnDMapBuilder.Application/Interfaces/IServices.cs"
check_file "src/DnDMapBuilder.Application/Mappings/MappingExtensions.cs"
check_file "src/DnDMapBuilder.Application/Services/AuthService.cs"
check_file "src/DnDMapBuilder.Application/Services/JwtService.cs"
check_file "src/DnDMapBuilder.Application/Services/CampaignService.cs"
check_file "src/DnDMapBuilder.Application/Services/MissionService.cs"
check_file "src/DnDMapBuilder.Application/Services/GameMapAndTokenServices.cs"
echo ""

echo "Checking API project..."
check_file "src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj"
check_file "src/DnDMapBuilder.Api/Program.cs"
check_file "src/DnDMapBuilder.Api/Dockerfile"
check_file "src/DnDMapBuilder.Api/appsettings.json"
check_file "src/DnDMapBuilder.Api/appsettings.Development.json"
check_file "src/DnDMapBuilder.Api/Properties/launchSettings.json"
check_file "src/DnDMapBuilder.Api/Controllers/AuthController.cs"
check_file "src/DnDMapBuilder.Api/Controllers/CampaignsController.cs"
check_file "src/DnDMapBuilder.Api/Controllers/OtherControllers.cs"
echo ""

echo "Checking Aspire projects..."
check_file "src/DnDMapBuilder.Aspire.AppHost/DnDMapBuilder.Aspire.AppHost.csproj"
check_file "src/DnDMapBuilder.Aspire.AppHost/Program.cs"
check_file "src/DnDMapBuilder.Aspire.ServiceDefaults/DnDMapBuilder.Aspire.ServiceDefaults.csproj"
check_file "src/DnDMapBuilder.Aspire.ServiceDefaults/Extensions.cs"
echo ""

echo "=========================================="
if [ $ERRORS -eq 0 ]; then
    echo "âœ… All files present! Structure is correct."
    echo ""
    echo "File counts:"
    echo "  - C# Project files: $(find . -name "*.csproj" | wc -l)"
    echo "  - C# Source files: $(find . -name "*.cs" | wc -l)"
    echo "  - Documentation files: $(find . -maxdepth 1 -name "*.md" | wc -l)"
    echo ""
    echo "You can now:"
    echo "  1. Run './setup.sh' for quick setup"
    echo "  2. Or run 'docker-compose up' for Docker deployment"
    echo "  3. Or read README.md for detailed instructions"
else
    echo "âŒ Found $ERRORS missing file(s)!"
    echo "Please check the structure and ensure all files are present."
fi
echo "=========================================="
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(move \"DnDMapBuilder.Aspire.ServiceDefaults.csproj\" \"src\\DnDMapBuilder.Aspire.ServiceDefaults\"\" && move \"Extensions.cs\" \"srcDnDMapBuilder.Aspire.ServiceDefaults\"\")",
      "Bash(git -C /Users/mikedeiktakis/RiderProjects/DnDMapbuilder-Api show:*)",
      "Bash(dotnet build:*)",
      "Bash(dotnet workload list:*)",
      "Bash(dotnet workload install:*)",
      "Bash(dotnet ef migrations:*)",
      "Bash(dotnet tool install:*)",
      "Bash(dotnet tool update:*)",
      "Bash(export PATH=\"$PATH:/Users/mikedeiktakis/.dotnet/tools\")",
      "Bash(docker ps:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="src/DnDMapBuilder.Api/appsettings.json">
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=sqlserver;Database=dndmapbuilder;User Id=sa;Password=s_2.Z6NWn*Jj17esJD6p+E;TrustServerCertificate=True;"
  },
  "JwtSettings": {
    "SecretKey": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
    "Issuer": "DnDMapBuilderApi",
    "Audience": "DnDMapBuilderClient",
    "ExpirationMinutes": "1440"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Information"
    }
  },
  "AllowedHosts": "*"
}
</file>

<file path="src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="7.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Aspire.ServiceDefaults\DnDMapBuilder.Aspire.ServiceDefaults.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Api/Dockerfile">
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

# Copy solution and project files
COPY ["DnDMapBuilder.sln", "./"]
COPY ["src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj", "src/DnDMapBuilder.Api/"]
COPY ["src/DnDMapBuilder.Application/DnDMapBuilder.Application.csproj", "src/DnDMapBuilder.Application/"]
COPY ["src/DnDMapBuilder.Contracts/DnDMapBuilder.Contracts.csproj", "src/DnDMapBuilder.Contracts/"]
COPY ["src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj", "src/DnDMapBuilder.Data/"]

# Restore dependencies
RUN dotnet restore "src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj"

# Copy everything else
COPY . .

# Build
WORKDIR "/src/src/DnDMapBuilder.Api"
RUN dotnet build "DnDMapBuilder.Api.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "DnDMapBuilder.Api.csproj" -c Release -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "DnDMapBuilder.Api.dll"]
</file>

<file path="src/DnDMapBuilder.AppHost/AppHost.cs">
var builder = DistributedApplication.CreateBuilder(args);

// Disable IDE run session integration (use direct process launching)
builder.Configuration["RunSession:UseIdeRunSession"] = "false";

var sql = builder.AddSqlServer("Database")
    .WithLifetime(ContainerLifetime.Persistent)
    .AddDatabase("dndmapbuilder");

builder.AddProject<Projects.DnDMapBuilder_Api>("dndmapapi")
    .WithReference(sql)
    .WithEnvironment("ConnectionStrings__DefaultConnection", sql)
    .WaitFor(sql)
    .WithEnvironment("ADMIN_EMAIL", "admin@test.com")
    .WithEnvironment("ADMIN_DEFAULT_PASSWORD", "1234")
    .WithEnvironment("MIGRATIONS_EXECUTE", "true");

builder.Build().Run();
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IServices.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Application.Interfaces;

public interface IAuthService
{
    Task<AuthResponse?> RegisterAsync(RegisterRequest request);
    Task<AuthResponse?> LoginAsync(LoginRequest request);
    Task<bool> ApproveUserAsync(string userId, bool approved);
    Task<IEnumerable<UserDto>> GetPendingUsersAsync();
}

public interface ICampaignService
{
    Task<CampaignDto?> GetByIdAsync(string id, string userId);
    Task<IEnumerable<CampaignDto>> GetUserCampaignsAsync(string userId);
    Task<CampaignDto> CreateAsync(CreateCampaignRequest request, string userId);
    Task<CampaignDto?> UpdateAsync(string id, UpdateCampaignRequest request, string userId);
    Task<bool> DeleteAsync(string id, string userId);
}

public interface IMissionService
{
    Task<MissionDto?> GetByIdAsync(string id, string userId);
    Task<IEnumerable<MissionDto>> GetByCampaignIdAsync(string campaignId, string userId);
    Task<MissionDto> CreateAsync(CreateMissionRequest request, string userId);
    Task<MissionDto?> UpdateAsync(string id, UpdateMissionRequest request, string userId);
    Task<bool> DeleteAsync(string id, string userId);
}

public interface IGameMapService
{
    Task<GameMapDto?> GetByIdAsync(string id, string userId);
    Task<IEnumerable<GameMapDto>> GetByMissionIdAsync(string missionId, string userId);
    Task<GameMapDto> CreateAsync(CreateMapRequest request, string userId);
    Task<GameMapDto?> UpdateAsync(string id, UpdateMapRequest request, string userId);
    Task<bool> DeleteAsync(string id, string userId);
}

public interface ITokenDefinitionService
{
    Task<TokenDefinitionDto?> GetByIdAsync(string id, string userId);
    Task<IEnumerable<TokenDefinitionDto>> GetUserTokensAsync(string userId);
    Task<TokenDefinitionDto> CreateAsync(CreateTokenDefinitionRequest request, string userId);
    Task<TokenDefinitionDto?> UpdateAsync(string id, UpdateTokenDefinitionRequest request, string userId);
    Task<bool> DeleteAsync(string id, string userId);
}

public interface IJwtService
{
    string GenerateToken(string userId, string email, string role);
    string? ValidateToken(string token);
}

public interface IFileStorageService
{
    /// <summary>
    /// Uploads a file to storage and returns the file ID for database reference.
    /// </summary>
    /// <param name="file">The file stream to upload</param>
    /// <param name="fileName">Original file name</param>
    /// <param name="contentType">MIME type of the file</param>
    /// <param name="storageCategory">Category for organization (e.g., "maps", "tokens")</param>
    /// <returns>Generated file ID</returns>
    Task<string> UploadAsync(Stream file, string fileName, string contentType, string storageCategory);

    /// <summary>
    /// Gets the public URL for a stored file.
    /// </summary>
    /// <param name="fileId">The file ID returned from upload</param>
    /// <param name="storageCategory">The category where the file is stored</param>
    /// <returns>Public URL to the file</returns>
    string GetPublicUrl(string fileId, string storageCategory);

    /// <summary>
    /// Deletes a file from storage.
    /// </summary>
    /// <param name="fileId">The file ID to delete</param>
    /// <param name="storageCategory">The category where the file is stored</param>
    /// <returns>True if deleted successfully</returns>
    Task<bool> DeleteAsync(string fileId, string storageCategory);
}
</file>

<file path="src/DnDMapBuilder.Application/Mappings/MappingExtensions.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Application.Mappings;

public static class MappingExtensions
{
    public static UserDto ToDto(this User user)
    {
        return new UserDto(
            user.Id,
            user.Username,
            user.Email,
            user.Role,
            user.Status
        );
    }

    public static TokenDefinitionDto ToDto(this TokenDefinition token)
    {
        return new TokenDefinitionDto(
            token.Id,
            token.Name,
            token.ImageUrl,
            token.Size,
            token.Type,
            token.UserId,
            token.ImageFileId,
            token.ImageContentType,
            token.ImageFileSize
        );
    }

    public static MapTokenInstanceDto ToDto(this MapTokenInstance instance)
    {
        return new MapTokenInstanceDto(
            instance.Id,
            instance.TokenId,
            instance.X,
            instance.Y
        );
    }

    public static GameMapDto ToDto(this GameMap map)
    {
        return new GameMapDto(
            map.Id,
            map.Name,
            map.ImageUrl,
            map.Rows,
            map.Cols,
            map.Tokens.Select(t => t.ToDto()).ToList(),
            map.GridColor,
            map.GridOpacity,
            map.MissionId,
            map.ImageFileId,
            map.ImageContentType,
            map.ImageFileSize
        );
    }

    public static MissionDto ToDto(this Mission mission)
    {
        return new MissionDto(
            mission.Id,
            mission.Name,
            mission.Description,
            mission.Maps.Select(m => m.ToDto()).ToList(),
            mission.CampaignId
        );
    }

    public static CampaignDto ToDto(this Campaign campaign)
    {
        return new CampaignDto(
            campaign.Id,
            campaign.Name,
            campaign.Description,
            campaign.Missions.Select(m => m.ToDto()).ToList(),
            campaign.OwnerId,
            campaign.CreatedAt,
            campaign.UpdatedAt
        );
    }
}
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/DomainDtos.cs">
namespace DnDMapBuilder.Contracts.DTOs;

public record UserDto(
    string Id,
    string Username,
    string Email,
    string Role,
    string Status
);

public record TokenDefinitionDto(
    string Id,
    string Name,
    string ImageUrl,
    int Size,
    string Type,
    string UserId,
    string? ImageFileId = null,
    string? ImageContentType = null,
    long ImageFileSize = 0
);

public record MapTokenInstanceDto(
    string InstanceId,
    string TokenId,
    int X,
    int Y
);

public record GameMapDto(
    string Id,
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    List<MapTokenInstanceDto> Tokens,
    string GridColor,
    double GridOpacity,
    string MissionId,
    string? ImageFileId = null,
    string? ImageContentType = null,
    long ImageFileSize = 0
);

public record MissionDto(
    string Id,
    string Name,
    string Description,
    List<GameMapDto> Maps,
    string CampaignId
);

public record CampaignDto(
    string Id,
    string Name,
    string Description,
    List<MissionDto> Missions,
    string OwnerId,
    DateTime CreatedAt,
    DateTime UpdatedAt
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/ApiRequests.cs">
namespace DnDMapBuilder.Contracts.Requests;

public record RegisterRequest(
    string Username,
    string Email,
    string Password
);

public record LoginRequest(
    string Email,
    string Password
);

public record CreateCampaignRequest(
    string Name,
    string Description
);

public record UpdateCampaignRequest(
    string Name,
    string Description
);

public record CreateMissionRequest(
    string Name,
    string Description,
    string CampaignId
);

public record UpdateMissionRequest(
    string Name,
    string Description
);

public record CreateMapRequest(
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    string GridColor,
    double GridOpacity,
    string MissionId
);

public record UpdateMapRequest(
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    List<MapTokenInstanceRequest> Tokens,
    string GridColor,
    double GridOpacity
);

public record MapTokenInstanceRequest(
    string TokenId,
    int X,
    int Y
);

public record CreateTokenDefinitionRequest(
    string Name,
    string ImageUrl,
    int Size,
    string Type
);

public record UpdateTokenDefinitionRequest(
    string Name,
    string ImageUrl,
    int Size,
    string Type
);

public record ApproveUserRequest(
    string UserId,
    bool Approved
);

// File upload response
public record ImageUploadResponse(
    string FileId,
    string Url,
    string ContentType,
    long FileSize
);
</file>

<file path="src/DnDMapBuilder.Data/Entities/DomainEntities.cs">
namespace DnDMapBuilder.Data.Entities;

public class User
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Username { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string PasswordHash { get; set; } = string.Empty;
    public string Role { get; set; } = "user"; // admin or user
    public string Status { get; set; } = "pending"; // pending, approved, rejected
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public ICollection<Campaign> Campaigns { get; set; } = new List<Campaign>();
    public ICollection<TokenDefinition> TokenDefinitions { get; set; } = new List<TokenDefinition>();
}

public class Campaign
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string OwnerId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User Owner { get; set; } = null!;
    public ICollection<Mission> Missions { get; set; } = new List<Mission>();
}

public class Mission
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string CampaignId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public Campaign Campaign { get; set; } = null!;
    public ICollection<GameMap> Maps { get; set; } = new List<GameMap>();
}

public class GameMap
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string? ImageUrl { get; set; }

    // File storage metadata (new fields for multipart upload)
    public string? ImageFileId { get; set; }
    public string? ImageContentType { get; set; }
    public long ImageFileSize { get; set; } = 0;

    public int Rows { get; set; }
    public int Cols { get; set; }
    public string GridColor { get; set; } = "#000000";
    public double GridOpacity { get; set; } = 0.3;
    public string MissionId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public Mission Mission { get; set; } = null!;
    public ICollection<MapTokenInstance> Tokens { get; set; } = new List<MapTokenInstance>();
}

public class TokenDefinition
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string ImageUrl { get; set; } = string.Empty;

    // File storage metadata (new fields for multipart upload)
    public string? ImageFileId { get; set; }
    public string? ImageContentType { get; set; }
    public long ImageFileSize { get; set; } = 0;

    public int Size { get; set; } = 1; // 1, 2, or 3
    public string Type { get; set; } = "player"; // player or enemy
    public string UserId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;
    public ICollection<MapTokenInstance> MapTokenInstances { get; set; } = new List<MapTokenInstance>();
}

public class MapTokenInstance
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string TokenId { get; set; } = string.Empty;
    public string MapId { get; set; } = string.Empty;
    public int X { get; set; }
    public int Y { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public TokenDefinition Token { get; set; } = null!;
    public GameMap Map { get; set; } = null!;
}
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="9.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="9.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

</Project>
</file>

<file path="DnDMapBuilder.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Api", "src\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj", "{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Contracts", "src\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj", "{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Application", "src\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj", "{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Data", "src\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj", "{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Aspire.ServiceDefaults", "src\DnDMapBuilder.Aspire.ServiceDefaults\DnDMapBuilder.Aspire.ServiceDefaults.csproj", "{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.AppHost", "src\DnDMapBuilder.AppHost\DnDMapBuilder.AppHost.csproj", "{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Release|Any CPU.Build.0 = Release|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Release|Any CPU.Build.0 = Release|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Release|Any CPU.Build.0 = Release|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Release|Any CPU.Build.0 = Release|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Release|Any CPU.Build.0 = Release|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal
</file>

<file path="src/DnDMapBuilder.Api/Controllers/OtherControllers.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class MissionsController : ControllerBase
{
    private readonly IMissionService _missionService;

    public MissionsController(IMissionService missionService)
    {
        _missionService = missionService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    [HttpGet("{id}")]
    public async Task<ActionResult<ApiResponse<MissionDto>>> GetMission(string id)
    {
        var mission = await _missionService.GetByIdAsync(id, GetUserId());
        
        if (mission == null)
        {
            return NotFound(new ApiResponse<MissionDto>(false, null, "Mission not found."));
        }

        return Ok(new ApiResponse<MissionDto>(true, mission));
    }

    [HttpGet("campaign/{campaignId}")]
    public async Task<ActionResult<ApiResponse<IEnumerable<MissionDto>>>> GetMissionsByCampaign(string campaignId)
    {
        var missions = await _missionService.GetByCampaignIdAsync(campaignId, GetUserId());
        return Ok(new ApiResponse<IEnumerable<MissionDto>>(true, missions));
    }

    [HttpPost]
    public async Task<ActionResult<ApiResponse<MissionDto>>> CreateMission([FromBody] CreateMissionRequest request)
    {
        try
        {
            var mission = await _missionService.CreateAsync(request, GetUserId());
            return CreatedAtAction(nameof(GetMission), new { id = mission.Id }, new ApiResponse<MissionDto>(true, mission, "Mission created."));
        }
        catch (UnauthorizedAccessException ex)
        {
            return Forbid(ex.Message);
        }
    }

    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<MissionDto>>> UpdateMission(string id, [FromBody] UpdateMissionRequest request)
    {
        var mission = await _missionService.UpdateAsync(id, request, GetUserId());
        
        if (mission == null)
        {
            return NotFound(new ApiResponse<MissionDto>(false, null, "Mission not found."));
        }

        return Ok(new ApiResponse<MissionDto>(true, mission, "Mission updated."));
    }

    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteMission(string id)
    {
        var result = await _missionService.DeleteAsync(id, GetUserId());
        
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Mission not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Mission deleted."));
    }
}

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class MapsController : ControllerBase
{
    private readonly IGameMapService _mapService;
    private readonly IFileStorageService _fileStorageService;

    public MapsController(IGameMapService mapService, IFileStorageService fileStorageService)
    {
        _mapService = mapService;
        _fileStorageService = fileStorageService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    [HttpGet("{id}")]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> GetMap(string id)
    {
        var map = await _mapService.GetByIdAsync(id, GetUserId());
        
        if (map == null)
        {
            return NotFound(new ApiResponse<GameMapDto>(false, null, "Map not found."));
        }

        return Ok(new ApiResponse<GameMapDto>(true, map));
    }

    [HttpGet("mission/{missionId}")]
    public async Task<ActionResult<ApiResponse<IEnumerable<GameMapDto>>>> GetMapsByMission(string missionId)
    {
        var maps = await _mapService.GetByMissionIdAsync(missionId, GetUserId());
        return Ok(new ApiResponse<IEnumerable<GameMapDto>>(true, maps));
    }

    [HttpPost]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> CreateMap([FromBody] CreateMapRequest request)
    {
        try
        {
            var map = await _mapService.CreateAsync(request, GetUserId());
            return CreatedAtAction(nameof(GetMap), new { id = map.Id }, new ApiResponse<GameMapDto>(true, map, "Map created."));
        }
        catch (UnauthorizedAccessException ex)
        {
            return Forbid(ex.Message);
        }
    }

    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> UpdateMap(string id, [FromBody] UpdateMapRequest request)
    {
        var map = await _mapService.UpdateAsync(id, request, GetUserId());
        
        if (map == null)
        {
            return NotFound(new ApiResponse<GameMapDto>(false, null, "Map not found."));
        }

        return Ok(new ApiResponse<GameMapDto>(true, map, "Map updated."));
    }

    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteMap(string id)
    {
        var result = await _mapService.DeleteAsync(id, GetUserId());

        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Map not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Map deleted."));
    }

    [HttpPost("{id}/image")]
    [Consumes("multipart/form-data")]
    public async Task<ActionResult<ApiResponse<ImageUploadResponse>>> UploadMapImage(string id, IFormFile image)
    {
        try
        {
            // Validate file
            if (image == null || image.Length == 0)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "No file provided."));

            // Validate file size (5MB max for maps)
            const long maxFileSize = 5 * 1024 * 1024;
            if (image.Length > maxFileSize)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "File size exceeds 5MB limit."));

            // Validate MIME type
            var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
            if (!allowedMimeTypes.Contains(image.ContentType?.ToLower() ?? ""))
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "Invalid file format. Allowed: PNG, JPEG, WebP."));

            // Get map to verify ownership
            var map = await _mapService.GetByIdAsync(id, GetUserId());
            if (map == null)
                return NotFound(new ApiResponse<ImageUploadResponse>(false, null, "Map not found."));

            // Upload file
            var fileId = await _fileStorageService.UploadAsync(
                image.OpenReadStream(),
                image.FileName,
                image.ContentType,
                "maps"
            );

            // Update map with file metadata
            var updatedMap = map with
            {
                ImageFileId = fileId,
                ImageContentType = image.ContentType,
                ImageFileSize = image.Length,
                ImageUrl = _fileStorageService.GetPublicUrl(fileId, "maps")
            };

            // Update database
            var tokenRequests = updatedMap.Tokens
                .Select(t => new MapTokenInstanceRequest(t.TokenId, t.X, t.Y))
                .ToList();

            var result = await _mapService.UpdateAsync(id, new UpdateMapRequest(
                updatedMap.Name,
                updatedMap.ImageUrl,
                updatedMap.Rows,
                updatedMap.Cols,
                tokenRequests,
                updatedMap.GridColor,
                updatedMap.GridOpacity
            ), GetUserId());

            var response = new ImageUploadResponse(fileId, result.ImageUrl ?? "", image.ContentType ?? "application/octet-stream", image.Length);
            return Ok(new ApiResponse<ImageUploadResponse>(true, response, "Image uploaded successfully."));
        }
        catch (Exception ex)
        {
            return StatusCode(500, new ApiResponse<ImageUploadResponse>(false, null, $"Error uploading image: {ex.Message}"));
        }
    }
}

[Authorize]
[ApiController]
[Route("api/[controller]")]
public class TokensController : ControllerBase
{
    private readonly ITokenDefinitionService _tokenService;
    private readonly IFileStorageService _fileStorageService;

    public TokensController(ITokenDefinitionService tokenService, IFileStorageService fileStorageService)
    {
        _tokenService = tokenService;
        _fileStorageService = fileStorageService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    [HttpGet]
    public async Task<ActionResult<ApiResponse<IEnumerable<TokenDefinitionDto>>>> GetUserTokens()
    {
        var tokens = await _tokenService.GetUserTokensAsync(GetUserId());
        return Ok(new ApiResponse<IEnumerable<TokenDefinitionDto>>(true, tokens));
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> GetToken(string id)
    {
        var token = await _tokenService.GetByIdAsync(id, GetUserId());
        
        if (token == null)
        {
            return NotFound(new ApiResponse<TokenDefinitionDto>(false, null, "Token not found."));
        }

        return Ok(new ApiResponse<TokenDefinitionDto>(true, token));
    }

    [HttpPost]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> CreateToken([FromBody] CreateTokenDefinitionRequest request)
    {
        var token = await _tokenService.CreateAsync(request, GetUserId());
        return CreatedAtAction(nameof(GetToken), new { id = token.Id }, new ApiResponse<TokenDefinitionDto>(true, token, "Token created."));
    }

    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> UpdateToken(string id, [FromBody] UpdateTokenDefinitionRequest request)
    {
        var token = await _tokenService.UpdateAsync(id, request, GetUserId());
        
        if (token == null)
        {
            return NotFound(new ApiResponse<TokenDefinitionDto>(false, null, "Token not found."));
        }

        return Ok(new ApiResponse<TokenDefinitionDto>(true, token, "Token updated."));
    }

    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteToken(string id)
    {
        var result = await _tokenService.DeleteAsync(id, GetUserId());

        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Token not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Token deleted."));
    }

    [HttpPost("{id}/image")]
    [Consumes("multipart/form-data")]
    public async Task<ActionResult<ApiResponse<ImageUploadResponse>>> UploadTokenImage(string id, IFormFile image)
    {
        try
        {
            // Validate file
            if (image == null || image.Length == 0)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "No file provided."));

            // Validate file size (2MB max for tokens)
            const long maxFileSize = 2 * 1024 * 1024;
            if (image.Length > maxFileSize)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "File size exceeds 2MB limit."));

            // Validate MIME type
            var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
            if (!allowedMimeTypes.Contains(image.ContentType?.ToLower() ?? ""))
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "Invalid file format. Allowed: PNG, JPEG, WebP."));

            // Get token to verify ownership
            var token = await _tokenService.GetByIdAsync(id, GetUserId());
            if (token == null)
                return NotFound(new ApiResponse<ImageUploadResponse>(false, null, "Token not found."));

            // Upload file
            var fileId = await _fileStorageService.UploadAsync(
                image.OpenReadStream(),
                image.FileName,
                image.ContentType,
                "tokens"
            );

            // Update token with file metadata
            var updatedToken = token with
            {
                ImageFileId = fileId,
                ImageContentType = image.ContentType,
                ImageFileSize = image.Length,
                ImageUrl = _fileStorageService.GetPublicUrl(fileId, "tokens")
            };

            // Update database
            var result = await _tokenService.UpdateAsync(id, new UpdateTokenDefinitionRequest(
                updatedToken.Name,
                updatedToken.ImageUrl,
                updatedToken.Size,
                updatedToken.Type
            ), GetUserId());

            var response = new ImageUploadResponse(fileId, result.ImageUrl ?? "", image.ContentType ?? "application/octet-stream", image.Length);
            return Ok(new ApiResponse<ImageUploadResponse>(true, response, "Image uploaded successfully."));
        }
        catch (Exception ex)
        {
            return StatusCode(500, new ApiResponse<ImageUploadResponse>(false, null, $"Error uploading image: {ex.Message}"));
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/DnDMapBuilderDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    partial class DnDMapBuilderDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data;

public class DnDMapBuilderDbContext : DbContext
{
    public DnDMapBuilderDbContext(DbContextOptions<DnDMapBuilderDbContext> options)
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; } = null!;
    public DbSet<Campaign> Campaigns { get; set; } = null!;
    public DbSet<Mission> Missions { get; set; } = null!;
    public DbSet<GameMap> GameMaps { get; set; } = null!;
    public DbSet<TokenDefinition> TokenDefinitions { get; set; } = null!;
    public DbSet<MapTokenInstance> MapTokenInstances { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.HasIndex(e => e.Email).IsUnique();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.Property(e => e.Username).IsRequired().HasMaxLength(100);
            entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
            entity.Property(e => e.PasswordHash).IsRequired();
            entity.Property(e => e.Role).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Status).IsRequired().HasMaxLength(50);
        });

        // Campaign configuration
        modelBuilder.Entity<Campaign>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Description).HasMaxLength(2000);
            
            entity.HasOne(e => e.Owner)
                .WithMany(u => u.Campaigns)
                .HasForeignKey(e => e.OwnerId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Mission configuration
        modelBuilder.Entity<Mission>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Description).HasMaxLength(2000);
            
            entity.HasOne(e => e.Campaign)
                .WithMany(c => c.Missions)
                .HasForeignKey(e => e.CampaignId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // GameMap configuration
        modelBuilder.Entity<GameMap>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.ImageUrl).HasMaxLength(1000);
            entity.Property(e => e.GridColor).IsRequired().HasMaxLength(20);
            
            entity.HasOne(e => e.Mission)
                .WithMany(m => m.Maps)
                .HasForeignKey(e => e.MissionId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // TokenDefinition configuration
        modelBuilder.Entity<TokenDefinition>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.ImageUrl).IsRequired().HasMaxLength(1000);
            entity.Property(e => e.Type).IsRequired().HasMaxLength(50);
            
            entity.HasOne(e => e.User)
                .WithMany(u => u.TokenDefinitions)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // MapTokenInstance configuration
        modelBuilder.Entity<MapTokenInstance>(entity =>
        {
            entity.HasKey(e => e.Id);
            
            entity.HasOne(e => e.Token)
                .WithMany(t => t.MapTokenInstances)
                .HasForeignKey(e => e.TokenId)
                .OnDelete(DeleteBehavior.Restrict);
            
            entity.HasOne(e => e.Map)
                .WithMany(m => m.Tokens)
                .HasForeignKey(e => e.MapId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Note: Admin user is seeded via DbInitializer at runtime, not via migrations
        // This allows the password to be read from environment variables securely
    }
}
</file>

<file path=".gitignore">
# Build results
bin/
obj/
Debug/
Release/
x64/
x86/
*.o
*.a
*.so
*.exe
*.dll
*.pdb
*.mdb

# All project build directories
src/**/bin/
src/**/obj/
src/**/Debug/
src/**/Release/

# Visual Studio and Rider cache and settings
.vs/
.vscode/
.idea/
*.suo
*.user
*.userosscache
*.sln.docstates
*.sln.DotSettings.user

# ReSharper
.resharper
.resharper.user
*.resharper.user
_ReSharper*/
*_resharper.jfm

# JetBrains Rider
.idea/
*.sln.iml
riderModule.iml

# NuGet
*.nupkg
*.snupkg
.nuget/
packages/
.packages/
src/**/packages/
*.nuget.props
*.nuget.targets

# Local environment files
.env
.env.local
appsettings.local.json
appsettings.Development.json

# macOS
.DS_Store
.AppleDouble
.LSOverride
*.swp
*.swo

# Windows
Thumbs.db
Desktop.ini

# Logs
logs/
*.log
npm-debug.log*

# Temporary files
*.tmp
*.temp
*~

# Build and test artifacts
TestResults/
coverage/
.coverage
*.trx

# ASP.NET Core
Properties/launchSettings.json
launchSettings.json

# Uploaded files (user content)
src/DnDMapBuilder.Api/wwwroot/uploads/

# Entity Framework Core
# Note: Migrations SHOULD be committed to track database schema changes

# Azure DevOps
.vs_extensions/

# Global settings
global.json
DnDMapBuilder.sln.DotSettings.user
BACKEND_ENHANCEMENT_PROMPT_PLAN.md
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: src/DnDMapBuilder.Api/Dockerfile
    container_name: dnd-api
    restart: unless-stopped
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=https://+:443;http://+:80
      - ASPNETCORE_Kestrel__Certificates__Default__Path=/app/certs/aspnetapp.pfx
      - ASPNETCORE_Kestrel__Certificates__Default__Password=crypticpassword
    ports:
      - "5000:80"
      - "5001:443"
    volumes:
      - ./certs:/app/certs:ro
      - ./uploads:/app/wwwroot/uploads
    networks:
      - dnd-network

networks:
  dnd-network:
    driver: bridge
</file>

<file path="src/DnDMapBuilder.Api/Program.cs">
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Repositories;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "DnD Map Builder API", Version = "v1" });
    
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme. Enter 'Bearer' [space] and then your token.",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

// Database
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<DnDMapBuilderDbContext>(options =>
    options.UseSqlServer(connectionString));

// JWT Configuration
var jwtSettings = builder.Configuration.GetSection("JwtSettings");
var secretKey = jwtSettings["SecretKey"] ?? throw new InvalidOperationException("JWT SecretKey not configured");

builder.Services.AddSingleton<IJwtService>(sp => 
    new JwtService(
        secretKey,
        jwtSettings["Issuer"] ?? "DnDMapBuilderApi",
        jwtSettings["Audience"] ?? "DnDMapBuilderClient",
        int.Parse(jwtSettings["ExpirationMinutes"] ?? "1440")
    ));

builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)),
        ValidateIssuer = true,
        ValidIssuer = jwtSettings["Issuer"],
        ValidateAudience = true,
        ValidAudience = jwtSettings["Audience"],
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero
    };
});

builder.Services.AddAuthorization();

// CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

// Register Repositories
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<ICampaignRepository, CampaignRepository>();
builder.Services.AddScoped<IMissionRepository, MissionRepository>();
builder.Services.AddScoped<IGameMapRepository, GameMapRepository>();
builder.Services.AddScoped<ITokenDefinitionRepository, TokenDefinitionRepository>();
builder.Services.AddScoped<IMapTokenInstanceRepository, MapTokenInstanceRepository>();

// Register Services
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<ICampaignService, CampaignService>();
builder.Services.AddScoped<IMissionService, MissionService>();
builder.Services.AddScoped<IGameMapService, GameMapService>();
builder.Services.AddScoped<ITokenDefinitionService, TokenDefinitionService>();

// File Storage Service
var baseStoragePath = Path.Combine(builder.Environment.ContentRootPath, "wwwroot", "uploads");
var basePublicUrl = "/uploads";
builder.Services.AddSingleton<IFileStorageService>(sp =>
    new LocalFileStorageService(baseStoragePath, basePublicUrl, sp.GetRequiredService<ILogger<LocalFileStorageService>>()));

var app = builder.Build();

app.MapDefaultEndpoints();

// Apply migrations and seed admin user on startup
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<DnDMapBuilderDbContext>();
    await DbInitializer.InitializeAsync(db);
}

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

// Ensure wwwroot directory exists for static file serving
var wwwrootPath = Path.Combine(app.Environment.ContentRootPath, "wwwroot");
if (!Directory.Exists(wwwrootPath))
{
    Directory.CreateDirectory(wwwrootPath);
}

// Serve static files from wwwroot at /api path
// This matches the frontend's URL construction: BASE_URL + imageUrl = /api + /uploads/...
app.UseStaticFiles(new StaticFileOptions
{
    FileProvider = new Microsoft.Extensions.FileProviders.PhysicalFileProvider(wwwrootPath),
    RequestPath = "/api"
});

app.UseCors("AllowAll");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();
</file>

<file path=".github/workflows/main.yml">
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch: # Allows manual triggering

env:
  DOTNET_VERSION: '10.0.x'
  REGISTRY: ghcr.io

jobs:
  # Job 1: Build and Test
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore dependencies
      run: dotnet restore DnDMapBuilder.sln

    - name: Build
      run: dotnet build DnDMapBuilder.sln --configuration Release --no-restore

    - name: Test
      run: dotnet test DnDMapBuilder.sln --configuration Release --no-build --verbosity normal

  # Job 2: Build and Push Docker Image
  build-docker:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write

    outputs:
      image-name: ${{ steps.image-name.outputs.lowercase }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Convert repository name to lowercase
      id: image-name
      run: echo "lowercase=${GITHUB_REPOSITORY@L}" >> $GITHUB_OUTPUT

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels)
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.lowercase }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./src/DnDMapBuilder.Api/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Job 3: Deploy to Server
  deploy:
    needs: build-docker
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to server via SSH
      env:
        IMAGE_NAME: ${{ needs.build-docker.outputs.image-name }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        envs: IMAGE_NAME
        script: |
          # Login to GitHub Container Registry
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # Create Docker network if it doesn't exist
          sudo docker network create dnd-network 2>/dev/null || true

          # Pull the latest image
          sudo docker pull ghcr.io/${IMAGE_NAME}:latest

          # Stop and remove old container
          sudo docker stop dnd-api || true
          sudo docker rm dnd-api || true

          # Create uploads directory on host if it doesn't exist
          mkdir -p ~/dnd-api-uploads

          # Run new container with environment variables
          sudo docker run -d \
            --name dnd-api \
            --restart unless-stopped \
            -p 5000:8080 \
            -e ASPNETCORE_ENVIRONMENT=Production \
            -e ASPNETCORE_URLS="http://+:8080" \
            -e ConnectionStrings__DefaultConnection="${{ secrets.DB_CONNECTION_STRING }}" \
            -e JwtSettings__Secret="${{ secrets.JWT_SECRET }}" \
            -e JwtSettings__Issuer="${{ secrets.JWT_ISSUER }}" \
            -e JwtSettings__Audience="${{ secrets.JWT_AUDIENCE }}" \
            -e ADMIN_DEFAULT_PASSWORD="${{ secrets.ADMIN_DEFAULT_PASSWORD }}" \
            -e ADMIN_EMAIL="${{ secrets.ADMIN_EMAIL }}" \
            -v ~/dnd-api-uploads:/app/wwwroot/uploads \
            --network dnd-network \
            ghcr.io/${IMAGE_NAME}:latest

          # Clean up old images
          sudo docker image prune -f

    - name: Verify deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        script: |
          # Check if container is running
          sudo docker ps | grep dnd-api

          # Check container logs
          sudo docker logs dnd-api --tail 50
</file>

</files>
