This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  commands/
    execute_prompt_plan.md
  settings.local.json
.github/
  workflows/
    main.yml
  FIX_DOCKER_PERMISSIONS.md
  GITHUB_ACTIONS_GUIDE.md
  GITLAB_VS_GITHUB_COMPARISON.md
  MULTI_PLATFORM_BUILD.md
scripts/
  run-migrations.sh
src/
  DnDMapBuilder.Api/
    Controllers/
      AuthController.cs
      CampaignsController.cs
      GameMapsController.cs
      MissionsController.cs
      TokensController.cs
    appsettings.json
    DnDMapBuilder.Api.csproj
    Dockerfile
    GlobalSuppressions.cs
    Program.cs
  DnDMapBuilder.AppHost/
    AppHost.cs
    appsettings.json
    DnDMapBuilder.AppHost.csproj
  DnDMapBuilder.Application/
    Common/
      Result.cs
    Interfaces/
      IAuthService.cs
      ICampaignService.cs
      IFileStorageService.cs
      IFileValidationService.cs
      IGameMapService.cs
      IJwtService.cs
      IMissionService.cs
      IPasswordService.cs
      ITokenDefinitionService.cs
      IUserManagementService.cs
    Mappings/
      MappingExtensions.cs
    Services/
      AuthService.cs
      CampaignService.cs
      FileStorageService.cs
      FileValidationService.cs
      GameMapService.cs
      JwtService.cs
      MissionService.cs
      PasswordService.cs
      TokenDefinitionService.cs
      UserManagementService.cs
    DnDMapBuilder.Application.csproj
  DnDMapBuilder.ArchitectureTests/
    ArchitectureTests.cs
    DnDMapBuilder.ArchitectureTests.csproj
  DnDMapBuilder.Aspire.ServiceDefaults/
    DnDMapBuilder.Aspire.ServiceDefaults.csproj
    Extensions.cs
  DnDMapBuilder.Contracts/
    DTOs/
      CampaignDto.cs
      GameMapDto.cs
      MapTokenInstanceDto.cs
      MissionDto.cs
      TokenDefinitionDto.cs
      UserDto.cs
    Pagination/
      PaginatedRequest.cs
      PaginatedResponse.cs
    Requests/
      ApproveUserRequest.cs
      CreateCampaignRequest.cs
      CreateMapRequest.cs
      CreateMissionRequest.cs
      CreateTokenDefinitionRequest.cs
      ImageUploadResponse.cs
      LoginRequest.cs
      MapTokenInstanceRequest.cs
      RegisterRequest.cs
      UpdateCampaignRequest.cs
      UpdateMapRequest.cs
      UpdateMissionRequest.cs
      UpdateTokenDefinitionRequest.cs
    Responses/
      ApiResponse.cs
      AuthResponse.cs
      PaginatedResponse.cs
    DnDMapBuilder.Contracts.csproj
  DnDMapBuilder.Data/
    Entities/
      Campaign.cs
      GameMap.cs
      MapTokenInstance.cs
      Mission.cs
      TokenDefinition.cs
      User.cs
    Migrations/
      20260114100522_InitialCreate.cs
      20260114100522_InitialCreate.Designer.cs
      20260115221337_PendingModelChanges.cs
      20260115221337_PendingModelChanges.Designer.cs
      20260116231211_UpdateAdminPasswordHash.cs
      20260116231211_UpdateAdminPasswordHash.Designer.cs
      20260116232059_RemoveSeedData.cs
      20260116232059_RemoveSeedData.Designer.cs
      20260117102707_AddImageFileStorageMetadata.cs
      20260117102707_AddImageFileStorageMetadata.Designer.cs
      20260117104633_SaveImageFiles.cs
      20260117104633_SaveImageFiles.Designer.cs
      20260117221839_ConfigureCascadeDeletes.cs
      20260117221839_ConfigureCascadeDeletes.Designer.cs
      20260117222805_FixCascadeDeleteTokenDefinition.cs
      20260117222805_FixCascadeDeleteTokenDefinition.Designer.cs
      DnDMapBuilderDbContextModelSnapshot.cs
    Repositories/
      Interfaces/
        ICampaignRepository.cs
        IGameMapRepository.cs
        IGenericRepository.cs
        IMapTokenInstanceRepository.cs
        IMissionRepository.cs
        ITokenDefinitionRepository.cs
        IUserRepository.cs
      CampaignRepository.cs
      GameMapRepository.cs
      GenericRepository.cs
      MapTokenInstanceRepository.cs
      MissionRepository.cs
      TokenDefinitionRepository.cs
      UserRepository.cs
    DbInitializer.cs
    DnDMapBuilder.Data.csproj
    DnDMapBuilderDbContext.cs
    DnDMapBuilderDbContextFactory.cs
    MigrationRunner.cs
  DnDMapBuilder.Infrastructure/
    Configuration/
      CachingConfiguration.cs
      CorsSettings.cs
      JwtSettings.cs
      RateLimitConfiguration.cs
    HealthChecks/
      HealthCheckConfiguration.cs
    Logging/
      LoggingConfiguration.cs
    Middleware/
      RequestResponseLoggingMiddleware.cs
      SecurityHeadersMiddleware.cs
    Telemetry/
      ITelemetryService.cs
      TelemetryConfiguration.cs
      TelemetryService.cs
    DnDMapBuilder.Infrastructure.csproj
  DnDMapBuilder.IntegrationTests/
    Controllers/
      HealthCheckIntegrationTests.cs
    Data/
      CascadeDeleteTests.cs
    DnDMapBuilder.IntegrationTests.csproj
  DnDMapBuilder.UnitTests/
    Entities/
      EntityTests.cs
    Infrastructure/
      HealthChecks/
        HealthCheckTests.cs
      Telemetry/
        TelemetryServiceTests.cs
      CachingConfigurationTests.cs
    Repositories/
      GenericRepositoryTests.cs
    Services/
      AuthServiceTests.cs
      FileValidationServiceTests.cs
      PasswordServiceTests.cs
      UserManagementServiceTests.cs
    DnDMapBuilder.UnitTests.csproj
.gitignore
API_DOCUMENTATION.md
DEPLOYMENT.md
DnDMapBuilder.sln
docker-compose.yml
dotnet-tools.json
FILE_STRUCTURE.md
generate-certs.sh
LOAD_TESTING.md
PROJECT_SUMMARY.md
prompt_plan.md
QUICKSTART.md
README.md
SECURITY.md
setup.sh
SMOKE_TESTS.md
STRUCTURE_DIAGRAM.md
verify-structure.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/FIX_DOCKER_PERMISSIONS.md">
# Fixing Docker Permission Issues on Your Server

## The Problem

You're seeing this error:
```
permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock
```

This happens because your SSH user doesn't have permission to run Docker commands.

## Solution: Add User to Docker Group

SSH into your server and run these commands:

### Step 1: Add your user to the docker group
```bash
sudo usermod -aG docker $USER
```

If you're deploying with a specific user (e.g., `ubuntu`), replace `$USER`:
```bash
sudo usermod -aG docker ubuntu
```

### Step 2: Apply the group changes

You have two options:

**Option A: Log out and log back in** (Recommended)
```bash
exit
# Then SSH back in
```

**Option B: Activate the group without logging out**
```bash
newgrp docker
```

### Step 3: Verify it works
```bash
docker ps
```

If this runs without `sudo` and without errors, you're all set!

### Step 4: Test the full workflow
```bash
# Test login to GitHub Container Registry
echo "YOUR_GITHUB_PAT" | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin

# Test pulling an image
docker pull hello-world

# Test running a container
docker run hello-world
```

## Alternative Solution: Use Sudo (Not Recommended)

If you can't add the user to the docker group, you can modify the workflow to use `sudo`. However, this requires configuring passwordless sudo for Docker commands.

### Configure passwordless sudo for Docker

1. SSH into your server
2. Edit the sudoers file:
```bash
sudo visudo
```

3. Add this line at the end (replace `ubuntu` with your username):
```bash
ubuntu ALL=(ALL) NOPASSWD: /usr/bin/docker
```

4. Save and exit (Ctrl+X, then Y, then Enter)

5. Update the workflow to use `sudo`:

In `.github/workflows/ci-cd.yml`, replace all `docker` commands with `sudo docker`:
```bash
sudo docker login ...
sudo docker pull ...
sudo docker stop ...
sudo docker rm ...
sudo docker run ...
```

## Checking Current Docker Group Membership

To see if your user is already in the docker group:
```bash
groups $USER
```

Or for a specific user:
```bash
groups ubuntu
```

You should see `docker` in the output.

## Understanding Docker Socket Permissions

The Docker daemon runs as root and listens on `/var/run/docker.sock`. By default, only root and members of the `docker` group can access this socket.

To check socket permissions:
```bash
ls -l /var/run/docker.sock
```

Output should look like:
```
srw-rw---- 1 root docker 0 Jan 15 21:00 /var/run/docker.sock
```

The `docker` in the group column means users in the docker group can access it.

## Security Note

Adding a user to the docker group gives them root-equivalent privileges because Docker containers can be run with root access. Only add trusted users to the docker group.

For production environments, consider:
- Using a dedicated deployment user with minimal privileges
- Implementing proper secret rotation
- Using Docker's user namespaces for additional isolation
- Auditing Docker commands via logging

## Testing Your Fix

After adding your user to the docker group and logging back in, run:

```bash
# Should work without sudo
docker ps

# Should work without sudo
docker images

# Should work without sudo
docker pull alpine
```

If all three commands work without errors, your permissions are fixed!

## Still Having Issues?

### Issue: "Cannot connect to the Docker daemon"
**Solution**: Make sure Docker is running
```bash
sudo systemctl status docker
sudo systemctl start docker
sudo systemctl enable docker  # Enable on boot
```

### Issue: "credential helper" warning
This warning is harmless but can be fixed by installing a credential helper:
```bash
# For Ubuntu/Debian
sudo apt-get install pass gnupg2

# Configure Docker to use it
docker-credential-pass
```

Or ignore it - it won't affect deployment.

### Issue: "network dnd-network not found"
Create the Docker network first:
```bash
docker network create dnd-network
```

Or update the workflow to create it automatically:
```bash
docker network create dnd-network || true
```
</file>

<file path=".github/GITHUB_ACTIONS_GUIDE.md">
# GitHub Actions CI/CD Guide

## Overview

This guide explains how to use the GitHub Actions workflow for your DnD MapBuilder API, and how to configure secrets (similar to GitLab CI/CD variables).

## GitLab vs GitHub Actions: Key Differences

| Feature | GitLab CI/CD | GitHub Actions |
|---------|--------------|----------------|
| **Config File** | `.gitlab-ci.yml` (root) | `.github/workflows/*.yml` |
| **Variables/Secrets** | Settings > CI/CD > Variables | Settings > Secrets and variables > Actions |
| **Jobs** | Defined in stages | Defined in jobs (can run in parallel or sequence) |
| **Runners** | GitLab Runners | GitHub-hosted or self-hosted runners |
| **Docker Registry** | GitLab Container Registry | GitHub Container Registry (ghcr.io) |
| **Manual Trigger** | `when: manual` | `workflow_dispatch` |

## How the Workflow Works

The workflow has 3 jobs that run sequentially:

### 1. Build and Test (`build-and-test`)
- Triggers on: Push to `main`/`develop` or Pull Requests
- Checks out code
- Sets up .NET 10.0
- Restores dependencies
- Builds the solution
- Runs tests

### 2. Build Docker Image (`build-docker`)
- Runs only on push to `main` branch (after tests pass)
- Builds Docker image using your Dockerfile
- Pushes to GitHub Container Registry (ghcr.io)
- Tags images with branch name, commit SHA, and 'latest'

### 3. Deploy to Server (`deploy`)
- Runs only on push to `main` branch (after Docker build)
- Connects to your server via SSH
- Pulls the latest Docker image
- Stops old container
- Starts new container with environment variables
- Verifies deployment

## Setting Up Secrets (GitLab Variables Equivalent)

In GitHub, secrets are stored in: **Repository Settings > Secrets and variables > Actions**

### Required Secrets

#### Server Connection Secrets
```
SECRET NAME: SERVER_HOST
VALUE: your-server-ip-or-domain.com
DESCRIPTION: IP address or domain of your deployment server
```

```
SECRET NAME: SERVER_USERNAME
VALUE: ubuntu (or your SSH username)
DESCRIPTION: SSH username for server access
```

```
SECRET NAME: SSH_PRIVATE_KEY
VALUE: -----BEGIN OPENSSH PRIVATE KEY-----
...your private key content...
-----END OPENSSH PRIVATE KEY-----
DESCRIPTION: SSH private key for server authentication
```

```
SECRET NAME: SERVER_PORT
VALUE: 22 (optional, defaults to 22)
DESCRIPTION: SSH port if different from 22
```

#### Application Secrets
```
SECRET NAME: DB_CONNECTION_STRING
VALUE: Host=your-db-host;Database=dndmapbuilder;Username=dbuser;Password=dbpass
DESCRIPTION: PostgreSQL/SQL Server connection string
```

```
SECRET NAME: JWT_SECRET
VALUE: your-super-secret-jwt-key-at-least-32-characters-long
DESCRIPTION: Secret key for JWT token signing
```

```
SECRET NAME: JWT_ISSUER
VALUE: https://your-api-domain.com
DESCRIPTION: JWT token issuer
```

```
SECRET NAME: JWT_AUDIENCE
VALUE: https://your-api-domain.com
DESCRIPTION: JWT token audience
```

### How to Add Secrets

1. Go to your GitHub repository
2. Click **Settings** tab
3. In the left sidebar, click **Secrets and variables** > **Actions**
4. Click **New repository secret**
5. Enter the secret name and value
6. Click **Add secret**

### Secret Scopes

- **Repository secrets**: Available to all workflows in the repository (default)
- **Environment secrets**: Scoped to specific environments (production, staging)
- **Organization secrets**: Shared across multiple repositories

## Generating SSH Key Pair

If you don't have SSH keys set up:

```bash
# On your local machine
ssh-keygen -t ed25519 -C "github-actions-deploy" -f ~/.ssh/github_actions_deploy

# Copy public key to your server
ssh-copy-id -i ~/.ssh/github_actions_deploy.pub user@your-server.com

# Copy private key content to GitHub secret
cat ~/.ssh/github_actions_deploy
# Copy the entire output including BEGIN and END lines
```

## GitHub Container Registry Setup

GitHub Container Registry (ghcr.io) is free and automatically available. No extra setup needed!

The workflow uses `GITHUB_TOKEN` which is automatically provided by GitHub Actions.

### Making Your Image Public (Optional)

1. Go to your package: https://github.com/users/YOUR_USERNAME/packages/container/YOUR_REPO
2. Click **Package settings**
3. Change visibility to Public if desired

## Triggering the Workflow

### Automatic Triggers
- **Push to `main` or `develop`**: Runs build, test, Docker build (only on main), and deploy (only on main)
- **Pull Request to `main` or `develop`**: Runs build and test only

### Manual Trigger
1. Go to **Actions** tab in your repository
2. Select **CI/CD Pipeline** workflow
3. Click **Run workflow** button
4. Select branch and click **Run workflow**

## Monitoring Workflow Runs

1. Go to **Actions** tab in your repository
2. Click on a workflow run to see details
3. Click on individual jobs to see logs
4. Failed steps will be highlighted in red

## Environment Variables in Workflow

There are two types of variables:

### 1. Secrets (Sensitive Data)
```yaml
${{ secrets.DB_CONNECTION_STRING }}
```
- Encrypted and hidden in logs
- Used for passwords, keys, tokens

### 2. Environment Variables (Non-Sensitive)
```yaml
env:
  DOTNET_VERSION: '10.0.x'
```
- Visible in workflow file
- Used for versions, public URLs

### 3. GitHub Context Variables
```yaml
${{ github.repository }}  # owner/repo-name
${{ github.actor }}       # username who triggered
${{ github.ref }}         # branch reference
```

## Customizing the Workflow

### Change Deployment Branch
To deploy from `develop` instead of `main`:
```yaml
if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
```

### Add Staging Environment
```yaml
deploy-staging:
  if: github.ref == 'refs/heads/develop'
  environment: staging
  # ... steps
```

### Add Database Migrations
Add before deployment:
```yaml
- name: Run migrations
  uses: appleboy/ssh-action@v1.0.0
  with:
    host: ${{ secrets.SERVER_HOST }}
    username: ${{ secrets.SERVER_USERNAME }}
    key: ${{ secrets.SSH_PRIVATE_KEY }}
    script: |
      docker exec dnd-api dotnet ef database update
```

## Caching for Faster Builds

The workflow already includes Docker layer caching:
```yaml
cache-from: type=gha
cache-to: type=gha,mode=max
```

To add .NET dependency caching:
```yaml
- uses: actions/cache@v3
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
```

## Notifications

### Slack Notifications
Add to the end of deploy job:
```yaml
- name: Notify Slack
  uses: slackapi/slack-github-action@v1
  with:
    webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
    payload: |
      {
        "text": "Deployment completed: ${{ job.status }}"
      }
```

### Email Notifications
GitHub sends email notifications for failed workflows automatically.

## Troubleshooting

### SSH Connection Fails
- Verify `SERVER_HOST`, `SERVER_USERNAME`, and `SSH_PRIVATE_KEY` secrets
- Ensure server allows SSH from GitHub's IP ranges
- Check that public key is in `~/.ssh/authorized_keys` on server

### Docker Pull Fails
- Ensure GitHub token has package read permissions
- Make package public or use Personal Access Token with `read:packages` scope

### Container Won't Start
- Check secrets are correctly set
- Review container logs: `docker logs dnd-api`
- Verify environment variables format

## Security Best Practices

1. **Never commit secrets to code**
2. **Use environment-specific secrets** for production vs staging
3. **Rotate secrets regularly**
4. **Use least-privilege service accounts** for SSH access
5. **Enable branch protection** on `main` to require PR reviews
6. **Use environment protection rules** to require manual approval for production deploys

## Next Steps

1. Add secrets to your GitHub repository
2. Push this workflow to your `main` branch
3. Monitor the Actions tab for the first run
4. Adjust the workflow based on your specific needs
</file>

<file path=".github/GITLAB_VS_GITHUB_COMPARISON.md">
# GitLab CI/CD vs GitHub Actions: Side-by-Side Comparison

## Configuration File Structure

### GitLab CI/CD (.gitlab-ci.yml)
```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOTNET_VERSION: "10.0"

build_job:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:10.0
  script:
    - dotnet restore
    - dotnet build
  only:
    - main
    - develop

deploy_job:
  stage: deploy
  script:
    - ssh user@server "docker pull image"
  only:
    - main
  when: manual
```

### GitHub Actions (.github/workflows/ci-cd.yml)
```yaml
on:
  push:
    branches: [ main, develop ]

env:
  DOTNET_VERSION: '10.0.x'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: |
          dotnet restore
          dotnet build

  deploy:
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: ssh user@server "docker pull image"
    # workflow_dispatch enables manual trigger
```

## Variables and Secrets

### GitLab: CI/CD Variables
**Location**: Settings > CI/CD > Variables

```yaml
# In .gitlab-ci.yml
script:
  - echo $DB_CONNECTION_STRING
  - echo $CI_COMMIT_SHA  # GitLab predefined variable
```

**Variable Types**:
- Regular variables
- Protected variables (only for protected branches)
- Masked variables (hidden in logs)
- File variables (content saved to temp file)

### GitHub: Secrets and Variables
**Location**: Settings > Secrets and variables > Actions

```yaml
# In workflow file
run: |
  echo ${{ secrets.DB_CONNECTION_STRING }}
  echo ${{ github.sha }}  # GitHub context variable
```

**Types**:
- Secrets (encrypted, hidden in logs)
- Variables (plain text, visible)
- Environment secrets (scoped to environments)

## Key Concept Mapping

| GitLab Concept | GitHub Actions Equivalent | Notes |
|----------------|---------------------------|-------|
| `.gitlab-ci.yml` | `.github/workflows/*.yml` | GitHub allows multiple workflow files |
| `stages:` | `jobs:` with `needs:` | GitHub jobs run in parallel by default |
| `stage: build` | `jobs: build:` | Define job dependencies with `needs:` |
| `script:` | `steps:` with `run:` | GitHub uses steps within jobs |
| `image:` | `runs-on:` or `container:` | GitHub has hosted runners |
| `only:` / `except:` | `if:` conditions | GitHub uses expressions |
| `when: manual` | `workflow_dispatch` event | Different trigger mechanism |
| `artifacts:` | `actions/upload-artifact` | GitHub uses actions |
| `cache:` | `actions/cache` | GitHub uses actions |
| `before_script:` | Common step at start | No built-in concept |
| `after_script:` | Add step with `if: always()` | No built-in concept |
| `variables:` | `env:` | GitHub also has `secrets` |
| `$CI_*` variables | `${{ github.* }}` context | Different syntax and names |
| `extends:` | Reusable workflows | Different mechanism |
| `rules:` | `if:` conditions | GitHub uses expressions |
| `environment:` | `environment:` | Similar concept |
| `services:` | `services:` in job | Similar concept |
| `retry:` | `uses: nick-invision/retry@v2` | Needs action |

## Common Variables/Context Mapping

| GitLab Variable | GitHub Context | Value |
|-----------------|----------------|-------|
| `$CI_COMMIT_SHA` | `${{ github.sha }}` | Commit SHA |
| `$CI_COMMIT_REF_NAME` | `${{ github.ref_name }}` | Branch name |
| `$CI_PIPELINE_ID` | `${{ github.run_id }}` | Pipeline/Run ID |
| `$CI_JOB_ID` | `${{ github.job }}` | Job ID |
| `$CI_PROJECT_NAME` | `${{ github.repository }}` | Project name |
| `$CI_COMMIT_MESSAGE` | `${{ github.event.head_commit.message }}` | Commit message |
| `$CI_COMMIT_BRANCH` | `${{ github.ref_name }}` | Branch name |
| `$GITLAB_USER_LOGIN` | `${{ github.actor }}` | Username |
| `$CI_REGISTRY` | `ghcr.io` | Container registry |
| `$CI_REGISTRY_USER` | `${{ github.actor }}` | Registry username |
| `$CI_REGISTRY_PASSWORD` | `${{ secrets.GITHUB_TOKEN }}` | Registry password |

## SSH Deployment Comparison

### GitLab CI/CD
```yaml
deploy:
  stage: deploy
  before_script:
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVER_HOST >> ~/.ssh/known_hosts
  script:
    - ssh $SERVER_USER@$SERVER_HOST "
        docker pull $CI_REGISTRY_IMAGE:latest &&
        docker stop app || true &&
        docker run -d --name app $CI_REGISTRY_IMAGE:latest
      "
  only:
    - main
```

**GitLab Variables to Set**:
- `SSH_PRIVATE_KEY` (Type: File, Protected, Masked)
- `SERVER_HOST`
- `SERVER_USER`

### GitHub Actions
```yaml
deploy:
  runs-on: ubuntu-latest
  if: github.ref == 'refs/heads/main'
  steps:
    - uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          docker pull ghcr.io/${{ github.repository }}:latest
          docker stop app || true
          docker run -d --name app ghcr.io/${{ github.repository }}:latest
```

**GitHub Secrets to Set**:
- `SSH_PRIVATE_KEY`
- `SERVER_HOST`
- `SERVER_USERNAME`

## Docker Build & Push Comparison

### GitLab CI/CD
```yaml
docker-build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
```

**No extra variables needed** - GitLab provides `$CI_REGISTRY_*` automatically

### GitHub Actions
```yaml
docker-build:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4

    - uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ghcr.io/${{ github.repository }}:${{ github.sha }}
          ghcr.io/${{ github.repository }}:latest
```

**No extra secrets needed** - GitHub provides `GITHUB_TOKEN` automatically

## Environment-Specific Deployment

### GitLab CI/CD
```yaml
deploy_staging:
  stage: deploy
  script:
    - echo "Deploying to staging"
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

deploy_production:
  stage: deploy
  script:
    - echo "Deploying to production"
  environment:
    name: production
    url: https://example.com
  only:
    - main
  when: manual
```

### GitHub Actions
```yaml
deploy-staging:
  if: github.ref == 'refs/heads/develop'
  environment:
    name: staging
    url: https://staging.example.com
  runs-on: ubuntu-latest
  steps:
    - run: echo "Deploying to staging"

deploy-production:
  if: github.ref == 'refs/heads/main'
  environment:
    name: production
    url: https://example.com
  runs-on: ubuntu-latest
  steps:
    - run: echo "Deploying to production"
```

**Environment Protection Rules** (Settings > Environments):
- Required reviewers (similar to `when: manual`)
- Wait timer
- Deployment branches

## Conditional Execution

### GitLab CI/CD
```yaml
job:
  script:
    - echo "Running"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - changes:
        - src/**/*
  # OR using legacy syntax
  only:
    - main
    - merge_requests
  except:
    - tags
```

### GitHub Actions
```yaml
job:
  if: |
    github.ref == 'refs/heads/main' ||
    github.event_name == 'pull_request'
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4
    - run: echo "Running"
```

For path filtering:
```yaml
on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
```

## Matrix Builds

### GitLab CI/CD
```yaml
test:
  parallel:
    matrix:
      - DOTNET_VERSION: ['8.0', '9.0', '10.0']
  script:
    - dotnet test --framework net$DOTNET_VERSION
```

### GitHub Actions
```yaml
test:
  strategy:
    matrix:
      dotnet-version: ['8.0', '9.0', '10.0']
  runs-on: ubuntu-latest
  steps:
    - uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
    - run: dotnet test
```

## Migration Checklist

- [ ] Move `.gitlab-ci.yml` logic to `.github/workflows/`
- [ ] Convert GitLab variables to GitHub secrets
- [ ] Update `$CI_*` variables to `${{ github.* }}`
- [ ] Change `script:` to `steps:` with `run:`
- [ ] Convert `only:`/`except:` to `if:` conditions
- [ ] Replace `extends:` with reusable workflows if needed
- [ ] Update Docker registry from GitLab to GitHub (`ghcr.io`)
- [ ] Configure environment protection rules
- [ ] Set up branch protection rules
- [ ] Test SSH access from GitHub Actions runners
- [ ] Update documentation with new workflow triggers

## Quick Reference Card

```
# Access secrets
GitLab:  $MY_SECRET  or  ${{ env.MY_SECRET }}
GitHub:  ${{ secrets.MY_SECRET }}

# Access commit SHA
GitLab:  $CI_COMMIT_SHA
GitHub:  ${{ github.sha }}

# Access branch name
GitLab:  $CI_COMMIT_REF_NAME
GitHub:  ${{ github.ref_name }}

# Run on specific branch
GitLab:  only: [ main ]
GitHub:  if: github.ref == 'refs/heads/main'

# Manual trigger
GitLab:  when: manual
GitHub:  workflow_dispatch (in 'on:' section)

# Job dependencies
GitLab:  stage: deploy (stages run in order)
GitHub:  needs: [build, test]

# Docker registry
GitLab:  $CI_REGISTRY/group/project
GitHub:  ghcr.io/username/repository
```
</file>

<file path=".github/MULTI_PLATFORM_BUILD.md">
# Multi-Platform Docker Builds

## The Problem

You encountered this error:
```
no matching manifest for linux/arm64/v8 in the manifest list entries
```

This means your Docker image was built for **AMD64 (x86_64)** architecture, but your server runs on **ARM64** architecture.

## Architecture Types

- **AMD64 (x86_64)**: Standard Intel/AMD processors (most cloud servers, desktops, laptops)
- **ARM64 (aarch64)**: ARM-based processors (Raspberry Pi, Apple Silicon M1/M2, AWS Graviton, Oracle ARM instances)

## How to Check Your Server Architecture

SSH into your server and run:
```bash
uname -m
```

Output examples:
- `x86_64` = AMD64 architecture
- `aarch64` or `arm64` = ARM64 architecture

Or check with:
```bash
dpkg --print-architecture
```

## The Solution

Build Docker images for **multiple platforms** so they work on any server type.

### What Changed in the Workflow

In `.github/workflows/main.yml`, I added the `platforms` parameter:

```yaml
- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    context: .
    file: ./src/DnDMapBuilder.Api/Dockerfile
    platforms: linux/amd64,linux/arm64  # ← Added this line
    push: true
    tags: ${{ steps.meta.outputs.tags }}
    labels: ${{ steps.meta.outputs.labels }}
```

This tells Docker to build images for both:
- `linux/amd64` - Standard x86_64 servers
- `linux/arm64` - ARM-based servers

## How Multi-Platform Images Work

1. **Build Time**: GitHub Actions builds the image twice (once for each architecture)
2. **Push Time**: Both images are pushed to the registry with the same tag
3. **Pull Time**: Docker automatically selects the correct architecture for your server

When you run `docker pull ghcr.io/mikedeik/dndmapbuilder-api:latest`, Docker will:
- Pull the ARM64 version on ARM servers
- Pull the AMD64 version on x86_64 servers

## Verifying Multi-Platform Support

After the next build, check your image on GitHub Container Registry:

1. Go to: https://github.com/users/mikedeik/packages/container/dndmapbuilder-api
2. Click on a tag (e.g., `latest`)
3. Look for "OS/Arch" - you should see both:
   - `linux/amd64`
   - `linux/arm64`

Or check via CLI:
```bash
docker manifest inspect ghcr.io/mikedeik/dndmapbuilder-api:latest
```

You should see two manifests listed.

## Build Time Impact

Multi-platform builds take longer because:
- Each platform is built separately
- ARM builds on AMD64 runners use QEMU emulation (slower)

Typical build times:
- Single platform (amd64): 2-5 minutes
- Multi-platform (amd64 + arm64): 5-15 minutes

## Optimizations

### Option 1: Build Only for Your Server Architecture

If you only deploy to ARM64 servers, change to:
```yaml
platforms: linux/arm64
```

If you only deploy to AMD64 servers, change to:
```yaml
platforms: linux/amd64
```

Or remove the `platforms` line entirely (defaults to AMD64).

### Option 2: Use Native Runners

For faster ARM64 builds, use native ARM64 runners:
```yaml
build-docker:
  strategy:
    matrix:
      include:
        - platform: linux/amd64
          runner: ubuntu-latest
        - platform: linux/arm64
          runner: ubuntu-24.04-arm  # GitHub's ARM runners
```

Note: GitHub's ARM runners are currently in beta and may require a paid plan.

### Option 3: Conditional Builds

Build for multiple platforms only on releases:
```yaml
- name: Set platforms
  id: platforms
  run: |
    if [[ "${{ github.ref }}" == "refs/tags/v"* ]]; then
      echo "platforms=linux/amd64,linux/arm64" >> $GITHUB_OUTPUT
    else
      echo "platforms=linux/amd64" >> $GITHUB_OUTPUT
    fi

- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    platforms: ${{ steps.platforms.outputs.platforms }}
    # ... rest of config
```

## Troubleshooting

### Build fails with "exec format error"

This means you're trying to run an image built for a different architecture. Solution:
- Ensure multi-platform build is enabled
- Pull the latest image after the new build completes

### "Cannot connect to Docker daemon during build"

QEMU might not be set up properly. The workflow already includes `docker/setup-buildx-action@v3` which handles this automatically.

### Slow builds

ARM64 builds on AMD64 runners are slow due to QEMU emulation. This is normal. Consider:
- Building only for your target architecture
- Using native ARM runners (if available)
- Caching layers aggressively

## Common Server Types

| Provider | Service | Architecture |
|----------|---------|--------------|
| AWS | EC2 (t3, m5, c5) | AMD64 |
| AWS | EC2 (t4g, m6g, c6g) Graviton | ARM64 |
| DigitalOcean | Standard Droplets | AMD64 |
| Oracle Cloud | VM.Standard.E2.1.Micro (Free Tier) | AMD64 |
| Oracle Cloud | VM.Standard.A1.Flex (Free Tier) | ARM64 |
| Raspberry Pi | All models | ARM64 |
| Apple Silicon | M1/M2 Macs | ARM64 |
| Google Cloud | N1, N2, E2 | AMD64 |
| Google Cloud | T2A (Tau) | ARM64 |

## Next Steps

1. Commit and push the updated workflow
2. Let the build complete (will take longer this time)
3. Retry deployment - it should now work on your ARM64 server
</file>

<file path="scripts/run-migrations.sh">
#!/bin/bash

# Database Migration Script
# This script runs database migrations as part of the deployment pipeline.
# Can be executed from CI/CD pipelines or manually for maintenance.

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
DOTNET_VERSION=${DOTNET_VERSION:-"10.0"}
PROJECT_PATH=${PROJECT_PATH:-"src/DnDMapBuilder.Api"}
CONNECTION_STRING=${ConnectionStrings__DefaultConnection}
MIGRATION_TIMEOUT=${MIGRATION_TIMEOUT:-120}

# Helper functions
print_info() {
    echo -e "${BLUE}ℹ ${1}${NC}"
}

print_success() {
    echo -e "${GREEN}✓ ${1}${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ ${1}${NC}"
}

print_error() {
    echo -e "${RED}✗ ${1}${NC}"
}

# Verify environment
print_info "Verifying environment..."

if [ -z "$CONNECTION_STRING" ]; then
    print_error "ConnectionStrings__DefaultConnection environment variable is not set"
    exit 1
fi

if [ ! -f "$PROJECT_PATH/$PROJECT_PATH.csproj" ] && [ ! -f "src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj" ]; then
    print_error "Project file not found"
    exit 1
fi

print_success "Environment verified"

# Check if .NET is available
print_info "Checking .NET version..."
if ! command -v dotnet &> /dev/null; then
    print_error ".NET CLI is not installed"
    exit 1
fi

INSTALLED_VERSION=$(dotnet --version)
print_success ".NET $INSTALLED_VERSION is installed"

# Run migrations
print_info "Running database migrations..."
print_info "Connection String: ${CONNECTION_STRING:0:50}..."

cd "$(dirname "$0")/.."

# Use timeout to prevent hanging if migration takes too long
timeout $MIGRATION_TIMEOUT dotnet ef database update \
    --project src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj \
    --startup-project src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj \
    --context DnDMapBuilderDbContext \
    --verbose \
    || {
        MIGRATION_RESULT=$?
        if [ $MIGRATION_RESULT -eq 124 ]; then
            print_error "Migration timeout after ${MIGRATION_TIMEOUT} seconds"
            exit 1
        else
            print_error "Migration failed with exit code $MIGRATION_RESULT"
            exit 1
        fi
    }

print_success "Database migrations completed successfully"

# Verify database connectivity
print_info "Verifying database connectivity..."

# Extract server and database from connection string
SERVER=$(echo "$CONNECTION_STRING" | grep -oP 'Server=\K[^;]+')
DATABASE=$(echo "$CONNECTION_STRING" | grep -oP 'Database=\K[^;]+')

print_info "Server: $SERVER"
print_info "Database: $DATABASE"

# If using SQL Server, verify with sqlcmd
if command -v sqlcmd &> /dev/null; then
    print_info "Verifying database with sqlcmd..."

    if sqlcmd -S "$SERVER" -d "$DATABASE" -Q "SELECT DB_NAME();" &>/dev/null; then
        print_success "Database connectivity verified"
    else
        print_warning "Could not verify database with sqlcmd (this might be normal if not using SQL Server)"
    fi
else
    print_warning "sqlcmd not available, skipping verification"
fi

print_success "Migration process completed successfully"
exit 0
</file>

<file path="src/DnDMapBuilder.Api/GlobalSuppressions.cs">
// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Style", "NU1510:PackageReference will not be pruned",
    Justification = "Microsoft.AspNetCore.RateLimiting is used in Program.cs for rate limiting configuration")]
</file>

<file path="src/DnDMapBuilder.AppHost/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Aspire.Hosting.Dcp": "Warning"
    }
  }
}
</file>

<file path="src/DnDMapBuilder.AppHost/DnDMapBuilder.AppHost.csproj">
<Project Sdk="Aspire.AppHost.Sdk/13.1.0">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net10.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <UserSecretsId>341d30cb-17ac-469c-8407-79b6afe8eb3b</UserSecretsId>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Aspire.Hosting.SqlServer" Version="13.1.0" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Application/Common/Result.cs">
namespace DnDMapBuilder.Application.Common;

/// <summary>
/// Represents the result of an operation that returns no data, indicating success or failure.
/// </summary>
public class Result
{
    /// <summary>
    /// Gets a value indicating whether the operation was successful.
    /// </summary>
    public bool IsSuccess { get; }

    /// <summary>
    /// Gets the error message if operation failed.
    /// </summary>
    public string? Error { get; }

    /// <summary>
    /// Gets the list of errors if operation failed.
    /// </summary>
    public IReadOnlyList<string> Errors { get; }

    private Result(bool isSuccess, string? error, IReadOnlyList<string>? errors)
    {
        IsSuccess = isSuccess;
        Error = error;
        Errors = errors ?? new List<string>();
    }

    /// <summary>
    /// Creates a successful result.
    /// </summary>
    /// <returns>A successful Result</returns>
    public static Result Success()
    {
        return new Result(true, null, null);
    }

    /// <summary>
    /// Creates a failed result with a single error message.
    /// </summary>
    /// <param name="error">The error message</param>
    /// <returns>A failed Result</returns>
    public static Result Failure(string error)
    {
        return new Result(false, error, new[] { error });
    }

    /// <summary>
    /// Creates a failed result with multiple error messages.
    /// </summary>
    /// <param name="errors">The list of error messages</param>
    /// <returns>A failed Result</returns>
    public static Result Failure(IEnumerable<string> errors)
    {
        var errorList = errors.ToList();
        return new Result(false, errorList.FirstOrDefault(), errorList);
    }
}

/// <summary>
/// Represents the result of an operation that returns data, indicating success or failure.
/// </summary>
/// <typeparam name="T">The type of data returned on success</typeparam>
public class Result<T>
{
    /// <summary>
    /// Gets a value indicating whether the operation was successful.
    /// </summary>
    public bool IsSuccess { get; }

    /// <summary>
    /// Gets the data returned by the operation (null if failed).
    /// </summary>
    public T? Data { get; }

    /// <summary>
    /// Gets the error message if operation failed.
    /// </summary>
    public string? Error { get; }

    /// <summary>
    /// Gets the list of errors if operation failed.
    /// </summary>
    public IReadOnlyList<string> Errors { get; }

    private Result(bool isSuccess, T? data, string? error, IReadOnlyList<string>? errors)
    {
        IsSuccess = isSuccess;
        Data = data;
        Error = error;
        Errors = errors ?? new List<string>();
    }

    /// <summary>
    /// Creates a successful result with data.
    /// </summary>
    /// <param name="data">The data to return</param>
    /// <returns>A successful Result<T></returns>
    public static Result<T> Success(T data)
    {
        return new Result<T>(true, data, null, null);
    }

    /// <summary>
    /// Creates a failed result with a single error message.
    /// </summary>
    /// <param name="error">The error message</param>
    /// <returns>A failed Result<T></returns>
    public static Result<T> Failure(string error)
    {
        return new Result<T>(false, default, error, new[] { error });
    }

    /// <summary>
    /// Creates a failed result with multiple error messages.
    /// </summary>
    /// <param name="errors">The list of error messages</param>
    /// <returns>A failed Result<T></returns>
    public static Result<T> Failure(IEnumerable<string> errors)
    {
        var errorList = errors.ToList();
        return new Result<T>(false, default, errorList.FirstOrDefault(), errorList);
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/ICampaignService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;

namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for campaign business logic operations.
/// </summary>
public interface ICampaignService
{
    /// <summary>
    /// Gets a campaign by ID with authorization check.
    /// </summary>
    /// <param name="id">The campaign ID</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The campaign DTO or null if not found or not authorized</returns>
    Task<CampaignDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all campaigns owned by the specified user.
    /// </summary>
    /// <param name="userId">The owner's user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of campaign DTOs owned by the user</returns>
    Task<IEnumerable<CampaignDto>> GetUserCampaignsAsync(string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Creates a new campaign for the specified user.
    /// </summary>
    /// <param name="request">Campaign creation request</param>
    /// <param name="userId">The user ID who will own the campaign</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created campaign DTO</returns>
    Task<CampaignDto> CreateAsync(CreateCampaignRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing campaign with authorization check.
    /// </summary>
    /// <param name="id">The campaign ID to update</param>
    /// <param name="request">Campaign update request</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated campaign DTO or null if not found or not authorized</returns>
    Task<CampaignDto?> UpdateAsync(string id, UpdateCampaignRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a campaign with authorization check.
    /// </summary>
    /// <param name="id">The campaign ID to delete</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if deleted successfully, false if not found or not authorized</returns>
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IFileStorageService.cs">
namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for file storage operations.
/// </summary>
public interface IFileStorageService
{
    /// <summary>
    /// Uploads a file to storage and returns the file ID for database reference.
    /// </summary>
    /// <param name="file">The file stream to upload</param>
    /// <param name="fileName">Original file name</param>
    /// <param name="contentType">MIME type of the file</param>
    /// <param name="storageCategory">Category for organization (e.g., "maps", "tokens")</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Generated file ID</returns>
    Task<string> UploadAsync(Stream file, string fileName, string contentType, string storageCategory, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the public URL for a stored file.
    /// </summary>
    /// <param name="fileId">The file ID returned from upload</param>
    /// <param name="storageCategory">The category where the file is stored</param>
    /// <returns>Public URL to the file</returns>
    string GetPublicUrl(string fileId, string storageCategory);

    /// <summary>
    /// Deletes a file from storage.
    /// </summary>
    /// <param name="fileId">The file ID to delete</param>
    /// <param name="storageCategory">The category where the file is stored</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if deleted successfully</returns>
    Task<bool> DeleteAsync(string fileId, string storageCategory, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IFileValidationService.cs">
namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service for validating file uploads.
/// </summary>
public interface IFileValidationService
{
    /// <summary>
    /// Validates a file's size and type.
    /// </summary>
    /// <param name="fileName">The file name</param>
    /// <param name="fileSize">The file size in bytes</param>
    /// <param name="contentType">The MIME type of the file</param>
    /// <param name="storageCategory">The storage category (e.g., "maps", "tokens")</param>
    /// <returns>Validation result with any error messages</returns>
    FileValidationResult ValidateFile(string fileName, long fileSize, string contentType, string storageCategory);

    /// <summary>
    /// Gets the maximum allowed file size for a storage category.
    /// </summary>
    /// <param name="storageCategory">The storage category</param>
    /// <returns>Maximum file size in bytes</returns>
    long GetMaxFileSizeForCategory(string storageCategory);

    /// <summary>
    /// Gets the allowed MIME types for a storage category.
    /// </summary>
    /// <param name="storageCategory">The storage category</param>
    /// <returns>Array of allowed MIME types</returns>
    string[] GetAllowedMimeTypesForCategory(string storageCategory);
}

/// <summary>
/// Result of file validation.
/// </summary>
public class FileValidationResult
{
    /// <summary>
    /// Initializes a new instance of the FileValidationResult class with success.
    /// </summary>
    public FileValidationResult()
    {
        IsValid = true;
        Errors = new List<string>();
    }

    /// <summary>
    /// Initializes a new instance of the FileValidationResult class with an error.
    /// </summary>
    /// <param name="error">The validation error message</param>
    public FileValidationResult(string error) : this(new[] { error })
    {
    }

    /// <summary>
    /// Initializes a new instance of the FileValidationResult class with errors.
    /// </summary>
    /// <param name="errors">The validation error messages</param>
    public FileValidationResult(string[] errors)
    {
        IsValid = false;
        Errors = new List<string>(errors);
    }

    /// <summary>
    /// Gets a value indicating whether the file passed validation.
    /// </summary>
    public bool IsValid { get; }

    /// <summary>
    /// Gets the validation error messages.
    /// </summary>
    public List<string> Errors { get; }
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IGameMapService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;

namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for game map business logic operations.
/// </summary>
public interface IGameMapService
{
    /// <summary>
    /// Gets a game map by ID with authorization check.
    /// </summary>
    /// <param name="id">The game map ID</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The game map DTO or null if not found or not authorized</returns>
    Task<GameMapDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all game maps for a specific mission with authorization check.
    /// </summary>
    /// <param name="missionId">The mission ID</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of game map DTOs in the mission</returns>
    Task<IEnumerable<GameMapDto>> GetByMissionIdAsync(string missionId, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Creates a new game map in the specified mission.
    /// </summary>
    /// <param name="request">Map creation request</param>
    /// <param name="userId">The user ID making the request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created game map DTO</returns>
    Task<GameMapDto> CreateAsync(CreateMapRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing game map with authorization check.
    /// </summary>
    /// <param name="id">The game map ID to update</param>
    /// <param name="request">Map update request</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated game map DTO or null if not found or not authorized</returns>
    Task<GameMapDto?> UpdateAsync(string id, UpdateMapRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a game map with authorization check.
    /// </summary>
    /// <param name="id">The game map ID to delete</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if deleted successfully, false if not found or not authorized</returns>
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IJwtService.cs">
namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for JWT token generation and validation.
/// </summary>
public interface IJwtService
{
    /// <summary>
    /// Generates a JWT token for the specified user.
    /// </summary>
    /// <param name="userId">The user ID to include in the token</param>
    /// <param name="email">The user's email to include in the token</param>
    /// <param name="role">The user's role to include in the token</param>
    /// <returns>The generated JWT token</returns>
    string GenerateToken(string userId, string email, string role);

    /// <summary>
    /// Validates a JWT token and returns the user ID if valid.
    /// </summary>
    /// <param name="token">The JWT token to validate</param>
    /// <returns>The user ID if token is valid, null if invalid or expired</returns>
    string? ValidateToken(string token);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IMissionService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;

namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for mission business logic operations.
/// </summary>
public interface IMissionService
{
    /// <summary>
    /// Gets a mission by ID with authorization check.
    /// </summary>
    /// <param name="id">The mission ID</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The mission DTO or null if not found or not authorized</returns>
    Task<MissionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all missions for a specific campaign with authorization check.
    /// </summary>
    /// <param name="campaignId">The campaign ID</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of mission DTOs in the campaign</returns>
    Task<IEnumerable<MissionDto>> GetByCampaignIdAsync(string campaignId, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Creates a new mission in the specified campaign.
    /// </summary>
    /// <param name="request">Mission creation request</param>
    /// <param name="userId">The user ID making the request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created mission DTO</returns>
    Task<MissionDto> CreateAsync(CreateMissionRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing mission with authorization check.
    /// </summary>
    /// <param name="id">The mission ID to update</param>
    /// <param name="request">Mission update request</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated mission DTO or null if not found or not authorized</returns>
    Task<MissionDto?> UpdateAsync(string id, UpdateMissionRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a mission with authorization check.
    /// </summary>
    /// <param name="id">The mission ID to delete</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if deleted successfully, false if not found or not authorized</returns>
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IPasswordService.cs">
namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for password hashing and verification operations.
/// </summary>
public interface IPasswordService
{
    /// <summary>
    /// Hashes a plain text password using BCrypt.
    /// </summary>
    /// <param name="password">The plain text password to hash</param>
    /// <returns>The hashed password</returns>
    string HashPassword(string password);

    /// <summary>
    /// Verifies a plain text password against a hash.
    /// </summary>
    /// <param name="password">The plain text password to verify</param>
    /// <param name="hash">The hashed password to compare against</param>
    /// <returns>True if password matches hash, false otherwise</returns>
    bool VerifyPassword(string password, string hash);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/ITokenDefinitionService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;

namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for token definition business logic operations.
/// </summary>
public interface ITokenDefinitionService
{
    /// <summary>
    /// Gets a token definition by ID with authorization check.
    /// </summary>
    /// <param name="id">The token definition ID</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The token definition DTO or null if not found or not authorized</returns>
    Task<TokenDefinitionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all token definitions for a specific user.
    /// </summary>
    /// <param name="userId">The user ID owner of the tokens</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of token definition DTOs owned by the user</returns>
    Task<IEnumerable<TokenDefinitionDto>> GetUserTokensAsync(string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Creates a new token definition for the specified user.
    /// </summary>
    /// <param name="request">Token definition creation request</param>
    /// <param name="userId">The user ID who will own the token</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created token definition DTO</returns>
    Task<TokenDefinitionDto> CreateAsync(CreateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing token definition with authorization check.
    /// </summary>
    /// <param name="id">The token definition ID to update</param>
    /// <param name="request">Token definition update request</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated token definition DTO or null if not found or not authorized</returns>
    Task<TokenDefinitionDto?> UpdateAsync(string id, UpdateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a token definition with authorization check.
    /// </summary>
    /// <param name="id">The token definition ID to delete</param>
    /// <param name="userId">The user ID making the request (for authorization)</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if deleted successfully, false if not found or not authorized</returns>
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IUserManagementService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;

namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for user management operations (registration, approval, profile management).
/// </summary>
public interface IUserManagementService
{
    /// <summary>
    /// Registers a new user with the provided credentials.
    /// </summary>
    /// <param name="request">Registration request with username, email, and password</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created user DTO or null if registration fails</returns>
    Task<UserDto?> RegisterAsync(RegisterRequest request, CancellationToken cancellationToken = default);

    /// <summary>
    /// Approves or rejects a pending user registration.
    /// </summary>
    /// <param name="userId">The user ID to approve/reject</param>
    /// <param name="approved">True to approve, false to reject</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if approval succeeded, false otherwise</returns>
    Task<bool> ApproveUserAsync(string userId, bool approved, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all users with pending registration status.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of pending users</returns>
    Task<IEnumerable<UserDto>> GetPendingUsersAsync(CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Services/FileValidationService.cs">
using DnDMapBuilder.Application.Interfaces;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for validating file uploads with size and type restrictions.
/// </summary>
public class FileValidationService : IFileValidationService
{
    private static readonly Dictionary<string, (long MaxSize, string[] AllowedMimeTypes)> CategoryConfig =
        new()
        {
            {
                "maps",
                (
                    MaxSize: 5 * 1024 * 1024, // 5MB
                    AllowedMimeTypes: new[] { "image/png", "image/jpeg", "image/webp" }
                )
            },
            {
                "tokens",
                (
                    MaxSize: 2 * 1024 * 1024, // 2MB
                    AllowedMimeTypes: new[] { "image/png", "image/jpeg", "image/webp" }
                )
            },
            {
                "default",
                (
                    MaxSize: 10 * 1024 * 1024, // 10MB
                    AllowedMimeTypes: new[] { "application/octet-stream" }
                )
            }
        };

    /// <summary>
    /// Validates a file's size and type.
    /// </summary>
    public FileValidationResult ValidateFile(string fileName, long fileSize, string contentType, string storageCategory)
    {
        var errors = new List<string>();

        // Validate file name
        if (string.IsNullOrWhiteSpace(fileName))
        {
            errors.Add("File name cannot be empty.");
            return new FileValidationResult(errors.ToArray());
        }

        // Validate file size
        var maxSize = GetMaxFileSizeForCategory(storageCategory);
        if (fileSize == 0)
        {
            errors.Add("File cannot be empty.");
        }
        else if (fileSize > maxSize)
        {
            errors.Add($"File size exceeds the maximum limit of {maxSize / (1024 * 1024)}MB for {storageCategory}.");
        }

        // Validate MIME type
        var allowedMimeTypes = GetAllowedMimeTypesForCategory(storageCategory);
        var normalizedContentType = (contentType ?? "").ToLowerInvariant();
        if (!allowedMimeTypes.Contains(normalizedContentType))
        {
            var supportedTypes = string.Join(", ", allowedMimeTypes);
            errors.Add($"File type '{normalizedContentType}' is not allowed. Supported types: {supportedTypes}");
        }

        return errors.Count > 0 ? new FileValidationResult(errors.ToArray()) : new FileValidationResult();
    }

    /// <summary>
    /// Gets the maximum allowed file size for a storage category.
    /// </summary>
    public long GetMaxFileSizeForCategory(string storageCategory)
    {
        var category = (storageCategory ?? "default").ToLowerInvariant();
        return CategoryConfig.ContainsKey(category) ? CategoryConfig[category].MaxSize : CategoryConfig["default"].MaxSize;
    }

    /// <summary>
    /// Gets the allowed MIME types for a storage category.
    /// </summary>
    public string[] GetAllowedMimeTypesForCategory(string storageCategory)
    {
        var category = (storageCategory ?? "default").ToLowerInvariant();
        return CategoryConfig.ContainsKey(category) ? CategoryConfig[category].AllowedMimeTypes : CategoryConfig["default"].AllowedMimeTypes;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/GameMapService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for GameMap business logic and CRUD operations.
/// </summary>
public class GameMapService : IGameMapService
{
    private readonly IGameMapRepository _mapRepository;
    private readonly IMissionRepository _missionRepository;
    private readonly ICampaignRepository _campaignRepository;
    private readonly IMapTokenInstanceRepository _tokenInstanceRepository;

    public GameMapService(
        IGameMapRepository mapRepository,
        IMissionRepository missionRepository,
        ICampaignRepository campaignRepository,
        IMapTokenInstanceRepository tokenInstanceRepository)
    {
        _mapRepository = mapRepository;
        _missionRepository = missionRepository;
        _campaignRepository = campaignRepository;
        _tokenInstanceRepository = tokenInstanceRepository;
    }

    /// <summary>
    /// Gets a GameMap by ID if user has access.
    /// </summary>
    /// <param name="id">The GameMap ID</param>
    /// <param name="userId">The requesting user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The GameMap DTO or null if not found or user has no access</returns>
    public async Task<GameMapDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var map = await _mapRepository.GetWithTokensAsync(id, cancellationToken);
        if (map == null)
        {
            return null;
        }

        if (!await HasAccessToMapAsync(map.MissionId, userId, cancellationToken))
        {
            return null;
        }

        return map.ToDto();
    }

    /// <summary>
    /// Gets all GameMaps for a specific mission.
    /// </summary>
    /// <param name="missionId">The mission ID</param>
    /// <param name="userId">The requesting user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of GameMap DTOs</returns>
    public async Task<IEnumerable<GameMapDto>> GetByMissionIdAsync(string missionId, string userId, CancellationToken cancellationToken = default)
    {
        if (!await HasAccessToMapAsync(missionId, userId, cancellationToken))
        {
            return Enumerable.Empty<GameMapDto>();
        }

        var maps = await _mapRepository.GetByMissionIdAsync(missionId, cancellationToken);
        return maps.Select(m => m.ToDto());
    }

    /// <summary>
    /// Creates a new GameMap.
    /// </summary>
    /// <param name="request">Create map request</param>
    /// <param name="userId">The requesting user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created GameMap DTO</returns>
    /// <exception cref="UnauthorizedAccessException">Thrown when user doesn't have permission</exception>
    public async Task<GameMapDto> CreateAsync(CreateMapRequest request, string userId, CancellationToken cancellationToken = default)
    {
        if (!await HasAccessToMapAsync(request.MissionId, userId, cancellationToken))
        {
            throw new UnauthorizedAccessException("You don't have permission to add maps to this mission.");
        }

        var map = new GameMap
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            ImageUrl = request.ImageUrl,
            Rows = request.Rows,
            Cols = request.Cols,
            GridColor = request.GridColor,
            GridOpacity = request.GridOpacity,
            MissionId = request.MissionId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _mapRepository.AddAsync(map, cancellationToken);
        return map.ToDto();
    }

    /// <summary>
    /// Updates an existing GameMap.
    /// </summary>
    /// <param name="id">The GameMap ID to update</param>
    /// <param name="request">Update map request</param>
    /// <param name="userId">The requesting user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated GameMap DTO or null if not found</returns>
    public async Task<GameMapDto?> UpdateAsync(string id, UpdateMapRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var map = await _mapRepository.GetByIdAsync(id, cancellationToken);
        if (map == null)
        {
            return null;
        }

        if (!await HasAccessToMapAsync(map.MissionId, userId, cancellationToken))
        {
            return null;
        }

        map.Name = request.Name;
        map.ImageUrl = request.ImageUrl;
        map.Rows = request.Rows;
        map.Cols = request.Cols;
        map.GridColor = request.GridColor;
        map.GridOpacity = request.GridOpacity;
        map.UpdatedAt = DateTime.UtcNow;

        // Update tokens
        await _tokenInstanceRepository.DeleteByMapIdAsync(map.Id, cancellationToken);

        foreach (var tokenReq in request.Tokens)
        {
            var tokenInstance = new MapTokenInstance
            {
                Id = Guid.NewGuid().ToString(),
                TokenId = tokenReq.TokenId,
                MapId = map.Id,
                X = tokenReq.X,
                Y = tokenReq.Y,
                CreatedAt = DateTime.UtcNow
            };
            await _tokenInstanceRepository.AddAsync(tokenInstance, cancellationToken);
        }

        await _mapRepository.UpdateAsync(map, cancellationToken);

        var updatedMap = await _mapRepository.GetWithTokensAsync(id, cancellationToken);
        return updatedMap?.ToDto();
    }

    /// <summary>
    /// Deletes a GameMap.
    /// </summary>
    /// <param name="id">The GameMap ID to delete</param>
    /// <param name="userId">The requesting user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if deletion succeeded, false otherwise</returns>
    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var map = await _mapRepository.GetByIdAsync(id, cancellationToken);
        if (map == null)
        {
            return false;
        }

        if (!await HasAccessToMapAsync(map.MissionId, userId, cancellationToken))
        {
            return false;
        }

        await _mapRepository.DeleteAsync(id, cancellationToken);
        return true;
    }

    /// <summary>
    /// Checks if user has access to a map via mission and campaign ownership.
    /// </summary>
    private async Task<bool> HasAccessToMapAsync(string missionId, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetByIdAsync(missionId, cancellationToken);
        if (mission == null)
        {
            return false;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        return campaign != null && campaign.OwnerId == userId;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/JwtService.cs">
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;
using DnDMapBuilder.Application.Interfaces;

namespace DnDMapBuilder.Application.Services;

public class JwtService : IJwtService
{
    private readonly string _secret;
    private readonly string _issuer;
    private readonly string _audience;
    private readonly int _expirationMinutes;

    public JwtService(string secret, string issuer, string audience, int expirationMinutes = 1440)
    {
        _secret = secret;
        _issuer = issuer;
        _audience = audience;
        _expirationMinutes = expirationMinutes;
    }

    public string GenerateToken(string userId, string email, string role)
    {
        var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_secret));
        var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId),
            new Claim(JwtRegisteredClaimNames.Email, email),
            new Claim(ClaimTypes.Role, role),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var token = new JwtSecurityToken(
            issuer: _issuer,
            audience: _audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_expirationMinutes),
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    public string? ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_secret);

        try
        {
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = _issuer,
                ValidateAudience = true,
                ValidAudience = _audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };

            var principal = tokenHandler.ValidateToken(token, validationParameters, out var validatedToken);
            var jwtToken = (JwtSecurityToken)validatedToken;
            var userId = jwtToken.Claims.First(x => x.Type == JwtRegisteredClaimNames.Sub).Value;

            return userId;
        }
        catch
        {
            return null;
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/PasswordService.cs">
using DnDMapBuilder.Application.Interfaces;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for password hashing and verification operations using BCrypt.
/// </summary>
public class PasswordService : IPasswordService
{
    /// <summary>
    /// Hashes a plain text password using BCrypt.
    /// </summary>
    /// <param name="password">The plain text password to hash</param>
    /// <returns>The hashed password</returns>
    public string HashPassword(string password)
    {
        return BCrypt.Net.BCrypt.HashPassword(password);
    }

    /// <summary>
    /// Verifies a plain text password against a hash.
    /// </summary>
    /// <param name="password">The plain text password to verify</param>
    /// <param name="hash">The hashed password to compare against</param>
    /// <returns>True if password matches hash, false otherwise</returns>
    public bool VerifyPassword(string password, string hash)
    {
        return BCrypt.Net.BCrypt.Verify(password, hash);
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/TokenDefinitionService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for TokenDefinition business logic and CRUD operations.
/// </summary>
public class TokenDefinitionService : ITokenDefinitionService
{
    private readonly ITokenDefinitionRepository _tokenRepository;

    public TokenDefinitionService(ITokenDefinitionRepository tokenRepository)
    {
        _tokenRepository = tokenRepository;
    }

    /// <summary>
    /// Gets a TokenDefinition by ID if it belongs to the user.
    /// </summary>
    /// <param name="id">The TokenDefinition ID</param>
    /// <param name="userId">The user ID to verify ownership</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The TokenDefinition DTO or null if not found or not owned by user</returns>
    public async Task<TokenDefinitionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var token = await _tokenRepository.GetByIdAsync(id, cancellationToken);
        if (token == null || token.UserId != userId)
        {
            return null;
        }

        return token.ToDto();
    }

    /// <summary>
    /// Gets all TokenDefinitions created by a user.
    /// </summary>
    /// <param name="userId">The user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of user's TokenDefinition DTOs</returns>
    public async Task<IEnumerable<TokenDefinitionDto>> GetUserTokensAsync(string userId, CancellationToken cancellationToken = default)
    {
        var tokens = await _tokenRepository.GetByUserIdAsync(userId, cancellationToken);
        return tokens.Select(t => t.ToDto());
    }

    /// <summary>
    /// Creates a new TokenDefinition.
    /// </summary>
    /// <param name="request">Create token request</param>
    /// <param name="userId">The user ID creating the token</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created TokenDefinition DTO</returns>
    public async Task<TokenDefinitionDto> CreateAsync(CreateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var token = new TokenDefinition
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            ImageUrl = request.ImageUrl,
            Size = request.Size,
            Type = request.Type,
            UserId = userId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _tokenRepository.AddAsync(token, cancellationToken);
        return token.ToDto();
    }

    /// <summary>
    /// Updates an existing TokenDefinition.
    /// </summary>
    /// <param name="id">The TokenDefinition ID to update</param>
    /// <param name="request">Update token request</param>
    /// <param name="userId">The user ID verifying ownership</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated TokenDefinition DTO or null if not found or not owned by user</returns>
    public async Task<TokenDefinitionDto?> UpdateAsync(string id, UpdateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var token = await _tokenRepository.GetByIdAsync(id, cancellationToken);
        if (token == null || token.UserId != userId)
        {
            return null;
        }

        token.Name = request.Name;
        token.ImageUrl = request.ImageUrl;
        token.Size = request.Size;
        token.Type = request.Type;
        token.UpdatedAt = DateTime.UtcNow;

        await _tokenRepository.UpdateAsync(token, cancellationToken);
        return token.ToDto();
    }

    /// <summary>
    /// Deletes a TokenDefinition.
    /// </summary>
    /// <param name="id">The TokenDefinition ID to delete</param>
    /// <param name="userId">The user ID verifying ownership</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if deletion succeeded, false otherwise</returns>
    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var token = await _tokenRepository.GetByIdAsync(id, cancellationToken);
        if (token == null || token.UserId != userId)
        {
            return false;
        }

        await _tokenRepository.DeleteAsync(id, cancellationToken);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/UserManagementService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for user management operations including registration, approval, and user querying.
/// </summary>
public class UserManagementService : IUserManagementService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;

    public UserManagementService(IUserRepository userRepository, IPasswordService passwordService)
    {
        _userRepository = userRepository;
        _passwordService = passwordService;
    }

    /// <summary>
    /// Registers a new user with the provided credentials.
    /// </summary>
    /// <param name="request">Registration request with username, email, and password</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created user DTO or null if registration fails</returns>
    public async Task<UserDto?> RegisterAsync(RegisterRequest request, CancellationToken cancellationToken = default)
    {
        // Check if user already exists by email
        var existingUser = await _userRepository.GetByEmailAsync(request.Email, cancellationToken);
        if (existingUser != null)
        {
            return null; // User already exists
        }

        // Check if username is already taken
        var existingUsername = await _userRepository.GetByUsernameAsync(request.Username, cancellationToken);
        if (existingUsername != null)
        {
            return null; // Username already taken
        }

        // Create new user with hashed password
        var user = new User
        {
            Id = Guid.NewGuid().ToString(),
            Username = request.Username,
            Email = request.Email,
            PasswordHash = _passwordService.HashPassword(request.Password),
            Role = "user",
            Status = "pending", // Requires admin approval
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _userRepository.AddAsync(user, cancellationToken);

        return user.ToDto();
    }

    /// <summary>
    /// Approves or rejects a pending user registration.
    /// </summary>
    /// <param name="userId">The user ID to approve/reject</param>
    /// <param name="approved">True to approve, false to reject</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if approval succeeded, false otherwise</returns>
    public async Task<bool> ApproveUserAsync(string userId, bool approved, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user == null)
        {
            return false;
        }

        user.Status = approved ? "approved" : "rejected";
        user.UpdatedAt = DateTime.UtcNow;

        await _userRepository.UpdateAsync(user, cancellationToken);
        return true;
    }

    /// <summary>
    /// Gets all users with pending registration status.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of pending users</returns>
    public async Task<IEnumerable<UserDto>> GetPendingUsersAsync(CancellationToken cancellationToken = default)
    {
        var users = await _userRepository.GetPendingUsersAsync(cancellationToken);
        return users.Select(u => u.ToDto());
    }
}
</file>

<file path="src/DnDMapBuilder.ArchitectureTests/ArchitectureTests.cs">
using System.Reflection;
using Xunit;
using DnDMapBuilder.Api.Controllers;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Repositories;

namespace DnDMapBuilder.ArchitectureTests;

/// <summary>
/// Architecture tests to enforce layered architecture and design principles.
/// Ensures no circular dependencies and proper separation of concerns.
/// </summary>
public class ArchitectureTests
{
    private static readonly Assembly ApiAssembly = typeof(AuthController).Assembly;
    private static readonly Assembly ApplicationAssembly = typeof(IAuthService).Assembly;
    private static readonly Assembly DataAssembly = typeof(DnDMapBuilderDbContext).Assembly;

    /// <summary>
    /// All controllers should inherit from ControllerBase.
    /// </summary>
    [Fact]
    public void All_Controllers_ShouldInheritFrom_ControllerBase()
    {
        var controllerTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Api.Controllers") == true &&
                        t.IsClass &&
                        !t.IsAbstract &&
                        !t.IsCompilerGenerated())
            .ToList();

        var invalidControllers = controllerTypes
            .Where(t => !typeof(Microsoft.AspNetCore.Mvc.ControllerBase).IsAssignableFrom(t))
            .ToList();

        Assert.Empty(invalidControllers);
    }

    /// <summary>
    /// All controller names should end with "Controller".
    /// </summary>
    [Fact]
    public void All_Controllers_ShouldHaveName_EndingWith_Controller()
    {
        var controllerTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Api.Controllers") == true &&
                        t.IsClass &&
                        !t.IsAbstract &&
                        !t.IsCompilerGenerated())
            .ToList();

        var invalidControllers = controllerTypes.Where(c => !c.Name.EndsWith("Controller")).ToList();
        Assert.Empty(invalidControllers);
    }

    /// <summary>
    /// Application layer should not reference API layer (no circular dependency).
    /// </summary>
    [Fact]
    public void ApplicationLayer_ShouldNotReference_ApiLayer()
    {
        var appTypes = ApplicationAssembly.GetTypes();
        var apiNamespace = "DnDMapBuilder.Api";

        var appWithApiDeps = appTypes
            .Where(t => t.GetProperties()
                .Any(p => p.PropertyType.Namespace?.StartsWith(apiNamespace) == true) ||
                   t.GetFields()
                .Any(f => f.FieldType.Namespace?.StartsWith(apiNamespace) == true))
            .ToList();

        Assert.Empty(appWithApiDeps);
    }

    /// <summary>
    /// Data layer should not reference Application layer (no circular dependency).
    /// </summary>
    [Fact]
    public void DataLayer_ShouldNotReference_ApplicationLayer()
    {
        var dataTypes = DataAssembly.GetTypes();
        var appNamespace = "DnDMapBuilder.Application";

        var dataWithAppDeps = dataTypes
            .Where(t => t.GetProperties()
                .Any(p => p.PropertyType.Namespace?.StartsWith(appNamespace) == true) ||
                   t.GetFields()
                .Any(f => f.FieldType.Namespace?.StartsWith(appNamespace) == true))
            .ToList();

        Assert.Empty(dataWithAppDeps);
    }

    /// <summary>
    /// All interfaces in Application layer should be implemented by services.
    /// </summary>
    [Fact]
    public void All_ServiceInterfaces_ShouldHaveImplementation()
    {
        var interfaceTypes = ApplicationAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Application.Interfaces") == true &&
                        t.IsInterface)
            .ToList();

        var serviceTypes = ApplicationAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Application.Services") == true &&
                        t.IsClass &&
                        !t.IsAbstract)
            .ToList();

        foreach (var interfaceType in interfaceTypes)
        {
            var implementingService = serviceTypes.FirstOrDefault(s => interfaceType.IsAssignableFrom(s));
            Assert.NotNull(implementingService);
        }
    }

    /// <summary>
    /// All repositories should have names ending with "Repository".
    /// </summary>
    [Fact]
    public void All_Repositories_ShouldHaveName_EndingWith_Repository()
    {
        var repositoryTypes = DataAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Data.Repositories") == true &&
                        t.IsClass &&
                        !t.IsAbstract &&
                        !t.Name.EndsWith("Tests") &&
                        !t.IsCompilerGenerated())
            .ToList();

        // Generic classes like GenericRepository<T> have names like "GenericRepository`1"
        // Remove the generic type parameter indicators for name validation
        var invalidRepos = repositoryTypes.Where(r =>
        {
            var cleanName = r.Name.Split('`')[0]; // Remove generic type parameter count
            return !cleanName.EndsWith("Repository");
        }).ToList();
        Assert.Empty(invalidRepos);
    }

    /// <summary>
    /// Services should not directly depend on DbContext (use repositories instead).
    /// </summary>
    [Fact]
    public void Services_ShouldNotHaveDirect_DbContextDependency()
    {
        var servicesWithDbContext = ApplicationAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Application.Services") == true &&
                        t.IsClass &&
                        !t.IsAbstract)
            .Where(t => t.GetConstructors()
                .SelectMany(c => c.GetParameters())
                .Any(p => p.ParameterType.Name == "DnDMapBuilderDbContext"))
            .ToList();

        // Services should use repositories, not DbContext directly
        Assert.Empty(servicesWithDbContext);
    }

    /// <summary>
    /// Check that data layer doesn't reference API layer directly.
    /// </summary>
    [Fact]
    public void DataLayer_ShouldNotReference_ApiLayer()
    {
        var dataTypes = DataAssembly.GetTypes();
        var apiNamespace = "DnDMapBuilder.Api";

        var dataWithApiDeps = dataTypes
            .Where(t => t.GetProperties()
                .Any(p => p.PropertyType.Namespace?.StartsWith(apiNamespace) == true) ||
                   t.GetFields()
                .Any(f => f.FieldType.Namespace?.StartsWith(apiNamespace) == true))
            .ToList();

        Assert.Empty(dataWithApiDeps);
    }
}

/// <summary>
/// Internal extensions for architecture tests.
/// </summary>
internal static class ArchitectureTestExtensions
{
    public static bool IsCompilerGenerated(this Type type)
    {
        return type.GetCustomAttribute<System.Runtime.CompilerServices.CompilerGeneratedAttribute>() != null;
    }
}
</file>

<file path="src/DnDMapBuilder.Aspire.ServiceDefaults/Extensions.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

namespace Microsoft.Extensions.Hosting;

public static class Extensions
{
    public static IHostApplicationBuilder AddServiceDefaults(this IHostApplicationBuilder builder)
    {
        builder.ConfigureOpenTelemetry();

        builder.AddDefaultHealthChecks();

        builder.Services.AddServiceDiscovery();

        builder.Services.ConfigureHttpClientDefaults(http =>
        {
            http.AddStandardResilienceHandler();
            http.AddServiceDiscovery();
        });

        return builder;
    }

    public static IHostApplicationBuilder ConfigureOpenTelemetry(this IHostApplicationBuilder builder)
    {
        builder.Logging.AddOpenTelemetry(logging =>
        {
            logging.IncludeFormattedMessage = true;
            logging.IncludeScopes = true;
        });

        builder.Services.AddOpenTelemetry()
            .WithMetrics(metrics =>
            {
                metrics.AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation()
                    .AddRuntimeInstrumentation();
            })
            .WithTracing(tracing =>
            {
                tracing.AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation();
            });

        builder.AddOpenTelemetryExporters();

        return builder;
    }

    private static IHostApplicationBuilder AddOpenTelemetryExporters(this IHostApplicationBuilder builder)
    {
        var useOtlpExporter = !string.IsNullOrWhiteSpace(builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"]);

        if (useOtlpExporter)
        {
            builder.Services.AddOpenTelemetry().UseOtlpExporter();
        }

        return builder;
    }

    public static IHostApplicationBuilder AddDefaultHealthChecks(this IHostApplicationBuilder builder)
    {
        builder.Services.AddHealthChecks()
            .AddCheck("self", () => HealthCheckResult.Healthy(), ["live"]);

        return builder;
    }

    public static WebApplication MapDefaultEndpoints(this WebApplication app)
    {
        app.MapHealthChecks("/health");
        app.MapHealthChecks("/alive", new HealthCheckOptions
        {
            Predicate = r => r.Tags.Contains("live")
        });

        return app;
    }
}
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/CampaignDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;

/// <summary>
/// Data transfer object for a campaign.
/// </summary>
public record CampaignDto(
    string Id,
    string Name,
    string Description,
    List<MissionDto> Missions,
    string OwnerId,
    DateTime CreatedAt,
    DateTime UpdatedAt
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/GameMapDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;

/// <summary>
/// Data transfer object for a game map.
/// </summary>
public record GameMapDto(
    string Id,
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    List<MapTokenInstanceDto> Tokens,
    string GridColor,
    double GridOpacity,
    string MissionId,
    string? ImageFileId = null,
    string? ImageContentType = null,
    long ImageFileSize = 0
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/MapTokenInstanceDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;

/// <summary>
/// Data transfer object for a map token instance.
/// </summary>
public record MapTokenInstanceDto(
    string InstanceId,
    string TokenId,
    int X,
    int Y
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/MissionDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;

/// <summary>
/// Data transfer object for a mission.
/// </summary>
public record MissionDto(
    string Id,
    string Name,
    string Description,
    List<GameMapDto> Maps,
    string CampaignId
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/TokenDefinitionDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;

/// <summary>
/// Data transfer object for a token definition.
/// </summary>
public record TokenDefinitionDto(
    string Id,
    string Name,
    string ImageUrl,
    int Size,
    string Type,
    string UserId,
    string? ImageFileId = null,
    string? ImageContentType = null,
    long ImageFileSize = 0
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/UserDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;

/// <summary>
/// Data transfer object for a user.
/// </summary>
public record UserDto(
    string Id,
    string Username,
    string Email,
    string Role,
    string Status
);
</file>

<file path="src/DnDMapBuilder.Contracts/Pagination/PaginatedRequest.cs">
namespace DnDMapBuilder.Contracts.Pagination;

/// <summary>
/// Base class for paginated requests.
/// </summary>
public class PaginatedRequest
{
    /// <summary>
    /// Gets or sets the page number (1-based, default is 1).
    /// </summary>
    public int PageNumber { get; set; } = 1;

    /// <summary>
    /// Gets or sets the page size (default is 20, max is 100).
    /// </summary>
    public int PageSize { get; set; } = 20;

    /// <summary>
    /// Validates the pagination parameters.
    /// </summary>
    public void Validate()
    {
        if (PageNumber < 1)
            PageNumber = 1;

        if (PageSize < 1)
            PageSize = 20;
        else if (PageSize > 100)
            PageSize = 100;
    }

    /// <summary>
    /// Gets the number of items to skip for the current page.
    /// </summary>
    public int GetSkipCount() => (PageNumber - 1) * PageSize;
}
</file>

<file path="src/DnDMapBuilder.Contracts/Pagination/PaginatedResponse.cs">
namespace DnDMapBuilder.Contracts.Pagination;

/// <summary>
/// Generic paginated response wrapper for list operations.
/// </summary>
/// <typeparam name="T">The type of items in the response</typeparam>
public class PaginatedResponse<T>
{
    /// <summary>
    /// Initializes a new instance of the PaginatedResponse class.
    /// </summary>
    /// <param name="items">The items in this page</param>
    /// <param name="pageNumber">The current page number</param>
    /// <param name="pageSize">The page size</param>
    /// <param name="totalCount">The total number of items</param>
    public PaginatedResponse(IEnumerable<T> items, int pageNumber, int pageSize, int totalCount)
    {
        Items = items.ToList();
        PageNumber = pageNumber;
        PageSize = pageSize;
        TotalCount = totalCount;
    }

    /// <summary>
    /// Gets the items in this page.
    /// </summary>
    public List<T> Items { get; }

    /// <summary>
    /// Gets the current page number.
    /// </summary>
    public int PageNumber { get; }

    /// <summary>
    /// Gets the page size.
    /// </summary>
    public int PageSize { get; }

    /// <summary>
    /// Gets the total number of items across all pages.
    /// </summary>
    public int TotalCount { get; }

    /// <summary>
    /// Gets the total number of pages.
    /// </summary>
    public int TotalPages => (TotalCount + PageSize - 1) / PageSize;

    /// <summary>
    /// Gets a value indicating whether there are more pages after the current page.
    /// </summary>
    public bool HasNextPage => PageNumber < TotalPages;

    /// <summary>
    /// Gets a value indicating whether there are pages before the current page.
    /// </summary>
    public bool HasPreviousPage => PageNumber > 1;
}
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/ApproveUserRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to approve or reject a pending user registration.
/// </summary>
public record ApproveUserRequest(
    string UserId,
    bool Approved
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateCampaignRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to create a new campaign.
/// </summary>
public record CreateCampaignRequest(
    string Name,
    string Description
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateMapRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to create a new game map.
/// </summary>
public record CreateMapRequest(
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    string GridColor,
    double GridOpacity,
    string MissionId
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateMissionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to create a new mission.
/// </summary>
public record CreateMissionRequest(
    string Name,
    string Description,
    string CampaignId
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateTokenDefinitionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to create a new token definition.
/// </summary>
public record CreateTokenDefinitionRequest(
    string Name,
    string ImageUrl,
    int Size,
    string Type
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/ImageUploadResponse.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Response for file upload operations.
/// </summary>
public record ImageUploadResponse(
    string FileId,
    string Url,
    string ContentType,
    long FileSize
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/LoginRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request for user login.
/// </summary>
public record LoginRequest(
    string Email,
    string Password
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/MapTokenInstanceRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request for a map token instance.
/// </summary>
public record MapTokenInstanceRequest(
    string TokenId,
    int X,
    int Y
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/RegisterRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request for user registration.
/// </summary>
public record RegisterRequest(
    string Username,
    string Email,
    string Password
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateCampaignRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to update an existing campaign.
/// </summary>
public record UpdateCampaignRequest(
    string Name,
    string Description
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateMapRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to update an existing game map.
/// </summary>
public record UpdateMapRequest(
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    List<MapTokenInstanceRequest> Tokens,
    string GridColor,
    double GridOpacity
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateMissionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to update an existing mission.
/// </summary>
public record UpdateMissionRequest(
    string Name,
    string Description
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateTokenDefinitionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request to update an existing token definition.
/// </summary>
public record UpdateTokenDefinitionRequest(
    string Name,
    string ImageUrl,
    int Size,
    string Type
);
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/ApiResponse.cs">
namespace DnDMapBuilder.Contracts.Responses;

/// <summary>
/// Standard API response wrapper for all endpoints.
/// </summary>
/// <typeparam name="T">The type of data being returned</typeparam>
public record ApiResponse<T>(
    bool Success,
    T? Data,
    string? Message = null,
    List<string>? Errors = null
);
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/AuthResponse.cs">
namespace DnDMapBuilder.Contracts.Responses;

/// <summary>
/// Response containing authentication data.
/// </summary>
public record AuthResponse(
    string Token,
    string UserId,
    string Username,
    string Email,
    string Role,
    string Status
);
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/PaginatedResponse.cs">
namespace DnDMapBuilder.Contracts.Responses;

/// <summary>
/// Response for paginated list results.
/// </summary>
/// <typeparam name="T">The type of items in the list</typeparam>
public record PaginatedResponse<T>(
    List<T> Items,
    int Page,
    int PageSize,
    int TotalCount,
    int TotalPages
);
</file>

<file path="src/DnDMapBuilder.Data/Entities/Campaign.cs">
namespace DnDMapBuilder.Data.Entities;

public class Campaign
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string OwnerId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User Owner { get; set; } = null!;
    public ICollection<Mission> Missions { get; set; } = new List<Mission>();
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/GameMap.cs">
namespace DnDMapBuilder.Data.Entities;

public class GameMap
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string? ImageUrl { get; set; }

    // File storage metadata (new fields for multipart upload)
    public string? ImageFileId { get; set; }
    public string? ImageContentType { get; set; }
    public long ImageFileSize { get; set; } = 0;

    public int Rows { get; set; }
    public int Cols { get; set; }
    public string GridColor { get; set; } = "#000000";
    public double GridOpacity { get; set; } = 0.3;
    public string MissionId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public Mission Mission { get; set; } = null!;
    public ICollection<MapTokenInstance> Tokens { get; set; } = new List<MapTokenInstance>();
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/MapTokenInstance.cs">
namespace DnDMapBuilder.Data.Entities;

public class MapTokenInstance
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string TokenId { get; set; } = string.Empty;
    public string MapId { get; set; } = string.Empty;
    public int X { get; set; }
    public int Y { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public TokenDefinition Token { get; set; } = null!;
    public GameMap Map { get; set; } = null!;
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/Mission.cs">
namespace DnDMapBuilder.Data.Entities;

public class Mission
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string CampaignId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public Campaign Campaign { get; set; } = null!;
    public ICollection<GameMap> Maps { get; set; } = new List<GameMap>();
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/TokenDefinition.cs">
namespace DnDMapBuilder.Data.Entities;

public class TokenDefinition
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string ImageUrl { get; set; } = string.Empty;

    // File storage metadata (new fields for multipart upload)
    public string? ImageFileId { get; set; }
    public string? ImageContentType { get; set; }
    public long ImageFileSize { get; set; } = 0;

    public int Size { get; set; } = 1; // 1, 2, or 3
    public string Type { get; set; } = "player"; // player or enemy
    public string UserId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public User User { get; set; } = null!;
    public ICollection<MapTokenInstance> MapTokenInstances { get; set; } = new List<MapTokenInstance>();
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/User.cs">
namespace DnDMapBuilder.Data.Entities;

public class User
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Username { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string PasswordHash { get; set; } = string.Empty;
    public string Role { get; set; } = "user"; // admin or user
    public string Status { get; set; } = "pending"; // pending, approved, rejected
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

    // Navigation properties
    public ICollection<Campaign> Campaigns { get; set; } = new List<Campaign>();
    public ICollection<TokenDefinition> TokenDefinitions { get; set; } = new List<TokenDefinition>();
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260114100522_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Username = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false),
                    Email = table.Column<string>(type: "nvarchar(255)", maxLength: 255, nullable: false),
                    PasswordHash = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Role = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    Status = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Campaigns",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    Description = table.Column<string>(type: "nvarchar(2000)", maxLength: 2000, nullable: false),
                    OwnerId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Campaigns", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Campaigns_Users_OwnerId",
                        column: x => x.OwnerId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "TokenDefinitions",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    ImageUrl = table.Column<string>(type: "nvarchar(1000)", maxLength: 1000, nullable: false),
                    Size = table.Column<int>(type: "int", nullable: false),
                    Type = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    UserId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_TokenDefinitions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_TokenDefinitions_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "Missions",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    Description = table.Column<string>(type: "nvarchar(2000)", maxLength: 2000, nullable: false),
                    CampaignId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Missions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Missions_Campaigns_CampaignId",
                        column: x => x.CampaignId,
                        principalTable: "Campaigns",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "GameMaps",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    ImageUrl = table.Column<string>(type: "nvarchar(1000)", maxLength: 1000, nullable: true),
                    Rows = table.Column<int>(type: "int", nullable: false),
                    Cols = table.Column<int>(type: "int", nullable: false),
                    GridColor = table.Column<string>(type: "nvarchar(20)", maxLength: 20, nullable: false),
                    GridOpacity = table.Column<double>(type: "float", nullable: false),
                    MissionId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_GameMaps", x => x.Id);
                    table.ForeignKey(
                        name: "FK_GameMaps_Missions_MissionId",
                        column: x => x.MissionId,
                        principalTable: "Missions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "MapTokenInstances",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    TokenId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    MapId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    X = table.Column<int>(type: "int", nullable: false),
                    Y = table.Column<int>(type: "int", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_MapTokenInstances", x => x.Id);
                    table.ForeignKey(
                        name: "FK_MapTokenInstances_GameMaps_MapId",
                        column: x => x.MapId,
                        principalTable: "GameMaps",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                        column: x => x.TokenId,
                        principalTable: "TokenDefinitions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });

            migrationBuilder.InsertData(
                table: "Users",
                columns: new[] { "Id", "CreatedAt", "Email", "PasswordHash", "Role", "Status", "UpdatedAt", "Username" },
                values: new object[] { "admin-seed-id", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin@dndmapbuilder.com", "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S", "admin", "approved", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin" });

            migrationBuilder.CreateIndex(
                name: "IX_Campaigns_OwnerId",
                table: "Campaigns",
                column: "OwnerId");

            migrationBuilder.CreateIndex(
                name: "IX_GameMaps_MissionId",
                table: "GameMaps",
                column: "MissionId");

            migrationBuilder.CreateIndex(
                name: "IX_MapTokenInstances_MapId",
                table: "MapTokenInstances",
                column: "MapId");

            migrationBuilder.CreateIndex(
                name: "IX_MapTokenInstances_TokenId",
                table: "MapTokenInstances",
                column: "TokenId");

            migrationBuilder.CreateIndex(
                name: "IX_Missions_CampaignId",
                table: "Missions",
                column: "CampaignId");

            migrationBuilder.CreateIndex(
                name: "IX_TokenDefinitions_UserId",
                table: "TokenDefinitions",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_Users_Email",
                table: "Users",
                column: "Email",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_Users_Username",
                table: "Users",
                column: "Username",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "MapTokenInstances");

            migrationBuilder.DropTable(
                name: "GameMaps");

            migrationBuilder.DropTable(
                name: "TokenDefinitions");

            migrationBuilder.DropTable(
                name: "Missions");

            migrationBuilder.DropTable(
                name: "Campaigns");

            migrationBuilder.DropTable(
                name: "Users");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260114100522_InitialCreate.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260114100522_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260115221337_PendingModelChanges.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class PendingModelChanges : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260115221337_PendingModelChanges.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260115221337_PendingModelChanges")]
    partial class PendingModelChanges
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116231211_UpdateAdminPasswordHash.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class UpdateAdminPasswordHash : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.UpdateData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id",
                column: "PasswordHash",
                value: "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.UpdateData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id",
                column: "PasswordHash",
                value: "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116231211_UpdateAdminPasswordHash.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260116231211_UpdateAdminPasswordHash")]
    partial class UpdateAdminPasswordHash
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");

                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116232059_RemoveSeedData.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class RemoveSeedData : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DeleteData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.InsertData(
                table: "Users",
                columns: new[] { "Id", "CreatedAt", "Email", "PasswordHash", "Role", "Status", "UpdatedAt", "Username" },
                values: new object[] { "admin-seed-id", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin@dndmapbuilder.com", "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq", "admin", "approved", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin" });
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116232059_RemoveSeedData.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260116232059_RemoveSeedData")]
    partial class RemoveSeedData
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117102707_AddImageFileStorageMetadata.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class AddImageFileStorageMetadata : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "ImageContentType",
                table: "TokenDefinitions",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "ImageFileId",
                table: "TokenDefinitions",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<long>(
                name: "ImageFileSize",
                table: "TokenDefinitions",
                type: "bigint",
                nullable: false,
                defaultValue: 0L);

            migrationBuilder.AddColumn<string>(
                name: "ImageContentType",
                table: "GameMaps",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "ImageFileId",
                table: "GameMaps",
                type: "nvarchar(max)",
                nullable: true);

            migrationBuilder.AddColumn<long>(
                name: "ImageFileSize",
                table: "GameMaps",
                type: "bigint",
                nullable: false,
                defaultValue: 0L);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "ImageContentType",
                table: "TokenDefinitions");

            migrationBuilder.DropColumn(
                name: "ImageFileId",
                table: "TokenDefinitions");

            migrationBuilder.DropColumn(
                name: "ImageFileSize",
                table: "TokenDefinitions");

            migrationBuilder.DropColumn(
                name: "ImageContentType",
                table: "GameMaps");

            migrationBuilder.DropColumn(
                name: "ImageFileId",
                table: "GameMaps");

            migrationBuilder.DropColumn(
                name: "ImageFileSize",
                table: "GameMaps");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117102707_AddImageFileStorageMetadata.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117102707_AddImageFileStorageMetadata")]
    partial class AddImageFileStorageMetadata
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117104633_SaveImageFiles.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class SaveImageFiles : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117104633_SaveImageFiles.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117104633_SaveImageFiles")]
    partial class SaveImageFiles
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117221839_ConfigureCascadeDeletes.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class ConfigureCascadeDeletes : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns");

            migrationBuilder.DropForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances");

            migrationBuilder.AddForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns",
                column: "OwnerId",
                principalTable: "Users",
                principalColumn: "Id",
                onDelete: ReferentialAction.Restrict);

            migrationBuilder.AddForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances",
                column: "TokenId",
                principalTable: "TokenDefinitions",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns");

            migrationBuilder.DropForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances");

            migrationBuilder.AddForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns",
                column: "OwnerId",
                principalTable: "Users",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);

            migrationBuilder.AddForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances",
                column: "TokenId",
                principalTable: "TokenDefinitions",
                principalColumn: "Id",
                onDelete: ReferentialAction.Restrict);
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117221839_ConfigureCascadeDeletes.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117221839_ConfigureCascadeDeletes")]
    partial class ConfigureCascadeDeletes
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "10.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117222805_FixCascadeDeleteTokenDefinition.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    /// <inheritdoc />
    public partial class FixCascadeDeleteTokenDefinition : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {

        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {

        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117222805_FixCascadeDeleteTokenDefinition.Designer.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117222805_FixCascadeDeleteTokenDefinition")]
    partial class FixCascadeDeleteTokenDefinition
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "10.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IGenericRepository.cs">
namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Base repository interface defining standard CRUD operations.
/// </summary>
/// <typeparam name="T">The entity type</typeparam>
public interface IGenericRepository<T> where T : class
{
    /// <summary>
    /// Gets an entity by its ID.
    /// </summary>
    /// <param name="id">The entity ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The entity or null if not found</returns>
    Task<T?> GetByIdAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all entities.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All entities</returns>
    Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Adds a new entity.
    /// </summary>
    /// <param name="entity">The entity to add</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The added entity</returns>
    Task<T> AddAsync(T entity, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing entity.
    /// </summary>
    /// <param name="entity">The entity to update</param>
    /// <param name="cancellationToken">Cancellation token</param>
    Task UpdateAsync(T entity, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes an entity by its ID.
    /// </summary>
    /// <param name="id">The entity ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    Task DeleteAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an entity exists by its ID.
    /// </summary>
    /// <param name="id">The entity ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if the entity exists, false otherwise</returns>
    Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilderDbContextFactory.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;

namespace DnDMapBuilder.Data;

/// <summary>
/// Design-time factory for DnDMapBuilderDbContext.
/// Used by Entity Framework Core for migrations and scaffolding.
/// </summary>
public class DnDMapBuilderDbContextFactory : IDesignTimeDbContextFactory<DnDMapBuilderDbContext>
{
    public DnDMapBuilderDbContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<DnDMapBuilderDbContext>();

        // Use the connection string from environment variable, or a default local SQL Server
        var connectionString = Environment.GetEnvironmentVariable("DefaultConnection")
            ?? "Server=localhost;Database=DnDMapBuilder;User Id=sa;Password=YourPassword123!;TrustServerCertificate=true;";

        optionsBuilder.UseSqlServer(connectionString);

        return new DnDMapBuilderDbContext(optionsBuilder.Options);
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/CachingConfiguration.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;

namespace DnDMapBuilder.Infrastructure.Configuration;

/// <summary>
/// Configuration for response caching policies and cache profiles.
/// </summary>
public static class CachingConfiguration
{
    /// <summary>
    /// Adds response caching services to the dependency injection container.
    /// Configures cache profiles for different endpoint types.
    /// </summary>
    public static IServiceCollection AddResponseCachingConfiguration(this IServiceCollection services)
    {
        services.AddResponseCaching();
        return services;
    }

    /// <summary>
    /// Configures cache profiles for response caching.
    /// Should be called when configuring controllers with AddControllers.
    /// </summary>
    public static IMvcBuilder ConfigureCacheProfiles(this IMvcBuilder mvcBuilder)
    {
        mvcBuilder.AddMvcOptions(options =>
        {
            // Default cache profile: 60 seconds
            options.CacheProfiles.Add("Default60", new()
            {
                Duration = 60,
                Location = ResponseCacheLocation.Any,
                NoStore = false
            });

            // Longer cache profile for static data: 300 seconds (5 minutes)
            options.CacheProfiles.Add("Long300", new()
            {
                Duration = 300,
                Location = ResponseCacheLocation.Any,
                NoStore = false
            });

            // Very short cache for frequently changing data: 10 seconds
            options.CacheProfiles.Add("Short10", new()
            {
                Duration = 10,
                Location = ResponseCacheLocation.Any,
                NoStore = false
            });

            // No cache profile for sensitive operations
            options.CacheProfiles.Add("NoCache", new()
            {
                NoStore = true,
                Location = ResponseCacheLocation.None,
                Duration = 0
            });
        });

        return mvcBuilder;
    }

    /// <summary>
    /// Applies response caching middleware to the application pipeline.
    /// Must be placed before other middleware that depends on caching.
    /// </summary>
    public static IApplicationBuilder UseResponseCachingConfiguration(this IApplicationBuilder app)
    {
        return app.UseResponseCaching();
    }

    /// <summary>
    /// Adds cache control headers for responses.
    /// This middleware ensures proper cache control behavior.
    /// </summary>
    public static IApplicationBuilder UseCacheControlHeaders(this IApplicationBuilder app)
    {
        return app.Use(async (context, next) =>
        {
            // Set cache control header for successful GET requests
            if (context.Request.Method == HttpMethods.Get)
            {
                // Set default cache control if not already set by response cache attribute
                if (!context.Response.Headers.ContainsKey("Cache-Control"))
                {
                    context.Response.Headers["Cache-Control"] = "public, max-age=60";
                }
            }
            else
            {
                // Don't cache non-GET requests
                context.Response.Headers["Cache-Control"] = "no-cache, no-store, must-revalidate";
                context.Response.Headers["Pragma"] = "no-cache";
                context.Response.Headers["Expires"] = "0";
            }

            await next();
        });
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/CorsSettings.cs">
namespace DnDMapBuilder.Infrastructure.Configuration;

/// <summary>
/// CORS configuration settings.
/// </summary>
public class CorsSettings
{
    /// <summary>
    /// Configuration section name for CORS settings.
    /// </summary>
    public const string SectionName = "CorsSettings";

    /// <summary>
    /// Gets or sets the allowed origins for CORS requests.
    /// </summary>
    public string[] AllowedOrigins { get; set; } = Array.Empty<string>();
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/JwtSettings.cs">
namespace DnDMapBuilder.Infrastructure.Configuration;

/// <summary>
/// JWT configuration settings.
/// </summary>
public class JwtSettings
{
    /// <summary>
    /// Configuration section name for JWT settings.
    /// </summary>
    public const string SectionName = "JwtSettings";

    /// <summary>
    /// Gets or sets the secret key for signing JWT tokens.
    /// </summary>
    public string SecretKey { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the token issuer.
    /// </summary>
    public string Issuer { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the token audience.
    /// </summary>
    public string Audience { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the token expiration time in minutes.
    /// </summary>
    public int ExpirationMinutes { get; set; } = 1440; // 24 hours
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/RateLimitConfiguration.cs">
using System.Security.Claims;
using System.Threading.RateLimiting;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.RateLimiting;
using Microsoft.Extensions.DependencyInjection;

namespace DnDMapBuilder.Infrastructure.Configuration;

/// <summary>
/// Configuration for rate limiting policies in the API.
/// </summary>
public static class RateLimitConfiguration
{
    /// <summary>
    /// Adds rate limiting services to the dependency injection container.
    /// </summary>
    public static IServiceCollection AddRateLimitingConfiguration(this IServiceCollection services)
    {
        services.AddRateLimiter(options =>
        {
            // Anonymous users: 100 requests per minute
            options.AddPolicy("anonymous", httpContext =>
                RateLimitPartition.GetFixedWindowLimiter(
                    partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "anonymous",
                    factory: _ => new FixedWindowRateLimiterOptions
                    {
                        AutoReplenishment = true,
                        PermitLimit = 100,
                        Window = TimeSpan.FromMinutes(1)
                    }));

            // Authenticated users: 300 requests per minute
            options.AddPolicy("authenticated", httpContext =>
            {
                var userId = httpContext.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "anonymous";
                return RateLimitPartition.GetFixedWindowLimiter(
                    partitionKey: userId,
                    factory: _ => new FixedWindowRateLimiterOptions
                    {
                        AutoReplenishment = true,
                        PermitLimit = 300,
                        Window = TimeSpan.FromMinutes(1)
                    });
            });

            // File uploads: 10 requests per minute
            options.AddPolicy("fileUpload", httpContext =>
            {
                var userId = httpContext.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "anonymous";
                return RateLimitPartition.GetFixedWindowLimiter(
                    partitionKey: $"{userId}-upload",
                    factory: _ => new FixedWindowRateLimiterOptions
                    {
                        AutoReplenishment = true,
                        PermitLimit = 10,
                        Window = TimeSpan.FromMinutes(1)
                    });
            });

            // Return 429 on rate limit exceeded
            options.OnRejected = async (context, _) =>
            {
                context.HttpContext.Response.StatusCode = StatusCodes.Status429TooManyRequests;
                context.HttpContext.Response.Headers.RetryAfter = "60";
                context.HttpContext.Response.ContentType = "application/json";

                var response = new { success = false, message = "Rate limit exceeded. Please try again later.", retryAfter = 60 };
                await context.HttpContext.Response.WriteAsJsonAsync(response);
            };
        });

        return services;
    }

    /// <summary>
    /// Applies rate limiting middleware to the application pipeline.
    /// </summary>
    public static IApplicationBuilder UseRateLimitingConfiguration(this IApplicationBuilder app)
    {
        return app.UseRateLimiter();
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/HealthChecks/HealthCheckConfiguration.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using System.Text.Json;

namespace DnDMapBuilder.Infrastructure.HealthChecks;

/// <summary>
/// Configures health checks for the application.
/// </summary>
public static class HealthCheckConfiguration
{
    /// <summary>
    /// Adds health checks to the service collection.
    /// </summary>
    /// <param name="services">The service collection to configure</param>
    /// <param name="configuration">The application configuration</param>
    /// <returns>The service collection for chaining</returns>
    public static IServiceCollection AddHealthChecksConfiguration(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var connectionString = configuration.GetConnectionString("DefaultConnection");

        var builder = services
            .AddHealthChecks()
            .AddSqlServer(
                connectionString ?? throw new InvalidOperationException("DefaultConnection not configured"),
                name: "database",
                failureStatus: HealthStatus.Unhealthy,
                timeout: TimeSpan.FromSeconds(5),
                tags: new[] { "ready", "live" })
            .AddCheck("memory_check", new MemoryHealthCheck(), HealthStatus.Degraded, tags: new[] { "ready" });

        return services;
    }

    /// <summary>
    /// Maps health check endpoints to the application pipeline.
    /// </summary>
    /// <param name="app">The application builder</param>
    public static void MapHealthCheckEndpoints(this WebApplication app)
    {
        // General health check endpoint
        app.MapHealthChecks("/health", new HealthCheckOptions
        {
            AllowCachingResponses = false,
            ResponseWriter = WriteHealthCheckResponse
        });

        // Readiness probe for Kubernetes (checks all required services)
        app.MapHealthChecks("/health/ready", new HealthCheckOptions
        {
            AllowCachingResponses = false,
            ResponseWriter = WriteHealthCheckResponse,
            Predicate = registration => registration.Tags.Contains("ready")
        });

        // Liveness probe for Kubernetes (checks if service is running)
        app.MapHealthChecks("/health/live", new HealthCheckOptions
        {
            AllowCachingResponses = false,
            ResponseWriter = WriteHealthCheckResponse,
            Predicate = registration => registration.Tags.Contains("live")
        });
    }

    private static async Task WriteHealthCheckResponse(
        HttpContext context,
        HealthReport report)
    {
        context.Response.ContentType = "application/json";

        var response = new
        {
            status = report.Status.ToString(),
            timestamp = DateTime.UtcNow,
            duration = report.TotalDuration.TotalMilliseconds,
            checks = report.Entries.Select(kvp => new
            {
                name = kvp.Key,
                status = kvp.Value.Status.ToString(),
                duration = kvp.Value.Duration.TotalMilliseconds,
                description = kvp.Value.Description ?? string.Empty,
                data = kvp.Value.Data.Count > 0 ? kvp.Value.Data : null
            })
        };

        var options = new JsonSerializerOptions { WriteIndented = true };
        await context.Response.WriteAsJsonAsync(response, options);
    }
}

/// <summary>
/// Health check for available memory.
/// </summary>
public class MemoryHealthCheck : IHealthCheck
{
    private const long MaxMemoryUsageMb = 512; // Adjust based on your requirements

    public Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default)
    {
        var totalMemory = GC.GetTotalMemory(false);
        var memoryUsageMb = totalMemory / 1024 / 1024;

        var data = new Dictionary<string, object>
        {
            { "TotalMemoryMB", memoryUsageMb },
            { "MaxMemoryMB", MaxMemoryUsageMb }
        };

        if (memoryUsageMb > MaxMemoryUsageMb)
        {
            return Task.FromResult(
                HealthCheckResult.Degraded(
                    $"Memory usage is {memoryUsageMb}MB which exceeds the threshold of {MaxMemoryUsageMb}MB",
                    data: data));
        }

        return Task.FromResult(
            HealthCheckResult.Healthy(
                $"Memory usage is {memoryUsageMb}MB",
                data: data));
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Logging/LoggingConfiguration.cs">
using Serilog;
using Serilog.Core;
using Serilog.Events;

namespace DnDMapBuilder.Infrastructure.Logging;

/// <summary>
/// Configures Serilog structured logging for the application.
/// </summary>
public static class LoggingConfiguration
{
    /// <summary>
    /// Configures Serilog logger with appropriate sinks and enrichers.
    /// </summary>
    /// <param name="environment">The application environment (Development, Staging, Production)</param>
    /// <param name="isDevelopment">Whether running in development mode</param>
    /// <returns>Configured Serilog ILogger instance</returns>
    public static Serilog.ILogger ConfigureLogging(string? environment, bool isDevelopment)
    {
        var logLevel = isDevelopment ? LogEventLevel.Debug : LogEventLevel.Information;

        var loggerConfig = new LoggerConfiguration()
            .MinimumLevel.Is(logLevel)
            .Enrich.FromLogContext()
            .Enrich.WithMachineName()
            .Enrich.WithEnvironmentUserName()
            .Enrich.WithThreadId();

        // Override logging levels for specific namespaces
        loggerConfig
            .MinimumLevel.Override("Microsoft.EntityFrameworkCore", LogEventLevel.Warning)
            .MinimumLevel.Override("Microsoft.EntityFrameworkCore.Database.Command", LogEventLevel.Warning)
            .MinimumLevel.Override("System", LogEventLevel.Warning)
            .MinimumLevel.Override("Microsoft", LogEventLevel.Warning);

        // Console sink for all environments
        loggerConfig.WriteTo.Console(
            outputTemplate: "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz}] [{Level:u3}] {Message:lj}{NewLine}{Exception}");

        // File sink with rolling files
        loggerConfig.WriteTo.File(
            path: "logs/app-.txt",
            rollingInterval: RollingInterval.Day,
            fileSizeLimitBytes: 100 * 1024 * 1024, // 100MB
            retainedFileCountLimit: 30,
            outputTemplate: "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz}] [{Level:u3}] [{SourceContext}] {Message:lj}{NewLine}{Exception}");

        // Seq sink for structured log aggregation (optional, for development/staging)
        var seqUrl = Environment.GetEnvironmentVariable("SEQ_SERVER_URL");
        if (!string.IsNullOrEmpty(seqUrl))
        {
            loggerConfig.WriteTo.Seq(seqUrl);
        }

        return loggerConfig.CreateLogger();
    }

}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Middleware/RequestResponseLoggingMiddleware.cs">
using System.Diagnostics;
using System.Text;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;

namespace DnDMapBuilder.Infrastructure.Middleware;

/// <summary>
/// Middleware for logging HTTP requests and responses.
/// </summary>
public class RequestResponseLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestResponseLoggingMiddleware> _logger;
    private readonly HashSet<string> _excludedPaths;
    private const int MaxBodySizeToLog = 4096; // 4KB

    public RequestResponseLoggingMiddleware(RequestDelegate next, ILogger<RequestResponseLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
        _excludedPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "/health",
            "/health/live",
            "/health/ready"
        };
    }

    /// <summary>
    /// Invokes the middleware to log request/response information.
    /// </summary>
    public async Task InvokeAsync(HttpContext context)
    {
        // Skip logging for excluded paths
        if (_excludedPaths.Any(path => context.Request.Path.StartsWithSegments(path)))
        {
            await _next(context);
            return;
        }

        var stopwatch = Stopwatch.StartNew();
        var correlationId = GetOrCreateCorrelationId(context);

        // Log request
        await LogRequestAsync(context, correlationId);

        // Store original response body stream
        var originalBodyStream = context.Response.Body;
        using (var responseBody = new MemoryStream())
        {
            context.Response.Body = responseBody;

            try
            {
                // Call next middleware
                await _next(context);

                // Log response
                stopwatch.Stop();
                await LogResponseAsync(context, correlationId, stopwatch.ElapsedMilliseconds);

                // Copy response to original stream
                await responseBody.CopyToAsync(originalBodyStream);
            }
            finally
            {
                context.Response.Body = originalBodyStream;
            }
        }
    }

    /// <summary>
    /// Logs the HTTP request details.
    /// </summary>
    private async Task LogRequestAsync(HttpContext context, string correlationId)
    {
        var request = context.Request;
        var userIdentity = context.User?.Identity?.Name ?? "Anonymous";

        // Log basic request info
        _logger.LogInformation(
            "HTTP Request | CorrelationId: {CorrelationId} | Method: {Method} | Path: {Path} | Query: {Query} | User: {User}",
            correlationId,
            request.Method,
            request.Path,
            request.QueryString.Value,
            userIdentity
        );

        // Log request headers (excluding sensitive ones)
        var sensitiveHeaders = new[] { "authorization", "cookie", "x-api-key", "x-token" };
        var headers = request.Headers
            .Where(h => !sensitiveHeaders.Contains(h.Key.ToLower()))
            .ToDictionary(h => h.Key, h => h.Value.ToString());

        if (headers.Any())
        {
            _logger.LogDebug(
                "HTTP Request Headers | CorrelationId: {CorrelationId} | Headers: {@Headers}",
                correlationId,
                headers
            );
        }

        // Log request body for POST/PUT/PATCH
        if (context.Request.ContentLength > 0 &&
            (request.Method == HttpMethods.Post ||
             request.Method == HttpMethods.Put ||
             request.Method == HttpMethods.Patch))
        {
            request.EnableBuffering();
            var body = await new StreamReader(request.Body).ReadToEndAsync();
            request.Body.Position = 0;

            if (!string.IsNullOrWhiteSpace(body) && body.Length <= MaxBodySizeToLog)
            {
                _logger.LogDebug(
                    "HTTP Request Body | CorrelationId: {CorrelationId} | Body: {Body}",
                    correlationId,
                    body
                );
            }
            else if (body.Length > MaxBodySizeToLog)
            {
                _logger.LogDebug(
                    "HTTP Request Body | CorrelationId: {CorrelationId} | Body: [Truncated - Size: {Size} bytes]",
                    correlationId,
                    body.Length
                );
            }
        }
    }

    /// <summary>
    /// Logs the HTTP response details.
    /// </summary>
    private async Task LogResponseAsync(HttpContext context, string correlationId, long elapsedMilliseconds)
    {
        var response = context.Response;

        // Log response status
        _logger.LogInformation(
            "HTTP Response | CorrelationId: {CorrelationId} | StatusCode: {StatusCode} | Duration: {DurationMs}ms",
            correlationId,
            response.StatusCode,
            elapsedMilliseconds
        );

        // Log response headers
        var responseHeaders = response.Headers
            .ToDictionary(h => h.Key, h => h.Value.ToString());

        if (responseHeaders.Any())
        {
            _logger.LogDebug(
                "HTTP Response Headers | CorrelationId: {CorrelationId} | Headers: {@Headers}",
                correlationId,
                responseHeaders
            );
        }

        // Log response body for error responses or small successful responses
        if (response.Body.CanSeek)
        {
            response.Body.Seek(0, SeekOrigin.Begin);
            var responseBody = await new StreamReader(response.Body).ReadToEndAsync();
            response.Body.Seek(0, SeekOrigin.Begin);

            if (!string.IsNullOrWhiteSpace(responseBody) && responseBody.Length <= MaxBodySizeToLog)
            {
                if (response.StatusCode >= 400 || response.StatusCode == 201)
                {
                    _logger.LogDebug(
                        "HTTP Response Body | CorrelationId: {CorrelationId} | Body: {Body}",
                        correlationId,
                        responseBody
                    );
                }
            }
        }
    }

    /// <summary>
    /// Gets or creates a correlation ID for request tracing.
    /// </summary>
    private string GetOrCreateCorrelationId(HttpContext context)
    {
        const string correlationIdHeader = "X-Correlation-ID";

        if (context.Request.Headers.TryGetValue(correlationIdHeader, out var correlationId))
        {
            return correlationId.ToString();
        }

        var newCorrelationId = Guid.NewGuid().ToString();
        context.Request.Headers.Add(correlationIdHeader, newCorrelationId);
        context.Response.Headers.Add(correlationIdHeader, newCorrelationId);

        return newCorrelationId;
    }
}

/// <summary>
/// Extension methods for adding request/response logging middleware.
/// </summary>
public static class RequestResponseLoggingMiddlewareExtensions
{
    /// <summary>
    /// Adds request/response logging middleware to the pipeline.
    /// </summary>
    public static IApplicationBuilder UseRequestResponseLogging(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<RequestResponseLoggingMiddleware>();
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Middleware/SecurityHeadersMiddleware.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;

namespace DnDMapBuilder.Infrastructure.Middleware;

/// <summary>
/// Middleware for adding security headers to HTTP responses.
/// </summary>
public class SecurityHeadersMiddleware
{
    private readonly RequestDelegate _next;

    public SecurityHeadersMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    /// <summary>
    /// Invokes the middleware to add security headers.
    /// </summary>
    public async Task InvokeAsync(HttpContext context)
    {
        // Prevent MIME type sniffing
        context.Response.Headers["X-Content-Type-Options"] = "nosniff";

        // Prevent clickjacking attacks
        context.Response.Headers["X-Frame-Options"] = "DENY";

        // Enable XSS protection
        context.Response.Headers["X-XSS-Protection"] = "1; mode=block";

        // HSTS (HTTP Strict Transport Security)
        // Tells browsers to always use HTTPS for this domain
        context.Response.Headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains; preload";

        // Content Security Policy
        // Restrict content to same-origin only
        context.Response.Headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'";

        // Referrer Policy
        context.Response.Headers["Referrer-Policy"] = "strict-origin-when-cross-origin";

        // Permissions Policy (formerly Feature Policy)
        context.Response.Headers["Permissions-Policy"] = "geolocation=(), microphone=(), camera=()";

        await _next(context);
    }
}

/// <summary>
/// Extension methods for adding security headers middleware.
/// </summary>
public static class SecurityHeadersMiddlewareExtensions
{
    /// <summary>
    /// Adds security headers middleware to the pipeline.
    /// </summary>
    public static IApplicationBuilder UseSecurityHeaders(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<SecurityHeadersMiddleware>();
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Telemetry/ITelemetryService.cs">
using System.Diagnostics;

namespace DnDMapBuilder.Infrastructure.Telemetry;

/// <summary>
/// Service for recording custom telemetry events and metrics.
/// </summary>
public interface ITelemetryService
{
    /// <summary>
    /// Records an authentication attempt.
    /// </summary>
    /// <param name="userId">The user ID (if successful)</param>
    /// <param name="success">Whether the authentication was successful</param>
    /// <param name="durationMs">Duration in milliseconds</param>
    void RecordAuthenticationAttempt(int? userId, bool success, long durationMs);

    /// <summary>
    /// Records a token operation.
    /// </summary>
    /// <param name="operationType">Type of token operation (issue, refresh, revoke)</param>
    /// <param name="success">Whether the operation was successful</param>
    void RecordTokenOperation(string operationType, bool success);

    /// <summary>
    /// Records a campaign CRUD operation.
    /// </summary>
    /// <param name="operationType">Type of operation (Create, Read, Update, Delete)</param>
    /// <param name="campaignId">The campaign ID</param>
    /// <param name="durationMs">Duration in milliseconds</param>
    void RecordCampaignOperation(string operationType, int campaignId, long durationMs);

    /// <summary>
    /// Records a mission CRUD operation.
    /// </summary>
    /// <param name="operationType">Type of operation (Create, Read, Update, Delete)</param>
    /// <param name="missionId">The mission ID</param>
    /// <param name="durationMs">Duration in milliseconds</param>
    void RecordMissionOperation(string operationType, int missionId, long durationMs);

    /// <summary>
    /// Records a game map CRUD operation.
    /// </summary>
    /// <param name="operationType">Type of operation (Create, Read, Update, Delete)</param>
    /// <param name="mapId">The map ID</param>
    /// <param name="durationMs">Duration in milliseconds</param>
    void RecordMapOperation(string operationType, int mapId, long durationMs);

    /// <summary>
    /// Records a token instance operation.
    /// </summary>
    /// <param name="operationType">Type of operation (Create, Read, Update, Delete)</param>
    /// <param name="tokenId">The token instance ID</param>
    /// <param name="durationMs">Duration in milliseconds</param>
    void RecordTokenInstanceOperation(string operationType, int tokenId, long durationMs);

    /// <summary>
    /// Records a file upload operation.
    /// </summary>
    /// <param name="fileName">Name of the uploaded file</param>
    /// <param name="fileSizeBytes">Size of the file in bytes</param>
    /// <param name="success">Whether the upload was successful</param>
    /// <param name="durationMs">Duration in milliseconds</param>
    void RecordFileUpload(string fileName, long fileSizeBytes, bool success, long durationMs);

    /// <summary>
    /// Creates an activity for manual tracing.
    /// </summary>
    /// <param name="activityName">Name of the activity</param>
    /// <returns>The created activity, or null if tracing is not enabled</returns>
    Activity? StartActivity(string activityName);
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Telemetry/TelemetryConfiguration.cs">
using System.Diagnostics;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Instrumentation.AspNetCore;
using OpenTelemetry.Instrumentation.Http;
using OpenTelemetry.Instrumentation.SqlClient;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace DnDMapBuilder.Infrastructure.Telemetry;

/// <summary>
/// Configures OpenTelemetry for distributed tracing and metrics collection.
/// </summary>
public static class TelemetryConfiguration
{
    /// <summary>
    /// Adds OpenTelemetry tracing and metrics to the service collection.
    /// </summary>
    /// <param name="services">The service collection to configure</param>
    /// <param name="configuration">The application configuration</param>
    /// <param name="isDevelopment">Whether running in development mode</param>
    /// <returns>The service collection for chaining</returns>
    public static IServiceCollection AddOpenTelemetryTracing(
        this IServiceCollection services,
        IConfiguration configuration,
        bool isDevelopment)
    {
        var otlpEndpoint = configuration["Telemetry:OtlpEndpoint"];

        // Configure tracing
        services.ConfigureOpenTelemetryTracerProvider((sp, builder) =>
        {
            builder
                .AddAspNetCoreInstrumentation(options =>
                {
                    options.RecordException = true;
                    options.EnrichWithHttpRequest = EnrichWithHttpRequest;
                    options.EnrichWithHttpResponse = EnrichWithHttpResponse;
                })
                .AddHttpClientInstrumentation(options =>
                {
                    options.RecordException = true;
                })
                .AddSqlClientInstrumentation(options =>
                {
                    options.RecordException = true;
                })
                .AddSource("DnDMapBuilder.Services")
                .AddSource("DnDMapBuilder.Repositories");

            // Export to OTLP endpoint if configured
            if (!string.IsNullOrEmpty(otlpEndpoint))
            {
                builder.AddOtlpExporter(options =>
                {
                    options.Endpoint = new Uri(otlpEndpoint);
                    options.Protocol = OtlpExportProtocol.Grpc;
                });
            }
        });

        // Register telemetry service
        services.AddSingleton<ITelemetryService, TelemetryService>();

        return services;
    }

    private static void EnrichWithHttpRequest(Activity activity, HttpRequest request)
    {
        activity.SetTag("http.request_content_type", request.ContentType);
        activity.SetTag("http.client_ip", request.HttpContext?.Connection?.RemoteIpAddress?.ToString());
    }

    private static void EnrichWithHttpResponse(Activity activity, HttpResponse response)
    {
        activity.SetTag("http.response_content_type", response.ContentType);
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Telemetry/TelemetryService.cs">
using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace DnDMapBuilder.Infrastructure.Telemetry;

/// <summary>
/// Service for recording custom telemetry events and metrics using OpenTelemetry.
/// </summary>
public class TelemetryService : ITelemetryService
{
    private readonly ActivitySource _activitySource;
    private readonly Meter _authenticationMeter;
    private readonly Meter _campaignMeter;
    private readonly Meter _missionMeter;
    private readonly Meter _mapMeter;
    private readonly Meter _tokenMeter;
    private readonly Meter _fileMeter;

    // Counters for various operations
    private readonly Counter<int> _authenticationAttempts;
    private readonly Counter<int> _authenticationSuccesses;
    private readonly Counter<int> _authenticationFailures;

    private readonly Counter<int> _tokenIssued;
    private readonly Counter<int> _tokenRefreshed;
    private readonly Counter<int> _tokenRevoked;

    private readonly Counter<int> _campaignCreated;
    private readonly Counter<int> _campaignUpdated;
    private readonly Counter<int> _campaignDeleted;
    private readonly Histogram<long> _campaignOperationDuration;

    private readonly Counter<int> _missionCreated;
    private readonly Counter<int> _missionUpdated;
    private readonly Counter<int> _missionDeleted;
    private readonly Histogram<long> _missionOperationDuration;

    private readonly Counter<int> _mapCreated;
    private readonly Counter<int> _mapUpdated;
    private readonly Counter<int> _mapDeleted;
    private readonly Histogram<long> _mapOperationDuration;

    private readonly Counter<int> _tokenInstanceCreated;
    private readonly Counter<int> _tokenInstanceUpdated;
    private readonly Counter<int> _tokenInstanceDeleted;
    private readonly Histogram<long> _tokenInstanceOperationDuration;

    private readonly Counter<int> _fileUploadsSuccessful;
    private readonly Counter<int> _fileUploadsFailed;
    private readonly Histogram<long> _fileUploadDuration;
    private readonly Histogram<long> _fileUploadSize;

    /// <summary>
    /// Initializes a new instance of the TelemetryService class.
    /// </summary>
    public TelemetryService()
    {
        // Create activity source for distributed tracing
        _activitySource = new ActivitySource("DnDMapBuilder.Services");

        // Create meters for different domains
        _authenticationMeter = new Meter("DnDMapBuilder.Authentication", "1.0.0");
        _campaignMeter = new Meter("DnDMapBuilder.CampaignOperations", "1.0.0");
        _missionMeter = new Meter("DnDMapBuilder.MissionOperations", "1.0.0");
        _mapMeter = new Meter("DnDMapBuilder.MapOperations", "1.0.0");
        _tokenMeter = new Meter("DnDMapBuilder.TokenOperations", "1.0.0");
        _fileMeter = new Meter("DnDMapBuilder.FileOperations", "1.0.0");

        // Initialize authentication counters
        _authenticationAttempts = _authenticationMeter.CreateCounter<int>(
            "authentication.attempts.total",
            description: "Total authentication attempts");
        _authenticationSuccesses = _authenticationMeter.CreateCounter<int>(
            "authentication.successes.total",
            description: "Total successful authentications");
        _authenticationFailures = _authenticationMeter.CreateCounter<int>(
            "authentication.failures.total",
            description: "Total failed authentications");

        // Initialize token counters
        _tokenIssued = _tokenMeter.CreateCounter<int>(
            "token.issued.total",
            description: "Total tokens issued");
        _tokenRefreshed = _tokenMeter.CreateCounter<int>(
            "token.refreshed.total",
            description: "Total tokens refreshed");
        _tokenRevoked = _tokenMeter.CreateCounter<int>(
            "token.revoked.total",
            description: "Total tokens revoked");

        // Initialize campaign counters and histograms
        _campaignCreated = _campaignMeter.CreateCounter<int>(
            "campaign.created.total",
            description: "Total campaigns created");
        _campaignUpdated = _campaignMeter.CreateCounter<int>(
            "campaign.updated.total",
            description: "Total campaigns updated");
        _campaignDeleted = _campaignMeter.CreateCounter<int>(
            "campaign.deleted.total",
            description: "Total campaigns deleted");
        _campaignOperationDuration = _campaignMeter.CreateHistogram<long>(
            "campaign.operation.duration_ms",
            unit: "ms",
            description: "Duration of campaign operations in milliseconds");

        // Initialize mission counters and histograms
        _missionCreated = _missionMeter.CreateCounter<int>(
            "mission.created.total",
            description: "Total missions created");
        _missionUpdated = _missionMeter.CreateCounter<int>(
            "mission.updated.total",
            description: "Total missions updated");
        _missionDeleted = _missionMeter.CreateCounter<int>(
            "mission.deleted.total",
            description: "Total missions deleted");
        _missionOperationDuration = _missionMeter.CreateHistogram<long>(
            "mission.operation.duration_ms",
            unit: "ms",
            description: "Duration of mission operations in milliseconds");

        // Initialize map counters and histograms
        _mapCreated = _mapMeter.CreateCounter<int>(
            "map.created.total",
            description: "Total maps created");
        _mapUpdated = _mapMeter.CreateCounter<int>(
            "map.updated.total",
            description: "Total maps updated");
        _mapDeleted = _mapMeter.CreateCounter<int>(
            "map.deleted.total",
            description: "Total maps deleted");
        _mapOperationDuration = _mapMeter.CreateHistogram<long>(
            "map.operation.duration_ms",
            unit: "ms",
            description: "Duration of map operations in milliseconds");

        // Initialize token instance counters and histograms
        _tokenInstanceCreated = _tokenMeter.CreateCounter<int>(
            "token_instance.created.total",
            description: "Total token instances created");
        _tokenInstanceUpdated = _tokenMeter.CreateCounter<int>(
            "token_instance.updated.total",
            description: "Total token instances updated");
        _tokenInstanceDeleted = _tokenMeter.CreateCounter<int>(
            "token_instance.deleted.total",
            description: "Total token instances deleted");
        _tokenInstanceOperationDuration = _tokenMeter.CreateHistogram<long>(
            "token_instance.operation.duration_ms",
            unit: "ms",
            description: "Duration of token instance operations in milliseconds");

        // Initialize file operation counters and histograms
        _fileUploadsSuccessful = _fileMeter.CreateCounter<int>(
            "file.uploads.successful.total",
            description: "Total successful file uploads");
        _fileUploadsFailed = _fileMeter.CreateCounter<int>(
            "file.uploads.failed.total",
            description: "Total failed file uploads");
        _fileUploadDuration = _fileMeter.CreateHistogram<long>(
            "file.upload.duration_ms",
            unit: "ms",
            description: "Duration of file uploads in milliseconds");
        _fileUploadSize = _fileMeter.CreateHistogram<long>(
            "file.upload.size_bytes",
            unit: "bytes",
            description: "Size of uploaded files in bytes");
    }

    public void RecordAuthenticationAttempt(int? userId, bool success, long durationMs)
    {
        _authenticationAttempts.Add(1);

        if (success && userId.HasValue)
        {
            _authenticationSuccesses.Add(1);
        }
        else
        {
            _authenticationFailures.Add(1);
        }
    }

    public void RecordTokenOperation(string operationType, bool success)
    {
        var countLabel = operationType.ToLowerInvariant() switch
        {
            "issue" => _tokenIssued,
            "refresh" => _tokenRefreshed,
            "revoke" => _tokenRevoked,
            _ => _tokenIssued
        };

        countLabel.Add(1);
    }

    public void RecordCampaignOperation(string operationType, int campaignId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _campaignCreated.Add(1);
                break;
            case "update":
                _campaignUpdated.Add(1);
                break;
            case "delete":
                _campaignDeleted.Add(1);
                break;
        }

        _campaignOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }

    public void RecordMissionOperation(string operationType, int missionId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _missionCreated.Add(1);
                break;
            case "update":
                _missionUpdated.Add(1);
                break;
            case "delete":
                _missionDeleted.Add(1);
                break;
        }

        _missionOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }

    public void RecordMapOperation(string operationType, int mapId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _mapCreated.Add(1);
                break;
            case "update":
                _mapUpdated.Add(1);
                break;
            case "delete":
                _mapDeleted.Add(1);
                break;
        }

        _mapOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }

    public void RecordTokenInstanceOperation(string operationType, int tokenId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _tokenInstanceCreated.Add(1);
                break;
            case "update":
                _tokenInstanceUpdated.Add(1);
                break;
            case "delete":
                _tokenInstanceDeleted.Add(1);
                break;
        }

        _tokenInstanceOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }

    public void RecordFileUpload(string fileName, long fileSizeBytes, bool success, long durationMs)
    {
        if (success)
        {
            _fileUploadsSuccessful.Add(1);
        }
        else
        {
            _fileUploadsFailed.Add(1);
        }

        _fileUploadDuration.Record(durationMs, new KeyValuePair<string, object?>("file_name", fileName));
        _fileUploadSize.Record(fileSizeBytes, new KeyValuePair<string, object?>("file_name", fileName));
    }

    public Activity? StartActivity(string activityName)
    {
        return _activitySource.StartActivity(activityName);
    }
}
</file>

<file path="src/DnDMapBuilder.IntegrationTests/Controllers/HealthCheckIntegrationTests.cs">
using Xunit;

namespace DnDMapBuilder.IntegrationTests.Controllers;

/// <summary>
/// Integration tests for health check endpoints.
/// Tests the complete HTTP request/response cycle with real middleware.
///
/// Note: These tests require a running database connection and are marked as
/// placeholder tests to be run in full integration testing environment.
/// </summary>
[Trait("Category", "Integration")]
public class HealthCheckIntegrationTests
{
    /// <summary>
    /// Placeholder test to demonstrate integration test structure.
    /// Real tests would require WebApplicationFactory with proper DB configuration.
    /// </summary>
    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthLive_ShouldReturn200OK()
    {
        // Placeholder: Real implementation would use WebApplicationFactory
        // with proper database configuration for integration testing
        await Task.CompletedTask;
    }

    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthReady_ShouldReturn200OK()
    {
        await Task.CompletedTask;
    }

    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task Health_ShouldReturn200OK()
    {
        await Task.CompletedTask;
    }

    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthLive_ShouldReturnContentType_ApplicationJson()
    {
        await Task.CompletedTask;
    }

    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthEndpoint_ShouldIncludeSecurityHeaders()
    {
        await Task.CompletedTask;
    }

    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthEndpoint_ShouldNotRequireAuthentication()
    {
        await Task.CompletedTask;
    }
}
</file>

<file path="src/DnDMapBuilder.IntegrationTests/Data/CascadeDeleteTests.cs">
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Entities;
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Xunit;

namespace DnDMapBuilder.IntegrationTests.Data;

public class CascadeDeleteTests : IAsyncLifetime
{
    private DbContextOptions<DnDMapBuilderDbContext> _options = null!;
    private DnDMapBuilderDbContext _dbContext = null!;

    public async Task InitializeAsync()
    {
        // Use in-memory database for tests
        _options = new DbContextOptionsBuilder<DnDMapBuilderDbContext>()
            .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
            .Options;

        _dbContext = new DnDMapBuilderDbContext(_options);
        await _dbContext.Database.EnsureCreatedAsync();
    }

    public async Task DisposeAsync()
    {
        await _dbContext.Database.EnsureDeletedAsync();
        await _dbContext.DisposeAsync();
    }

    [Fact]
    public async Task WhenCampaignDeleted_ThenAllMissionsShouldBeDeleted()
    {
        // Arrange
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };

        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        await _dbContext.SaveChangesAsync();

        // Act - Delete the campaign
        var campaignToDelete = await _dbContext.Campaigns.FirstAsync();
        _dbContext.Campaigns.Remove(campaignToDelete);
        await _dbContext.SaveChangesAsync();

        // Assert
        var missionsCount = await _dbContext.Missions.CountAsync();
        missionsCount.Should().Be(0, "All missions should be deleted when campaign is deleted");
    }

    [Fact]
    public async Task WhenMissionDeleted_ThenAllGameMapsShouldBeDeleted()
    {
        // Arrange
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };

        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        await _dbContext.SaveChangesAsync();

        // Act - Delete the mission
        var missionToDelete = await _dbContext.Missions.FirstAsync();
        _dbContext.Missions.Remove(missionToDelete);
        await _dbContext.SaveChangesAsync();

        // Assert
        var mapsCount = await _dbContext.GameMaps.CountAsync();
        mapsCount.Should().Be(0, "All game maps should be deleted when mission is deleted");
    }

    [Fact]
    public async Task WhenGameMapDeleted_ThenAllMapTokenInstancesShouldBeDeleted()
    {
        // Arrange
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };
        var instance = new MapTokenInstance { TokenId = token.Id, Token = token, MapId = gameMap.Id, Map = gameMap };

        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        _dbContext.TokenDefinitions.Add(token);
        _dbContext.MapTokenInstances.Add(instance);
        await _dbContext.SaveChangesAsync();

        // Act - Delete the game map
        var mapToDelete = await _dbContext.GameMaps.FirstAsync();
        _dbContext.GameMaps.Remove(mapToDelete);
        await _dbContext.SaveChangesAsync();

        // Assert
        var instancesCount = await _dbContext.MapTokenInstances.CountAsync();
        instancesCount.Should().Be(0, "All token instances should be deleted when game map is deleted");
    }

    [Fact]
    public async Task WhenTokenDefinitionDeleted_ThenAllMapTokenInstancesShouldBeDeleted()
    {
        // Arrange
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };
        var instance = new MapTokenInstance { TokenId = token.Id, Token = token, MapId = gameMap.Id, Map = gameMap };

        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        _dbContext.TokenDefinitions.Add(token);
        _dbContext.MapTokenInstances.Add(instance);
        await _dbContext.SaveChangesAsync();

        // Act - Delete the token definition
        var tokenToDelete = await _dbContext.TokenDefinitions.FirstAsync();
        _dbContext.TokenDefinitions.Remove(tokenToDelete);
        await _dbContext.SaveChangesAsync();

        // Assert
        var instancesCount = await _dbContext.MapTokenInstances.CountAsync();
        instancesCount.Should().Be(0, "All token instances should be deleted when token definition is deleted");
    }

    [Fact]
    public async Task WhenUserDeleted_ThenCampaignsShouldNotBeDeletedByDelete()
    {
        // Arrange - Delete behavior is set to Restrict
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };

        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        await _dbContext.SaveChangesAsync();

        // Act - Try to delete the user (DeleteBehavior.Restrict is configured)
        var userToDelete = await _dbContext.Users.FirstAsync();
        _dbContext.Users.Remove(userToDelete);

        // Note: In-memory database doesn't enforce foreign key constraints
        // In production SQL Server, this would throw a foreign key constraint exception
        await _dbContext.SaveChangesAsync();

        // Assert - Campaign should still exist (orphaned, but exists)
        var campaignsCount = await _dbContext.Campaigns.CountAsync();
        campaignsCount.Should().Be(1, "Campaign should still exist even though user is deleted (Restrict behavior)");
    }

    [Fact]
    public async Task WhenUserDeleted_ThenTokenDefinitionsShouldBeDeleted()
    {
        // Arrange
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };

        _dbContext.Users.Add(user);
        _dbContext.TokenDefinitions.Add(token);
        await _dbContext.SaveChangesAsync();

        // Act - Delete the user
        var userToDelete = await _dbContext.Users.FirstAsync();
        _dbContext.Users.Remove(userToDelete);
        await _dbContext.SaveChangesAsync();

        // Assert
        var tokensCount = await _dbContext.TokenDefinitions.CountAsync();
        tokensCount.Should().Be(0, "All token definitions should be deleted when user is deleted");
    }

    [Fact]
    public async Task CascadeDelete_MultiLevelHierarchy_ShouldDeleteAll()
    {
        // Arrange - Create full hierarchy
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };
        var instance = new MapTokenInstance { TokenId = token.Id, Token = token, MapId = gameMap.Id, Map = gameMap };

        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        _dbContext.TokenDefinitions.Add(token);
        _dbContext.MapTokenInstances.Add(instance);
        await _dbContext.SaveChangesAsync();

        // Act - Delete the campaign (top of hierarchy)
        var campaignToDelete = await _dbContext.Campaigns.FirstAsync();
        _dbContext.Campaigns.Remove(campaignToDelete);
        await _dbContext.SaveChangesAsync();

        // Assert
        var missionsCount = await _dbContext.Missions.CountAsync();
        var mapsCount = await _dbContext.GameMaps.CountAsync();
        var instancesCount = await _dbContext.MapTokenInstances.CountAsync();

        missionsCount.Should().Be(0, "Missions should be deleted in cascade");
        mapsCount.Should().Be(0, "GameMaps should be deleted in cascade");
        instancesCount.Should().Be(0, "MapTokenInstances should be deleted in cascade");

        // Tokens and users should still exist (they were deleted by token definition cascade, not campaign cascade)
        var tokensCount = await _dbContext.TokenDefinitions.CountAsync();
        var usersCount = await _dbContext.Users.CountAsync();

        tokensCount.Should().Be(1, "Token definitions should not be affected by campaign deletion");
        usersCount.Should().Be(1, "Users should not be affected by campaign deletion");
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Entities/EntityTests.cs">
using DnDMapBuilder.Data.Entities;
using FluentAssertions;
using Xunit;

namespace DnDMapBuilder.UnitTests.Entities;

public class UserEntityTests
{
    [Fact]
    public void User_Initialization_ShouldSetDefaults()
    {
        // Act
        var user = new User();

        // Assert
        user.Id.Should().NotBeNullOrEmpty();
        user.Username.Should().Be(string.Empty);
        user.Email.Should().Be(string.Empty);
        user.PasswordHash.Should().Be(string.Empty);
        user.Role.Should().Be("user");
        user.Status.Should().Be("pending");
        user.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        user.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        user.Campaigns.Should().BeEmpty();
        user.TokenDefinitions.Should().BeEmpty();
    }

    [Fact]
    public void User_ShouldHaveUniqueIds()
    {
        // Act
        var user1 = new User();
        var user2 = new User();

        // Assert
        user1.Id.Should().NotBe(user2.Id);
    }
}

public class CampaignEntityTests
{
    [Fact]
    public void Campaign_Initialization_ShouldSetDefaults()
    {
        // Act
        var campaign = new Campaign();

        // Assert
        campaign.Id.Should().NotBeNullOrEmpty();
        campaign.Name.Should().Be(string.Empty);
        campaign.Description.Should().Be(string.Empty);
        campaign.OwnerId.Should().Be(string.Empty);
        campaign.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        campaign.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        campaign.Missions.Should().BeEmpty();
    }

    [Fact]
    public void Campaign_WithProperties_ShouldHoldValues()
    {
        // Arrange
        var ownerId = "user123";
        var name = "Dragon Quest";
        var description = "A grand adventure";

        // Act
        var campaign = new Campaign
        {
            OwnerId = ownerId,
            Name = name,
            Description = description
        };

        // Assert
        campaign.OwnerId.Should().Be(ownerId);
        campaign.Name.Should().Be(name);
        campaign.Description.Should().Be(description);
    }
}

public class MissionEntityTests
{
    [Fact]
    public void Mission_Initialization_ShouldSetDefaults()
    {
        // Act
        var mission = new Mission();

        // Assert
        mission.Id.Should().NotBeNullOrEmpty();
        mission.Name.Should().Be(string.Empty);
        mission.Description.Should().Be(string.Empty);
        mission.CampaignId.Should().Be(string.Empty);
        mission.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        mission.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        mission.Maps.Should().BeEmpty();
    }
}

public class GameMapEntityTests
{
    [Fact]
    public void GameMap_Initialization_ShouldSetDefaults()
    {
        // Act
        var map = new GameMap();

        // Assert
        map.Id.Should().NotBeNullOrEmpty();
        map.Name.Should().Be(string.Empty);
        map.ImageUrl.Should().BeNull();
        map.GridColor.Should().Be("#000000");
        map.GridOpacity.Should().Be(0.3);
        map.ImageFileSize.Should().Be(0);
        map.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        map.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        map.Tokens.Should().BeEmpty();
    }

    [Fact]
    public void GameMap_WithProperties_ShouldHoldValues()
    {
        // Arrange
        var name = "Tavern";
        var rows = 10;
        var cols = 15;

        // Act
        var map = new GameMap
        {
            Name = name,
            Rows = rows,
            Cols = cols
        };

        // Assert
        map.Name.Should().Be(name);
        map.Rows.Should().Be(rows);
        map.Cols.Should().Be(cols);
    }
}

public class TokenDefinitionEntityTests
{
    [Fact]
    public void TokenDefinition_Initialization_ShouldSetDefaults()
    {
        // Act
        var token = new TokenDefinition();

        // Assert
        token.Id.Should().NotBeNullOrEmpty();
        token.Name.Should().Be(string.Empty);
        token.ImageUrl.Should().Be(string.Empty);
        token.Size.Should().Be(1);
        token.Type.Should().Be("player");
        token.UserId.Should().Be(string.Empty);
        token.ImageFileSize.Should().Be(0);
        token.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        token.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        token.MapTokenInstances.Should().BeEmpty();
    }

    [Fact]
    public void TokenDefinition_WithProperties_ShouldHoldValues()
    {
        // Arrange
        var name = "Knight";
        var type = "player";
        var size = 2;

        // Act
        var token = new TokenDefinition
        {
            Name = name,
            Type = type,
            Size = size
        };

        // Assert
        token.Name.Should().Be(name);
        token.Type.Should().Be(type);
        token.Size.Should().Be(size);
    }
}

public class MapTokenInstanceEntityTests
{
    [Fact]
    public void MapTokenInstance_Initialization_ShouldSetDefaults()
    {
        // Act
        var instance = new MapTokenInstance();

        // Assert
        instance.Id.Should().NotBeNullOrEmpty();
        instance.TokenId.Should().Be(string.Empty);
        instance.MapId.Should().Be(string.Empty);
        instance.X.Should().Be(0);
        instance.Y.Should().Be(0);
        instance.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
    }

    [Fact]
    public void MapTokenInstance_WithPosition_ShouldHoldValues()
    {
        // Arrange
        const int x = 5;
        const int y = 10;
        var tokenId = "token123";
        var mapId = "map123";

        // Act
        var instance = new MapTokenInstance
        {
            X = x,
            Y = y,
            TokenId = tokenId,
            MapId = mapId
        };

        // Assert
        instance.X.Should().Be(x);
        instance.Y.Should().Be(y);
        instance.TokenId.Should().Be(tokenId);
        instance.MapId.Should().Be(mapId);
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Infrastructure/HealthChecks/HealthCheckTests.cs">
using DnDMapBuilder.Infrastructure.HealthChecks;
using FluentAssertions;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Xunit;

namespace DnDMapBuilder.UnitTests.Infrastructure.HealthChecks;

public class MemoryHealthCheckTests
{
    private readonly MemoryHealthCheck _healthCheck;

    public MemoryHealthCheckTests()
    {
        _healthCheck = new MemoryHealthCheck();
    }

    [Fact]
    public async Task CheckHealthAsync_WithValidMemory_ReturnsHealthy()
    {
        // Act
        var result = await _healthCheck.CheckHealthAsync(new HealthCheckContext());

        // Assert
        result.Status.Should().Be(HealthStatus.Healthy);
        result.Description.Should().Contain("Memory usage is");
        result.Data.Should().ContainKey("TotalMemoryMB");
        result.Data.Should().ContainKey("MaxMemoryMB");
    }

    [Fact]
    public async Task CheckHealthAsync_WithValidMemory_IncludesMemoryData()
    {
        // Act
        var result = await _healthCheck.CheckHealthAsync(new HealthCheckContext());

        // Assert
        result.Data.Should().NotBeEmpty();
        result.Data["TotalMemoryMB"].Should().NotBeNull();
        result.Data["MaxMemoryMB"].Should().Be(512);
    }

    [Fact]
    public async Task CheckHealthAsync_WithCancellationToken_Completes()
    {
        // Arrange
        using var cts = new CancellationTokenSource();

        // Act
        var result = await _healthCheck.CheckHealthAsync(
            new HealthCheckContext(),
            cts.Token);

        // Assert
        result.Should().NotBeNull();
        result.Status.Should().BeOneOf(HealthStatus.Healthy, HealthStatus.Degraded);
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Infrastructure/Telemetry/TelemetryServiceTests.cs">
using DnDMapBuilder.Infrastructure.Telemetry;
using FluentAssertions;
using Xunit;

namespace DnDMapBuilder.UnitTests.Infrastructure.Telemetry;

public class TelemetryServiceTests
{
    private readonly TelemetryService _telemetryService;

    public TelemetryServiceTests()
    {
        _telemetryService = new TelemetryService();
    }

    [Fact]
    public void RecordAuthenticationAttempt_WithSuccessfulAuth_ShouldRecord()
    {
        // Arrange
        var userId = 123;
        var success = true;
        var durationMs = 150L;

        // Act
        _telemetryService.RecordAuthenticationAttempt(userId, success, durationMs);

        // Assert
        // Telemetry records are internal and cannot be directly verified, but the method should not throw
        // This test primarily ensures no exceptions occur
    }

    [Fact]
    public void RecordAuthenticationAttempt_WithFailedAuth_ShouldRecord()
    {
        // Arrange
        const long durationMs = 100L;

        // Act
        _telemetryService.RecordAuthenticationAttempt(null, false, durationMs);

        // Assert
        // Should not throw any exceptions
    }

    [Theory]
    [InlineData("issue")]
    [InlineData("refresh")]
    [InlineData("revoke")]
    public void RecordTokenOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        // Act
        _telemetryService.RecordTokenOperation(operationType, true);

        // Assert
        // Should not throw any exceptions
    }

    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordCampaignOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        // Arrange
        const int campaignId = 1;
        const long durationMs = 200L;

        // Act
        _telemetryService.RecordCampaignOperation(operationType, campaignId, durationMs);

        // Assert
        // Should not throw any exceptions
    }

    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordMissionOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        // Arrange
        const int missionId = 1;
        const long durationMs = 200L;

        // Act
        _telemetryService.RecordMissionOperation(operationType, missionId, durationMs);

        // Assert
        // Should not throw any exceptions
    }

    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordMapOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        // Arrange
        const int mapId = 1;
        const long durationMs = 200L;

        // Act
        _telemetryService.RecordMapOperation(operationType, mapId, durationMs);

        // Assert
        // Should not throw any exceptions
    }

    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordTokenInstanceOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        // Arrange
        const int tokenId = 1;
        const long durationMs = 150L;

        // Act
        _telemetryService.RecordTokenInstanceOperation(operationType, tokenId, durationMs);

        // Assert
        // Should not throw any exceptions
    }

    [Fact]
    public void RecordFileUpload_WithSuccessfulUpload_ShouldRecord()
    {
        // Arrange
        const string fileName = "test.png";
        const long fileSizeBytes = 1024 * 100; // 100KB
        const bool success = true;
        const long durationMs = 500L;

        // Act
        _telemetryService.RecordFileUpload(fileName, fileSizeBytes, success, durationMs);

        // Assert
        // Should not throw any exceptions
    }

    [Fact]
    public void RecordFileUpload_WithFailedUpload_ShouldRecord()
    {
        // Arrange
        const string fileName = "test.png";
        const long fileSizeBytes = 0;
        const bool success = false;
        const long durationMs = 100L;

        // Act
        _telemetryService.RecordFileUpload(fileName, fileSizeBytes, success, durationMs);

        // Assert
        // Should not throw any exceptions
    }

    [Fact]
    public void StartActivity_WithValidActivityName_ShouldReturnActivityOrNull()
    {
        // Act
        var activity = _telemetryService.StartActivity("test_activity");

        // Assert
        // Activity might be null if OpenTelemetry is not configured, which is valid in this context
        if (activity != null)
        {
            activity.DisplayName.Should().Be("test_activity");
            activity.Dispose();
        }
    }

    [Fact]
    public void RecordAuthenticationAttempt_WithMultipleAttempts_ShouldRecordAll()
    {
        // Act
        for (int i = 0; i < 5; i++)
        {
            _telemetryService.RecordAuthenticationAttempt(null, false, 100L);
        }

        // Assert
        // Should not throw any exceptions and should handle multiple calls gracefully
    }

    [Fact]
    public void RecordCampaignOperation_WithMixedOperations_ShouldRecord()
    {
        // Act
        _telemetryService.RecordCampaignOperation("create", 1, 100L);
        _telemetryService.RecordCampaignOperation("update", 1, 150L);
        _telemetryService.RecordCampaignOperation("delete", 1, 200L);

        // Assert
        // Should not throw any exceptions
    }

    [Fact]
    public void RecordTokenOperation_WithCaseInsensitivity_ShouldRecord()
    {
        // Act
        _telemetryService.RecordTokenOperation("ISSUE", true);
        _telemetryService.RecordTokenOperation("Refresh", true);
        _telemetryService.RecordTokenOperation("REVOKE", false);

        // Assert
        // Should not throw any exceptions regardless of case
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Infrastructure/CachingConfigurationTests.cs">
using FluentAssertions;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Xunit;
using DnDMapBuilder.Infrastructure.Configuration;

namespace DnDMapBuilder.UnitTests.Infrastructure;

/// <summary>
/// Unit tests for CachingConfiguration.
/// </summary>
public class CachingConfigurationTests
{
    [Fact]
    public void AddResponseCachingConfiguration_ShouldReturnServiceCollection()
    {
        // Arrange
        var services = new ServiceCollection();

        // Act
        var result = services.AddResponseCachingConfiguration();

        // Assert
        result.Should().NotBeNull();
        result.Should().BeSameAs(services);
    }

    [Fact]
    public void ConfigureCacheProfiles_ShouldAddAllFourCacheProfiles()
    {
        // Arrange
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();

        // Act
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();

        // Get MVC options to check cache profiles
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();

        // Assert
        options.Value.CacheProfiles.Should().HaveCount(4);
        options.Value.CacheProfiles.Should().ContainKey("Default60");
        options.Value.CacheProfiles.Should().ContainKey("Long300");
        options.Value.CacheProfiles.Should().ContainKey("Short10");
        options.Value.CacheProfiles.Should().ContainKey("NoCache");
    }

    [Fact]
    public void CacheProfile_Default60_ShouldHave60SecondsExpiration()
    {
        // Arrange
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();

        // Act
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();

        // Assert
        var profile = options.Value.CacheProfiles["Default60"];
        profile.Duration.Should().Be(60);
        profile.NoStore.Should().BeFalse();
        profile.Location.Should().Be(ResponseCacheLocation.Any);
    }

    [Fact]
    public void CacheProfile_Long300_ShouldHave300SecondsExpiration()
    {
        // Arrange
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();

        // Act
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();

        // Assert
        var profile = options.Value.CacheProfiles["Long300"];
        profile.Duration.Should().Be(300);
        profile.NoStore.Should().BeFalse();
        profile.Location.Should().Be(ResponseCacheLocation.Any);
    }

    [Fact]
    public void CacheProfile_Short10_ShouldHave10SecondsExpiration()
    {
        // Arrange
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();

        // Act
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();

        // Assert
        var profile = options.Value.CacheProfiles["Short10"];
        profile.Duration.Should().Be(10);
        profile.NoStore.Should().BeFalse();
        profile.Location.Should().Be(ResponseCacheLocation.Any);
    }

    [Fact]
    public void CacheProfile_NoCache_ShouldDisableCaching()
    {
        // Arrange
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();

        // Act
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();

        // Assert
        var profile = options.Value.CacheProfiles["NoCache"];
        profile.NoStore.Should().BeTrue();
        profile.Duration.Should().Be(0);
        profile.Location.Should().Be(ResponseCacheLocation.None);
    }

    [Fact]
    public void ConfigureCacheProfiles_ShouldReturnMvcBuilder()
    {
        // Arrange
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();

        // Act
        var result = mvcBuilder.ConfigureCacheProfiles();

        // Assert
        result.Should().NotBeNull();
        result.Should().Be(mvcBuilder);
    }

    [Fact]
    public void UseResponseCachingConfiguration_ShouldReturnApplicationBuilder()
    {
        // Arrange
        var app = WebApplication.CreateBuilder().Build();

        // Act
        var result = app.UseResponseCachingConfiguration();

        // Assert
        result.Should().NotBeNull();
        result.Should().Be(app);
    }

    [Fact]
    public void UseCacheControlHeaders_ShouldSetProperHeadersForGetRequests()
    {
        // Arrange
        var context = new DefaultHttpContext();
        context.Request.Method = HttpMethods.Get;
        var middleware = async (HttpContext ctx) => { };

        // Act
        var app = WebApplication.CreateBuilder().Build();
        app.UseCacheControlHeaders();

        // Assert - The middleware should be added to the pipeline
        // This is a basic validation that the middleware can be added
        // without throwing an exception
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/AuthServiceTests.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
using FluentAssertions;
using Moq;
using Xunit;

namespace DnDMapBuilder.UnitTests.Services;

public class AuthServiceTests
{
    private readonly Mock<IUserRepository> _mockUserRepository;
    private readonly Mock<IJwtService> _mockJwtService;
    private readonly Mock<IPasswordService> _mockPasswordService;
    private readonly AuthService _authService;

    public AuthServiceTests()
    {
        _mockUserRepository = new Mock<IUserRepository>();
        _mockJwtService = new Mock<IJwtService>();
        _mockPasswordService = new Mock<IPasswordService>();
        _authService = new AuthService(_mockUserRepository.Object, _mockJwtService.Object, _mockPasswordService.Object);
    }

    [Fact]
    public async Task LoginAsync_WithValidCredentials_ReturnsAuthResponse()
    {
        // Arrange
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };
        var expectedToken = "jwt_token_here";

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        _mockJwtService.Setup(j => j.GenerateToken(user.Id, user.Email, user.Role))
            .Returns(expectedToken);

        // Act
        var result = await _authService.LoginAsync(loginRequest);

        // Assert
        result.Should().NotBeNull();
        result.Token.Should().Be(expectedToken);
        result.UserId.Should().Be(user.Id);
        result.Email.Should().Be(user.Email);
        result.Username.Should().Be(user.Username);
        result.Role.Should().Be(user.Role);
        result.Status.Should().Be(user.Status);
    }

    [Fact]
    public async Task LoginAsync_WithNonExistentUser_ReturnsNull()
    {
        // Arrange
        var loginRequest = new LoginRequest("nonexistent@example.com", "password123");

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync((User)null);

        // Act
        var result = await _authService.LoginAsync(loginRequest);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task LoginAsync_WithInvalidPassword_ReturnsNull()
    {
        // Arrange
        var loginRequest = new LoginRequest("test@example.com", "wrongpassword");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(false);

        // Act
        var result = await _authService.LoginAsync(loginRequest);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task LoginAsync_WithPendingUserAndUserRole_ReturnsNull()
    {
        // Arrange
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "pending"
        };

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);

        // Act
        var result = await _authService.LoginAsync(loginRequest);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task LoginAsync_WithRejectedUserAndUserRole_ReturnsNull()
    {
        // Arrange
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "rejected"
        };

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);

        // Act
        var result = await _authService.LoginAsync(loginRequest);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task LoginAsync_WithPendingAdminUser_ReturnsAuthResponse()
    {
        // Arrange
        var loginRequest = new LoginRequest("admin@example.com", "password123");
        var user = new User
        {
            Id = "admin123",
            Email = "admin@example.com",
            Username = "admin",
            PasswordHash = "hashedpassword",
            Role = "admin",
            Status = "pending"
        };
        var expectedToken = "jwt_token_here";

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        _mockJwtService.Setup(j => j.GenerateToken(user.Id, user.Email, user.Role))
            .Returns(expectedToken);

        // Act
        var result = await _authService.LoginAsync(loginRequest);

        // Assert
        result.Should().NotBeNull();
        result.Token.Should().Be(expectedToken);
        result.Role.Should().Be("admin");
    }

    [Fact]
    public async Task LoginAsync_UsesPasswordServiceForVerification()
    {
        // Arrange
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(false);

        // Act
        await _authService.LoginAsync(loginRequest);

        // Assert
        _mockPasswordService.Verify(
            p => p.VerifyPassword(loginRequest.Password, user.PasswordHash),
            Times.Once
        );
    }

    [Fact]
    public async Task LoginAsync_GeneratesTokenWithCorrectParameters()
    {
        // Arrange
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };

        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        _mockJwtService.Setup(j => j.GenerateToken(user.Id, user.Email, user.Role))
            .Returns("token");

        // Act
        await _authService.LoginAsync(loginRequest);

        // Assert
        _mockJwtService.Verify(
            j => j.GenerateToken(user.Id, user.Email, user.Role),
            Times.Once
        );
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/FileValidationServiceTests.cs">
using FluentAssertions;
using Xunit;
using DnDMapBuilder.Application.Services;

namespace DnDMapBuilder.UnitTests.Services;

/// <summary>
/// Unit tests for FileValidationService.
/// </summary>
public class FileValidationServiceTests
{
    private readonly FileValidationService _fileValidationService = new();

    [Fact]
    public void ValidateFile_WithValidMapFile_ShouldReturnSuccess()
    {
        // Arrange
        var fileName = "map.png";
        var fileSize = 1024 * 1024; // 1MB
        var contentType = "image/png";
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void ValidateFile_WithValidTokenFile_ShouldReturnSuccess()
    {
        // Arrange
        var fileName = "token.jpeg";
        var fileSize = 512 * 1024; // 512KB
        var contentType = "image/jpeg";
        var storageCategory = "tokens";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void ValidateFile_WithEmptyFileName_ShouldReturnError()
    {
        // Arrange
        var fileSize = 1024 * 1024;
        var contentType = "image/png";
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile("", fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("File name cannot be empty"));
    }

    [Fact]
    public void ValidateFile_WithEmptyFile_ShouldReturnError()
    {
        // Arrange
        var fileName = "file.png";
        var fileSize = 0;
        var contentType = "image/png";
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("File cannot be empty"));
    }

    [Fact]
    public void ValidateFile_WithFileSizeExceedingMapLimit_ShouldReturnError()
    {
        // Arrange
        var fileName = "large_map.png";
        var fileSize = 6 * 1024 * 1024; // 6MB (limit is 5MB for maps)
        var contentType = "image/png";
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("exceeds the maximum limit"));
    }

    [Fact]
    public void ValidateFile_WithFileSizeExceedingTokenLimit_ShouldReturnError()
    {
        // Arrange
        var fileName = "large_token.png";
        var fileSize = 3 * 1024 * 1024; // 3MB (limit is 2MB for tokens)
        var contentType = "image/png";
        var storageCategory = "tokens";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("exceeds the maximum limit"));
    }

    [Fact]
    public void ValidateFile_WithInvalidMimeType_ShouldReturnError()
    {
        // Arrange
        var fileName = "file.pdf";
        var fileSize = 1024 * 1024;
        var contentType = "application/pdf";
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("not allowed"));
    }

    [Fact]
    public void ValidateFile_WithWebpMimeType_ShouldReturnSuccess()
    {
        // Arrange
        var fileName = "image.webp";
        var fileSize = 1024 * 1024;
        var contentType = "image/webp";
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }

    [Fact]
    public void ValidateFile_WithNullContentType_ShouldReturnError()
    {
        // Arrange
        var fileName = "file.png";
        var fileSize = 1024 * 1024;
        var contentType = (string?)null;
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType!, storageCategory);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().NotBeEmpty();
    }

    [Fact]
    public void GetMaxFileSizeForCategory_Maps_ShouldReturn5MB()
    {
        // Act
        var maxSize = _fileValidationService.GetMaxFileSizeForCategory("maps");

        // Assert
        maxSize.Should().Be(5 * 1024 * 1024);
    }

    [Fact]
    public void GetMaxFileSizeForCategory_Tokens_ShouldReturn2MB()
    {
        // Act
        var maxSize = _fileValidationService.GetMaxFileSizeForCategory("tokens");

        // Assert
        maxSize.Should().Be(2 * 1024 * 1024);
    }

    [Fact]
    public void GetMaxFileSizeForCategory_UnknownCategory_ShouldReturnDefault10MB()
    {
        // Act
        var maxSize = _fileValidationService.GetMaxFileSizeForCategory("unknown");

        // Assert
        maxSize.Should().Be(10 * 1024 * 1024);
    }

    [Fact]
    public void GetAllowedMimeTypesForCategory_Maps_ShouldReturnImageTypes()
    {
        // Act
        var allowedTypes = _fileValidationService.GetAllowedMimeTypesForCategory("maps");

        // Assert
        allowedTypes.Should().Contain(new[] { "image/png", "image/jpeg", "image/webp" });
    }

    [Fact]
    public void ValidateFile_WithMultipleErrors_ShouldReturnAllErrors()
    {
        // Arrange
        var fileName = "file.pdf";
        var fileSize = 6 * 1024 * 1024; // Exceeds limit and wrong type
        var contentType = "application/pdf";
        var storageCategory = "maps";

        // Act
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);

        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().HaveCountGreaterThan(1);
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/PasswordServiceTests.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using FluentAssertions;
using Xunit;

namespace DnDMapBuilder.UnitTests.Services;

public class PasswordServiceTests
{
    private readonly IPasswordService _passwordService;

    public PasswordServiceTests()
    {
        _passwordService = new PasswordService();
    }

    [Fact]
    public void HashPassword_WithValidPassword_ReturnsNonNullHash()
    {
        // Arrange
        const string password = "SecurePassword123!";

        // Act
        var hash = _passwordService.HashPassword(password);

        // Assert
        hash.Should().NotBeNullOrEmpty();
    }

    [Fact]
    public void HashPassword_WithSamePassword_ReturnsDifferentHashes()
    {
        // Arrange
        const string password = "SecurePassword123!";

        // Act
        var hash1 = _passwordService.HashPassword(password);
        var hash2 = _passwordService.HashPassword(password);

        // Assert
        hash1.Should().NotBe(hash2);
    }

    [Fact]
    public void VerifyPassword_WithCorrectPassword_ReturnsTrue()
    {
        // Arrange
        const string password = "SecurePassword123!";
        var hash = _passwordService.HashPassword(password);

        // Act
        var result = _passwordService.VerifyPassword(password, hash);

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public void VerifyPassword_WithIncorrectPassword_ReturnsFalse()
    {
        // Arrange
        const string password = "SecurePassword123!";
        const string wrongPassword = "WrongPassword123!";
        var hash = _passwordService.HashPassword(password);

        // Act
        var result = _passwordService.VerifyPassword(wrongPassword, hash);

        // Assert
        result.Should().BeFalse();
    }

    [Fact]
    public void VerifyPassword_WithEmptyPassword_ReturnsFalse()
    {
        // Arrange
        const string password = "SecurePassword123!";
        const string emptyPassword = "";
        var hash = _passwordService.HashPassword(password);

        // Act
        var result = _passwordService.VerifyPassword(emptyPassword, hash);

        // Assert
        result.Should().BeFalse();
    }

    [Fact]
    public void VerifyPassword_WithNullPassword_ThrowsException()
    {
        // Arrange
        const string password = "SecurePassword123!";
        var hash = _passwordService.HashPassword(password);

        // Act & Assert
        var action = () => _passwordService.VerifyPassword(null, hash);
        action.Should().Throw<Exception>();
    }

    [Fact]
    public void HashPassword_WithEmptyPassword_ReturnsNonNullHash()
    {
        // Arrange
        const string password = "";

        // Act
        var hash = _passwordService.HashPassword(password);

        // Assert
        hash.Should().NotBeNullOrEmpty();
    }

    [Fact]
    public void VerifyPassword_CanVerifyHashedEmptyPassword()
    {
        // Arrange
        const string password = "";
        var hash = _passwordService.HashPassword(password);

        // Act
        var result = _passwordService.VerifyPassword(password, hash);

        // Assert
        result.Should().BeTrue();
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/UserManagementServiceTests.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
using FluentAssertions;
using Moq;
using Xunit;

namespace DnDMapBuilder.UnitTests.Services;

public class UserManagementServiceTests
{
    private readonly Mock<IUserRepository> _mockUserRepository;
    private readonly Mock<IPasswordService> _mockPasswordService;
    private readonly UserManagementService _userManagementService;

    public UserManagementServiceTests()
    {
        _mockUserRepository = new Mock<IUserRepository>();
        _mockPasswordService = new Mock<IPasswordService>();
        _userManagementService = new UserManagementService(_mockUserRepository.Object, _mockPasswordService.Object);
    }

    [Fact]
    public async Task RegisterAsync_WithValidCredentials_CreatesUserSuccessfully()
    {
        // Arrange
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";

        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));

        // Act
        var result = await _userManagementService.RegisterAsync(registerRequest);

        // Assert
        result.Should().NotBeNull();
        result.Username.Should().Be(registerRequest.Username);
        result.Email.Should().Be(registerRequest.Email);
        result.Role.Should().Be("user");
        result.Status.Should().Be("pending");
    }

    [Fact]
    public async Task RegisterAsync_WithDuplicateEmail_ReturnsNull()
    {
        // Arrange
        var registerRequest = new RegisterRequest("newuser", "existing@example.com", "password123");
        var existingUser = new User
        {
            Email = registerRequest.Email,
            Username = "existinguser"
        };

        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync(existingUser);

        // Act
        var result = await _userManagementService.RegisterAsync(registerRequest);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task RegisterAsync_WithDuplicateUsername_ReturnsNull()
    {
        // Arrange
        var registerRequest = new RegisterRequest("existinguser", "new@example.com", "password123");
        var existingUser = new User
        {
            Username = registerRequest.Username,
            Email = "existing@example.com"
        };

        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync(existingUser);

        // Act
        var result = await _userManagementService.RegisterAsync(registerRequest);

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task RegisterAsync_UsesPasswordServiceToHashPassword()
    {
        // Arrange
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";

        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));

        // Act
        await _userManagementService.RegisterAsync(registerRequest);

        // Assert
        _mockPasswordService.Verify(
            p => p.HashPassword(registerRequest.Password),
            Times.Once
        );
    }

    [Fact]
    public async Task RegisterAsync_CallsRepositoryAddAsync()
    {
        // Arrange
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";

        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));

        // Act
        await _userManagementService.RegisterAsync(registerRequest);

        // Assert
        _mockUserRepository.Verify(
            r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }

    [Fact]
    public async Task ApproveUserAsync_WithValidUserId_ApprovesUser()
    {
        // Arrange
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };

        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _userManagementService.ApproveUserAsync(userId, true);

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public async Task ApproveUserAsync_WithValidUserId_RejectsUser()
    {
        // Arrange
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };

        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _userManagementService.ApproveUserAsync(userId, false);

        // Assert
        result.Should().BeTrue();
    }

    [Fact]
    public async Task ApproveUserAsync_WithNonExistentUserId_ReturnsFalse()
    {
        // Arrange
        var userId = "nonexistent";

        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync((User)null);

        // Act
        var result = await _userManagementService.ApproveUserAsync(userId, true);

        // Assert
        result.Should().BeFalse();
    }

    [Fact]
    public async Task ApproveUserAsync_UpdatesUserStatus()
    {
        // Arrange
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };

        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        await _userManagementService.ApproveUserAsync(userId, true);

        // Assert
        _mockUserRepository.Verify(
            r => r.UpdateAsync(It.Is<User>(u => u.Id == userId && u.Status == "approved"), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }

    [Fact]
    public async Task ApproveUserAsync_SetStatusToRejectedWhenApprovedIsFalse()
    {
        // Arrange
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };

        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        await _userManagementService.ApproveUserAsync(userId, false);

        // Assert
        _mockUserRepository.Verify(
            r => r.UpdateAsync(It.Is<User>(u => u.Id == userId && u.Status == "rejected"), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }

    [Fact]
    public async Task GetPendingUsersAsync_ReturnsPendingUsers()
    {
        // Arrange
        var pendingUsers = new List<User>
        {
            new User { Id = "user1", Username = "user1", Email = "user1@example.com", Status = "pending", Role = "user" },
            new User { Id = "user2", Username = "user2", Email = "user2@example.com", Status = "pending", Role = "user" }
        };

        _mockUserRepository.Setup(r => r.GetPendingUsersAsync(default))
            .ReturnsAsync(pendingUsers);

        // Act
        var result = await _userManagementService.GetPendingUsersAsync();

        // Assert
        result.Should().HaveCount(2);
        result.Should().AllSatisfy(u => u.Status.Should().Be("pending"));
    }

    [Fact]
    public async Task GetPendingUsersAsync_ReturnsEmptyListWhenNoPendingUsers()
    {
        // Arrange
        var emptyList = new List<User>();

        _mockUserRepository.Setup(r => r.GetPendingUsersAsync(default))
            .ReturnsAsync(emptyList);

        // Act
        var result = await _userManagementService.GetPendingUsersAsync();

        // Assert
        result.Should().BeEmpty();
    }

    [Fact]
    public async Task RegisterAsync_SetsInitialStatusToPending()
    {
        // Arrange
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";

        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));

        // Act
        var result = await _userManagementService.RegisterAsync(registerRequest);

        // Assert
        result.Status.Should().Be("pending");
    }
}
</file>

<file path="API_DOCUMENTATION.md">
# DnD Map Builder API Documentation

## Overview

This API provides endpoints for managing D&D campaigns, missions, maps, and tokens with JWT-based authentication.

## Base URL

- Development: `https://localhost:5001`
- Production: Update according to your deployment

## Authentication

All endpoints except `/api/auth/register` and `/api/auth/login` require authentication.

### How to Authenticate

1. Register a new user or login
2. Copy the `token` from the response
3. Include it in the `Authorization` header: `Bearer <token>`

Example:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

## API Endpoints

### Authentication

#### Register

```http
POST /api/auth/register
Content-Type: application/json

{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "SecurePassword123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": "user-id",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user",
    "status": "pending"
  },
  "message": "Registration successful. Awaiting admin approval."
}
```

**Note:** New users require admin approval before they can access protected resources.

#### Login

```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "SecurePassword123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": "user-id",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user",
    "status": "approved"
  },
  "message": "Login successful."
}
```

#### Get Pending Users (Admin Only)

```http
GET /api/auth/pending-users
Authorization: Bearer <admin-token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "user-id",
      "username": "new_user",
      "email": "newuser@example.com",
      "role": "user",
      "status": "pending"
    }
  ]
}
```

#### Approve User (Admin Only)

```http
POST /api/auth/approve-user
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "userId": "user-id",
  "approved": true
}
```

### Campaigns

#### Get All User Campaigns

```http
GET /api/campaigns
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "campaign-id",
      "name": "Lost Mines of Phandelver",
      "description": "A classic D&D adventure",
      "missions": [...],
      "ownerId": "user-id",
      "createdAt": "2024-01-15T10:30:00Z",
      "updatedAt": "2024-01-15T10:30:00Z"
    }
  ]
}
```

#### Get Campaign by ID

```http
GET /api/campaigns/{id}
Authorization: Bearer <token>
```

#### Create Campaign

```http
POST /api/campaigns
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Curse of Strahd",
  "description": "A gothic horror adventure in Barovia"
}
```

#### Update Campaign

```http
PUT /api/campaigns/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Curse of Strahd - Updated",
  "description": "Updated description"
}
```

#### Delete Campaign

```http
DELETE /api/campaigns/{id}
Authorization: Bearer <token>
```

### Missions

#### Get Mission by ID

```http
GET /api/missions/{id}
Authorization: Bearer <token>
```

#### Get Missions by Campaign

```http
GET /api/missions/campaign/{campaignId}
Authorization: Bearer <token>
```

#### Create Mission

```http
POST /api/missions
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Village of Barovia",
  "description": "Explore the mysterious village",
  "campaignId": "campaign-id"
}
```

#### Update Mission

```http
PUT /api/missions/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Village of Barovia - Updated",
  "description": "Updated description"
}
```

#### Delete Mission

```http
DELETE /api/missions/{id}
Authorization: Bearer <token>
```

### Maps

#### Get Map by ID

```http
GET /api/maps/{id}
Authorization: Bearer <token>
```

**Response includes all placed tokens on the map.**

#### Get Maps by Mission

```http
GET /api/maps/mission/{missionId}
Authorization: Bearer <token>
```

#### Create Map

```http
POST /api/maps
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Tavern Interior",
  "imageUrl": "https://example.com/tavern.jpg",
  "rows": 20,
  "cols": 30,
  "gridColor": "#000000",
  "gridOpacity": 0.3,
  "missionId": "mission-id"
}
```

#### Update Map (Including Tokens)

```http
PUT /api/maps/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Tavern Interior - Night",
  "imageUrl": "https://example.com/tavern-night.jpg",
  "rows": 20,
  "cols": 30,
  "tokens": [
    {
      "tokenId": "token-definition-id",
      "x": 5,
      "y": 10
    },
    {
      "tokenId": "another-token-id",
      "x": 15,
      "y": 8
    }
  ],
  "gridColor": "#000000",
  "gridOpacity": 0.5
}
```

**Note:** The tokens array replaces all existing tokens on the map.

#### Delete Map

```http
DELETE /api/maps/{id}
Authorization: Bearer <token>
```

### Token Definitions

#### Get All User Tokens

```http
GET /api/tokens
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "token-id",
      "name": "Warrior",
      "imageUrl": "https://example.com/warrior.png",
      "size": 1,
      "type": "player",
      "userId": "user-id"
    }
  ]
}
```

#### Get Token by ID

```http
GET /api/tokens/{id}
Authorization: Bearer <token>
```

#### Create Token

```http
POST /api/tokens
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Dragon",
  "imageUrl": "https://example.com/dragon.png",
  "size": 3,
  "type": "enemy"
}
```

**Token Sizes:**
- `1`: 1x1 grid square (Medium creature)
- `2`: 2x2 grid squares (Large creature)
- `3`: 3x3 grid squares (Huge creature)

**Token Types:**
- `player`: Player character or ally
- `enemy`: Enemy or monster

#### Update Token

```http
PUT /api/tokens/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Ancient Dragon",
  "imageUrl": "https://example.com/ancient-dragon.png",
  "size": 3,
  "type": "enemy"
}
```

#### Delete Token

```http
DELETE /api/tokens/{id}
Authorization: Bearer <token>
```

**Note:** Deleting a token definition does not remove it from existing maps.

## Error Responses

### 400 Bad Request
```json
{
  "success": false,
  "data": null,
  "message": "Validation error or bad request",
  "errors": ["Error detail 1", "Error detail 2"]
}
```

### 401 Unauthorized
```json
{
  "success": false,
  "data": null,
  "message": "Invalid credentials or account not approved."
}
```

### 403 Forbidden
```json
{
  "success": false,
  "data": null,
  "message": "You don't have permission to perform this action."
}
```

### 404 Not Found
```json
{
  "success": false,
  "data": null,
  "message": "Resource not found."
}
```

### 500 Internal Server Error
```json
{
  "success": false,
  "data": null,
  "message": "An internal error occurred."
}
```

## Data Models

### User
```typescript
{
  id: string;
  username: string;
  email: string;
  role: "admin" | "user";
  status: "pending" | "approved" | "rejected";
}
```

### Campaign
```typescript
{
  id: string;
  name: string;
  description: string;
  missions: Mission[];
  ownerId: string;
  createdAt: string; // ISO 8601
  updatedAt: string; // ISO 8601
}
```

### Mission
```typescript
{
  id: string;
  name: string;
  description: string;
  maps: GameMap[];
  campaignId: string;
}
```

### GameMap
```typescript
{
  id: string;
  name: string;
  imageUrl: string | null;
  rows: number;
  cols: number;
  tokens: MapTokenInstance[];
  gridColor: string; // Hex color
  gridOpacity: number; // 0.0 - 1.0
  missionId: string;
}
```

### TokenDefinition
```typescript
{
  id: string;
  name: string;
  imageUrl: string;
  size: 1 | 2 | 3;
  type: "player" | "enemy";
  userId: string;
}
```

### MapTokenInstance
```typescript
{
  instanceId: string;
  tokenId: string; // References TokenDefinition
  x: number;
  y: number;
}
```

## Rate Limiting

Currently, no rate limiting is implemented. Consider adding rate limiting in production.

## CORS

CORS is configured to allow all origins in development. Update CORS policy for production deployment.

## Versioning

Current API version: v1

Future versions will be accessible via `/api/v2/...`
</file>

<file path="DEPLOYMENT.md">
# Deployment Runbook

## Overview

This runbook documents the procedures, checklists, and strategies for deploying DnDMapBuilder API to production and staging environments.

## Pre-Deployment Checklist

### Code and Build
- [ ] All tests passing: `dotnet test`
- [ ] Build succeeding: `dotnet build --configuration Release`
- [ ] No compiler warnings
- [ ] Code review completed and approved
- [ ] All changes merged to main branch
- [ ] Version bumped (semantic versioning)

### Security
- [ ] No vulnerable dependencies: `dotnet list package --vulnerable`
- [ ] Secrets not in source code
- [ ] CORS origins configured for target environment
- [ ] Security headers configured
- [ ] Rate limiting policies appropriate
- [ ] Authentication/authorization tests passing

### Database
- [ ] Database migrations tested locally
- [ ] Backup created before migration
- [ ] Rollback plan documented
- [ ] Data consistency verified

### Infrastructure
- [ ] Target environment verified (staging/production)
- [ ] Database connection string verified
- [ ] Key Vault secrets configured
- [ ] Health check endpoints responding
- [ ] Monitoring and logging configured

### Documentation
- [ ] Release notes prepared
- [ ] Breaking changes documented
- [ ] Migration guide prepared (if applicable)
- [ ] Runbook reviewed

## Deployment Steps

### Phase 1: Pre-Deployment (30 minutes)

1. **Create deployment ticket**
   - Document deployment date/time
   - List changes and version
   - Assign responsible engineer

2. **Verify environment readiness**
   ```bash
   # Check target environment
   docker ps -a
   docker network ls
   
   # Verify services
   curl https://api.example.com/health
   
   # Check logs
   docker logs dnd-api
   ```

3. **Take database backup**
   ```bash
   # SQL Server backup
   docker exec -it dnd-db sqlcmd -S localhost -U sa \
     -P $SA_PASSWORD \
     -Q "BACKUP DATABASE [DnDMapBuilder] \
         TO DISK = '/var/opt/mssql/backup/pre-deployment.bak'"
   ```

4. **Notify stakeholders**
   - Post deployment notification to Slack/Teams
   - Set deployment status page to "In Progress"
   - Alert support team of potential service interruption

### Phase 2: Application Deployment (15-30 minutes)

#### Option A: Docker Compose (Single Host)

```bash
# 1. Navigate to deployment directory
cd ~/dnd-deployment

# 2. Pull latest image
docker pull ghcr.io/yourorg/dnd-api:latest

# 3. Stop current container
docker-compose down

# 4. Start new container
docker-compose up -d

# 5. Verify startup
sleep 10
docker logs dnd-api | tail -20
```

#### Option B: Kubernetes (Production)

```bash
# 1. Update image version in deployment
kubectl set image deployment/dnd-api \
  dnd-api=ghcr.io/yourorg/dnd-api:v1.2.3

# 2. Monitor rollout
kubectl rollout status deployment/dnd-api

# 3. Verify pods running
kubectl get pods -l app=dnd-api

# 4. Check logs
kubectl logs -l app=dnd-api -f
```

#### Option C: Azure App Service

```bash
# 1. Deploy using Azure CLI
az webapp deployment source config-zip \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --src-path release.zip

# 2. Monitor deployment
az webapp deployment slot show \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --slot staging

# 3. Swap slots when ready
az webapp deployment slot swap \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --slot staging
```

### Phase 3: Database Migration (10-20 minutes)

If database schema changes exist:

```bash
# 1. Run migrations
docker exec -it dnd-api \
  dotnet ef database update --context DnDMapBuilderDbContext

# 2. Verify migration
docker exec -it dnd-api \
  dotnet ef migrations list --context DnDMapBuilderDbContext

# 3. Check database state
docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
  -Q "SELECT TOP 5 * FROM dbo.Users"
```

### Phase 4: Post-Deployment Verification (15-20 minutes)

1. **Health Check**
   ```bash
   curl https://api.example.com/health
   curl https://api.example.com/health/ready
   curl https://api.example.com/health/live
   ```

2. **Smoke Tests**
   - Login endpoint: `curl -X POST https://api.example.com/api/v1/auth/login`
   - Get user data: `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/api/v1/campaigns`
   - Create resource: Test campaign creation
   - File upload: Test image upload
   - Rate limiting: Verify 429 responses

3. **Monitor Metrics**
   ```bash
   # Check application logs
   docker logs -f dnd-api
   
   # Check error rate
   curl https://api.example.com/metrics | grep http_requests_total
   
   # Check performance
   kubectl top pod -l app=dnd-api  # Kubernetes
   ```

4. **Database Consistency**
   ```bash
   # Check record counts
   docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
     -Q "SELECT COUNT(*) FROM Users; SELECT COUNT(*) FROM Campaigns;"
   ```

## Rollback Procedure

If issues occur during or after deployment:

### Quick Rollback (< 2 minutes)

```bash
# Docker Compose
docker-compose down
git checkout previous-tag
docker-compose up -d

# Kubernetes
kubectl rollout undo deployment/dnd-api

# Azure App Service
az webapp deployment slot swap \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --slot staging
```

### Database Rollback (if needed)

```bash
# SQL Server restore
docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
  -Q "RESTORE DATABASE [DnDMapBuilder] \
      FROM DISK = '/var/opt/mssql/backup/pre-deployment.bak' \
      WITH REPLACE"

# Verify database
docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
  -Q "SELECT @@VERSION"
```

### Notification After Rollback

- Post incident notification to Slack/Teams
- Document root cause
- Create ticket for issue resolution
- Plan re-deployment

## Environment-Specific Procedures

### Staging Deployment

```bash
# Deploy to staging for validation
git push origin develop

# Automated deployment via GitHub Actions
# Verify health: https://staging-api.example.com/health

# Run extended smoke tests
./scripts/smoke_tests.sh https://staging-api.example.com

# If tests pass, proceed to production
```

### Production Deployment

```bash
# Merge develop to main
git push origin develop:main

# Wait for automated deployment
# Verify all post-deployment checks
# Monitor for 24 hours

# If issues arise, execute rollback
```

## Monitoring Post-Deployment

### First Hour
- Monitor error rates in real-time
- Check for exceptions in logs
- Verify performance metrics
- Monitor database queries

### First Day
- Check for memory leaks
- Verify all endpoints responding
- Monitor rate limiting effectiveness
- Check for security events

### First Week
- Review error trends
- Analyze performance metrics
- Check for regressions
- Verify telemetry collection

## Incident Response During Deployment

### If deployment fails to complete

1. **Assess severity**
   - Is service down or degraded?
   - Are users affected?
   - Can it be fixed quickly?

2. **Immediate action**
   - If critical: Execute rollback immediately
   - If minor: Continue investigation

3. **Investigation**
   - Check logs: `docker logs dnd-api`
   - Check database: Verify connection
   - Check infrastructure: Resource availability
   - Check dependencies: External services

4. **Communication**
   - Update status page
   - Notify stakeholders
   - Post incident channel updates
   - Document timeline

### If health checks fail

1. Verify network connectivity
2. Check service startup logs
3. Verify configuration files
4. Check database connectivity
5. Execute rollback if unable to resolve quickly

### If performance degrades

1. Check memory usage
2. Monitor CPU utilization
3. Analyze slow queries
4. Check rate limiting
5. Scale infrastructure if necessary

## Post-Deployment Reporting

### Deployment Report Template

```
Deployment Report - [Date]

Deployment Details:
- Version: [Version number]
- Environment: [staging/production]
- Start time: [Time]
- End time: [Time]
- Duration: [Minutes]

Changes Deployed:
- [List of features/fixes]

Pre-Deployment Checks:
- [✓] Tests passing
- [✓] Security audit passed
- [✓] Database backup created

Post-Deployment Results:
- [✓] Health checks passing
- [✓] Smoke tests passed
- [✓] Performance acceptable

Issues Encountered:
- None

Verification:
- [✓] Endpoints responding
- [✓] Authentication working
- [✓] File uploads functional
- [✓] Rate limiting active

Rollback Status:
- Not required

Signed off by: [Name]
Date: [Date]
```

## Deployment Automation

### GitHub Actions Workflow

```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Build Docker image
        run: docker build -t dnd-api:${{ github.sha }} .
      
      - name: Push to registry
        run: docker push dnd-api:${{ github.sha }}
      
      - name: Deploy to production
        run: |
          # Deploy commands
          docker pull dnd-api:${{ github.sha }}
          docker-compose up -d
      
      - name: Run smoke tests
        run: ./scripts/smoke_tests.sh
      
      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
```

## Disaster Recovery

### Database Corruption

1. Restore from latest backup
2. Verify data consistency
3. Run integrity checks
4. Monitor for anomalies

### Complete Service Failure

1. Execute rollback procedure
2. Restore from backup
3. Verify service startup
4. Run full smoke test suite

### Data Loss Scenario

1. Restore from backup (ideally < 1 hour old)
2. Verify backup integrity
3. Communicate to users about data recovery
4. Monitor for issues

## References

- [ASP.NET Core Deployment](https://learn.microsoft.com/aspnet/core/host-and-deploy/)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Kubernetes Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
- [Incident Response](https://www.atlassian.com/incident-management)
</file>

<file path="dotnet-tools.json">
{
  "version": 1,
  "isRoot": true,
  "tools": {
    "dotnet-ef": {
      "version": "10.0.2",
      "commands": [
        "dotnet-ef"
      ],
      "rollForward": false
    }
  }
}
</file>

<file path="FILE_STRUCTURE.md">
# DnD Map Builder - Complete File Structure

## Solution Structure

```
DnDMapBuilder/
│
├── DnDMapBuilder.sln                      # Visual Studio Solution File
├── .gitignore                             # Git ignore patterns
├── docker-compose.yml                     # Docker Compose configuration
├── setup.sh                               # Quick setup script (chmod +x)
│
├── README.md                              # Main documentation
├── QUICKSTART.md                          # Quick start guide
├── API_DOCUMENTATION.md                   # Complete API reference
├── PROJECT_SUMMARY.md                     # Project overview
├── FILE_STRUCTURE.md                      # This file
│
└── src/                                   # Source code directory
    │
    ├── DnDMapBuilder.Contracts/           # DTO & Contract Layer
    │   ├── DnDMapBuilder.Contracts.csproj
    │   ├── DTOs/
    │   │   └── DomainDtos.cs             # Campaign, Mission, Map, Token DTOs
    │   ├── Requests/
    │   │   └── ApiRequests.cs            # Create/Update request models
    │   └── Responses/
    │       └── ApiResponses.cs           # API response wrappers
    │
    ├── DnDMapBuilder.Data/                # Data Access Layer
    │   ├── DnDMapBuilder.Data.csproj
    │   ├── DnDMapBuilderDbContext.cs     # EF Core DbContext
    │   ├── Entities/
    │   │   └── DomainEntities.cs         # Database entities (User, Campaign, etc.)
    │   └── Repositories/
    │       ├── IRepositories.cs          # Repository interfaces
    │       └── Repositories.cs           # Repository implementations
    │
    ├── DnDMapBuilder.Application/         # Business Logic Layer
    │   ├── DnDMapBuilder.Application.csproj
    │   ├── Interfaces/
    │   │   └── IServices.cs              # Service interfaces
    │   ├── Mappings/
    │   │   └── MappingExtensions.cs      # Entity to DTO mappings
    │   └── Services/
    │       ├── AuthService.cs            # Authentication & user management
    │       ├── CampaignService.cs        # Campaign operations
    │       ├── MissionService.cs         # Mission operations
    │       ├── GameMapAndTokenServices.cs # Map & token operations
    │       └── JwtService.cs             # JWT token generation/validation
    │
    ├── DnDMapBuilder.Api/                 # Web API Layer
    │   ├── DnDMapBuilder.Api.csproj
    │   ├── Program.cs                    # Application entry point & DI configuration
    │   ├── Dockerfile                    # Docker image definition
    │   ├── appsettings.json              # Application configuration
    │   ├── appsettings.Development.json  # Development configuration
    │   ├── Controllers/
    │   │   ├── AuthController.cs         # /api/auth endpoints
    │   │   ├── CampaignsController.cs    # /api/campaigns endpoints
    │   │   └── OtherControllers.cs       # Missions, Maps, Tokens endpoints
    │   └── Properties/
    │       └── launchSettings.json       # Launch profiles (HTTP/HTTPS)
    │
    ├── DnDMapBuilder.Aspire.AppHost/      # Aspire Orchestration
    │   ├── DnDMapBuilder.Aspire.AppHost.csproj
    │   └── Program.cs                    # Aspire app host configuration
    │
    └── DnDMapBuilder.Aspire.ServiceDefaults/ # Aspire Shared Services
        ├── DnDMapBuilder.Aspire.ServiceDefaults.csproj
        └── Extensions.cs                 # OpenTelemetry & health checks
```

## File Descriptions

### Root Level

- **DnDMapBuilder.sln**: Visual Studio solution file that references all projects
- **.gitignore**: Specifies files/folders to ignore in version control
- **docker-compose.yml**: Docker Compose configuration for SQL Server + API
- **setup.sh**: Bash script for quick project setup (make executable with `chmod +x`)

### Documentation Files

- **README.md**: Complete setup instructions and project overview
- **QUICKSTART.md**: Fast setup guide with minimal steps
- **API_DOCUMENTATION.md**: Full API endpoint reference with examples
- **PROJECT_SUMMARY.md**: Architecture overview and technology stack

### Source Projects

#### 1. DnDMapBuilder.Contracts (No Dependencies)
**Purpose**: Define data contracts used across all layers

- `DTOs/DomainDtos.cs`: Data transfer objects for all domain models
- `Requests/ApiRequests.cs`: Request models for API endpoints
- `Responses/ApiResponses.cs`: Standardized response wrappers

#### 2. DnDMapBuilder.Data (Depends on: None)
**Purpose**: Database access and entity definitions

- `DnDMapBuilderDbContext.cs`: EF Core database context with configuration
- `Entities/DomainEntities.cs`: Database entity classes (User, Campaign, Mission, GameMap, TokenDefinition, MapTokenInstance)
- `Repositories/IRepositories.cs`: Repository interface definitions
- `Repositories/Repositories.cs`: Concrete repository implementations with EF Core

**Key Features**:
- Entity relationships configured with Fluent API
- Repository pattern for data access abstraction
- Seeded admin user for initial setup

#### 3. DnDMapBuilder.Application (Depends on: Contracts, Data)
**Purpose**: Business logic and service layer

- `Interfaces/IServices.cs`: Service contracts (IAuthService, ICampaignService, etc.)
- `Mappings/MappingExtensions.cs`: Extension methods for Entity→DTO conversion
- `Services/AuthService.cs`: User registration, login, approval workflow
- `Services/JwtService.cs`: JWT token generation and validation
- `Services/CampaignService.cs`: Campaign CRUD operations
- `Services/MissionService.cs`: Mission CRUD operations
- `Services/GameMapAndTokenServices.cs`: Map and token CRUD operations

**Key Features**:
- User ownership validation
- Role-based authorization checks
- Password hashing with BCrypt
- JWT token management

#### 4. DnDMapBuilder.Api (Depends on: Application, Contracts, Data)
**Purpose**: REST API endpoints and HTTP handling

- `Program.cs`: Application startup, DI container configuration, middleware pipeline
- `Controllers/AuthController.cs`: Authentication endpoints
- `Controllers/CampaignsController.cs`: Campaign management endpoints
- `Controllers/OtherControllers.cs`: Missions, Maps, and Tokens endpoints
- `appsettings.json`: Database connection, JWT settings
- `Dockerfile`: Multi-stage Docker build definition

**Key Features**:
- JWT Bearer authentication
- Swagger/OpenAPI documentation
- CORS configuration
- Automatic database migration on startup

#### 5. DnDMapBuilder.Aspire.AppHost (Depends on: Api, ServiceDefaults)
**Purpose**: Local development orchestration

- `Program.cs`: Configure SQL Server and API containers

**Features**:
- SQL Server container with persistent volume
- Automatic service discovery
- Health check monitoring
- Aspire dashboard

#### 6. DnDMapBuilder.Aspire.ServiceDefaults (No Dependencies)
**Purpose**: Shared Aspire configuration

- `Extensions.cs`: OpenTelemetry, health checks, service discovery

## Total File Count

- **C# Project Files**: 6
- **C# Source Files**: 19
- **Configuration Files**: 5
- **Documentation Files**: 5
- **Docker Files**: 2
- **Scripts**: 1

**Total**: 38 files

## File Sizes (Approximate)

- Total solution size: ~115 KB (code only)
- Largest file: `Repositories.cs` (~6 KB)
- Average file size: ~3 KB

## Technology Stack by Project

### DnDMapBuilder.Contracts
- .NET 9.0
- No external dependencies

### DnDMapBuilder.Data
- .NET 9.0
- Entity Framework Core 9.0
- SQL Server provider

### DnDMapBuilder.Application
- .NET 9.0
- BCrypt.Net-Next
- System.IdentityModel.Tokens.Jwt

### DnDMapBuilder.Api
- ASP.NET Core 9.0
- JWT Bearer Authentication
- Swashbuckle (Swagger)
- Entity Framework Core Design Tools

### Aspire Projects
- .NET 9.0
- Aspire.Hosting
- OpenTelemetry

## Quick Navigation

| Task | File to Modify |
|------|---------------|
| Add new API endpoint | `src/DnDMapBuilder.Api/Controllers/` |
| Add business logic | `src/DnDMapBuilder.Application/Services/` |
| Add database entity | `src/DnDMapBuilder.Data/Entities/DomainEntities.cs` |
| Add repository method | `src/DnDMapBuilder.Data/Repositories/` |
| Change DB schema | `src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs` |
| Add DTO | `src/DnDMapBuilder.Contracts/DTOs/` |
| Configure JWT | `src/DnDMapBuilder.Api/appsettings.json` |
| Change connection string | `src/DnDMapBuilder.Api/appsettings.json` |
| Modify Aspire setup | `src/DnDMapBuilder.Aspire.AppHost/Program.cs` |

## Missing Files (By Design)

The following are **NOT** included as they're generated/downloaded:
- `bin/` and `obj/` directories (build output)
- `packages/` directory (NuGet packages)
- `.vs/` directory (Visual Studio cache)
- `*.user` files (user-specific settings)
- Database migration files (generate with EF Core tools)
- `node_modules/` (not applicable for this project)

## Next Steps After Download

1. Extract the ZIP file
2. Navigate to the `DnDMapBuilder` directory
3. Choose a run method:
   - Aspire: Run `setup.sh` and select option 1
   - Docker: Run `docker-compose up`
   - Direct: Configure SQL Server and run `dotnet run`
4. Access Swagger UI to test the API

## Verifying the Structure

Run this command in the root directory to verify all files are present:

```bash
find . -name "*.csproj" | wc -l  # Should show 6
find . -name "*.cs" | wc -l      # Should show 19
```

## Support Files

All necessary support files are included:
- ✅ Solution file (.sln)
- ✅ Project files (.csproj)
- ✅ Configuration files (appsettings.json, launchSettings.json)
- ✅ Docker files (Dockerfile, docker-compose.yml)
- ✅ Documentation (4 markdown files)
- ✅ Setup script (setup.sh)
- ✅ Git ignore (.gitignore)

The solution is **complete and ready to build**!
</file>

<file path="generate-certs.sh">
#!/bin/bash

# Create certs directory if it doesn't exist
mkdir -p certs

# Generate self-signed certificate for .NET API
echo "Generating self-signed certificate for .NET API..."
openssl req -x509 -newkey rsa:4096 -keyout certs/aspnetapp.key -out certs/aspnetapp.crt \
  -days 365 -nodes -subj "/CN=localhost" -addext "subjectAltName=DNS:localhost,DNS:dnd-api"

# Convert to PFX format (required by .NET)
openssl pkcs12 -export -in certs/aspnetapp.crt -inkey certs/aspnetapp.key \
  -out certs/aspnetapp.pfx -name aspnetapp -passout pass:crypticpassword

echo "✓ Generated aspnetapp.pfx"
echo "Certificate location: certs/aspnetapp.pfx"
echo ""
</file>

<file path="LOAD_TESTING.md">
# Load Testing and Performance Validation Guide

## Overview

This guide provides load testing strategies and performance benchmarks for the DnDMapBuilder API. Load testing helps identify bottlenecks, validate rate limiting, and ensure the API can handle expected and peak loads.

## Load Testing Tools

### Recommended Tools

1. **k6** (JavaScript-based, cloud-native)
   - Easy to write tests in JavaScript
   - Real-time results
   - Cloud execution for distributed load
   - Excellent metrics and visualization

2. **Apache JMeter** (Java-based, GUI)
   - Enterprise standard
   - Good for complex scenarios
   - Built-in reporting
   - Large community

3. **Apache Bench (ab)** (Simple, CLI)
   - Quick and simple
   - Good for baseline testing
   - Limited features

### Installation

#### k6
```bash
# macOS
brew install k6

# Linux
sudo apt-get install k6

# Windows (via Chocolatey)
choco install k6
```

#### JMeter
```bash
# macOS
brew install jmeter

# Download from https://jmeter.apache.org/download_jmeter.html
```

## Test Scenarios

### Scenario 1: Authentication Load Test

**Objective:** Validate login endpoint under sustained load

**Test Profile:**
- Duration: 2 minutes
- Ramp-up: 30 seconds to 100 concurrent users
- Steady state: 100 users for 1.5 minutes
- Ramp-down: 30 seconds

**Expected Metrics:**
- Response time p95: < 500ms
- Response time p99: < 1000ms
- Error rate: < 0.1%
- Throughput: > 50 requests/sec

**k6 Script:**
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '30s', target: 100 },
    { duration: '1m30s', target: 100 },
    { duration: '30s', target: 0 },
  ],
  thresholds: {
    http_req_duration: ['p(95)<500', 'p(99)<1000'],
    http_req_failed: ['rate<0.01'],
  },
};

const BASE_URL = 'http://localhost:5000/api/v1';

export default function() {
  const loginPayload = JSON.stringify({
    email: `user${Math.floor(Math.random() * 1000)}@example.com`,
    password: 'TestPassword123!',
  });

  const response = http.post(`${BASE_URL}/auth/login`, loginPayload, {
    headers: { 'Content-Type': 'application/json' },
  });

  check(response, {
    'login status is 200 or 401': (r) => r.status === 200 || r.status === 401,
  });

  sleep(1);
}
```

### Scenario 2: CRUD Operations Load Test

**Objective:** Validate campaign CRUD operations under load

**Test Profile:**
- Duration: 3 minutes
- Ramp-up: 1 minute to 50 concurrent users
- Steady state: 50 users for 1.5 minutes
- Ramp-down: 30 seconds
- Mix: 40% GET, 30% POST, 20% PUT, 10% DELETE

**Expected Metrics:**
- Response time p95: < 300ms
- Response time p99: < 700ms
- Error rate: < 0.5%
- Throughput: > 30 requests/sec

### Scenario 3: File Upload Load Test

**Objective:** Validate file upload performance under concurrent uploads

**Test Profile:**
- Duration: 2 minutes
- Concurrent users: 10 (limited by file upload rate limit)
- File size: 1-3MB images
- Expected: Hits rate limit at ~10 requests/minute

**Expected Metrics:**
- Response time p95: < 2 seconds (includes file I/O)
- Error rate: < 1% (429 status acceptable)
- Rate limit compliance: 100% at > 10 req/min

### Scenario 4: Sustained Load Test

**Objective:** Validate API stability under 8-hour sustained load

**Test Profile:**
- Duration: 8 hours
- Concurrent users: 50 (constant)
- Think time: 1-2 seconds between requests
- Request mix: 60% GET, 20% POST, 15% PUT, 5% DELETE

**Expected Metrics:**
- No memory leaks (stable memory usage)
- Response time degradation: < 10% over 8 hours
- Error rate: < 0.1%
- Database connection pool stable

### Scenario 5: Spike Load Test

**Objective:** Validate API behavior during sudden traffic spikes

**Test Profile:**
- Baseline: 10 concurrent users
- Spike: Increase to 500 concurrent users in 10 seconds
- Hold: Maintain for 2 minutes
- Return to baseline

**Expected Metrics:**
- Response time p99 during spike: < 2000ms
- Error rate during spike: < 5%
- Recovery: Return to normal response times within 1 minute

## Performance Benchmarks

### Target Metrics

| Metric | Target | Acceptable | Warning |
|--------|--------|-----------|---------|
| Response Time (p50) | < 100ms | < 200ms | > 200ms |
| Response Time (p95) | < 300ms | < 500ms | > 500ms |
| Response Time (p99) | < 500ms | < 1000ms | > 1000ms |
| Error Rate | < 0.1% | < 0.5% | > 0.5% |
| Throughput | > 100 req/s | > 50 req/s | < 50 req/s |
| CPU Utilization | < 60% | < 80% | > 80% |
| Memory Utilization | < 60% | < 80% | > 80% |
| Database Connection Pool | < 80% utilized | < 90% utilized | > 90% utilized |

## Running Load Tests

### Using k6

```bash
# Basic run
k6 run load_test.js

# With output file
k6 run load_test.js --out csv=results.csv

# Cloud execution (requires k6 Cloud account)
k6 cloud load_test.js

# With custom environment
k6 run -e BASE_URL=https://api.production.com load_test.js
```

### Using Apache JMeter

```bash
# Interactive GUI
jmeter -t load_test.jmx

# Headless (command line)
jmeter -n -t load_test.jmx -l results.jtl -j jmeter.log

# Generate HTML report
jmeter -g results.jtl -o report/
```

## Performance Optimization Recommendations

### Based on Load Test Results

**If response times > target:**
1. Check database query performance (use query analyzer)
2. Add caching for frequently accessed data
3. Implement pagination for large result sets
4. Consider read replicas for database scaling
5. Review middleware performance (remove unnecessary middleware)
6. Profile application code for hotspots

**If error rate > acceptable:**
1. Review error logs for specific failure modes
2. Increase database connection pool size
3. Add circuit breaker for external dependencies
4. Implement request queuing/backpressure
5. Scale horizontally (add more instances)

**If memory usage increases:**
1. Profile for memory leaks
2. Review logging configuration (excessive log data)
3. Check for unbounded collections
4. Verify connection pool cleanup
5. Monitor garbage collection frequency

**If CPU usage high:**
1. Profile CPU-intensive operations
2. Review encryption/hashing operations
3. Check for tight loops
4. Consider async operations where applicable
5. Profile LINQ query compilation

## Continuous Load Testing

### CI/CD Integration

Add to GitHub Actions workflow:

```yaml
name: Load Testing

on:
  schedule:
    - cron: '0 2 * * 0'  # Weekly at 2 AM UTC

jobs:
  load-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Install k6
        run: sudo apt-get install k6
      
      - name: Start API
        run: |
          docker-compose up -d
          sleep 10
      
      - name: Run Load Tests
        run: k6 run load_tests/auth_load_test.js
      
      - name: Upload Results
        uses: actions/upload-artifact@v2
        with:
          name: load-test-results
          path: results/
```

## Monitoring During Load Tests

### Metrics to Monitor

**Application Level:**
- CPU and Memory usage
- Request rate (requests/sec)
- Response times (p50, p95, p99)
- Error rate
- Active connections

**Database Level:**
- Query execution time
- Connection pool utilization
- Deadlock occurrences
- I/O operations

**Infrastructure Level:**
- Network bandwidth
- Disk I/O
- System load
- Available resources

### Tools

- **Grafana:** Real-time metrics visualization
- **Prometheus:** Metrics collection
- **Application Insights:** Azure integrated monitoring
- **DataDog:** Enterprise monitoring
- **New Relic:** APM and monitoring

## Load Test Results Documentation

### Standard Report Includes

1. **Executive Summary**
   - Test date and duration
   - Peak concurrent users
   - Overall pass/fail status

2. **Key Metrics**
   - Response time statistics (min, max, avg, p50, p95, p99)
   - Throughput (requests/sec)
   - Error rate and error types
   - Resource utilization (CPU, Memory, Disk)

3. **Scenario Results**
   - Per-scenario performance
   - Any threshold violations
   - Anomalies or unexpected behavior

4. **Analysis**
   - Bottleneck identification
   - Performance trends
   - Comparison to previous tests

5. **Recommendations**
   - Optimization opportunities
   - Configuration adjustments
   - Infrastructure scaling needs

## Baseline Metrics

### Initial Deployment (Single Instance)

Record baseline metrics for comparison:

```
Configuration: 
- 1 API instance (2 vCPU, 4GB RAM)
- 1 SQL Server instance (2 vCPU, 8GB RAM)

Scenario: 100 concurrent users, 2 minute duration
- Response Time p50: 89ms
- Response Time p95: 234ms
- Response Time p99: 456ms
- Error Rate: 0.02%
- Throughput: 85 requests/sec
- CPU (API): 42%
- Memory (API): 512MB
- Database Connections: 12/50
```

## Maintenance and Review

- **Monthly:** Review baselines against current performance
- **Quarterly:** Full regression load testing
- **Before Major Release:** Comprehensive load testing
- **After Infrastructure Changes:** Re-baseline metrics
- **Performance Regression:** Immediate investigation

## References

- [k6 Documentation](https://k6.io/docs/)
- [Apache JMeter](https://jmeter.apache.org/usermanual/)
- [Performance Testing Guide](https://www.perfmatrix.com/)
- [Load Testing Best Practices](https://www.thoughtworks.com/insights/blog/load-testing)
</file>

<file path="PROJECT_SUMMARY.md">
# DnD Map Builder - Complete Backend Solution

## 🎯 Project Overview

A full-featured ASP.NET Web API backend for the DnD Map Builder application, implementing user authentication, campaign management, mission planning, map creation, and token management.

## 📁 Solution Structure

```
DnDMapBuilder/
├── src/
│   ├── DnDMapBuilder.Contracts/          # DTOs, Requests, Responses
│   ├── DnDMapBuilder.Data/               # EF Core, Entities, Repositories
│   ├── DnDMapBuilder.Application/        # Business Logic & Services
│   ├── DnDMapBuilder.Api/                # Web API Controllers
│   ├── DnDMapBuilder.Aspire.AppHost/     # Aspire Orchestration
│   └── DnDMapBuilder.Aspire.ServiceDefaults/  # Aspire Service Defaults
├── DnDMapBuilder.sln                     # Solution file
├── docker-compose.yml                    # Docker Compose configuration
├── setup.sh                              # Quick setup script
├── README.md                             # Main documentation
├── API_DOCUMENTATION.md                  # Complete API reference
├── QUICKSTART.md                         # Quick start guide
└── .gitignore
```

## 🏗️ Architecture

### Clean Architecture Pattern

1. **Contracts Layer** (`DnDMapBuilder.Contracts`)
   - DTOs (Data Transfer Objects)
   - Request/Response models
   - API contracts
   - No dependencies on other layers

2. **Data Layer** (`DnDMapBuilder.Data`)
   - Entity Framework Core
   - Database entities
   - DbContext configuration
   - Repository pattern implementation
   - Database migrations

3. **Application Layer** (`DnDMapBuilder.Application`)
   - Business logic
   - Service implementations
   - Mapping extensions
   - JWT service
   - Depends on: Contracts, Data

4. **API Layer** (`DnDMapBuilder.Api`)
   - Controllers
   - Authentication/Authorization
   - Middleware
   - Swagger configuration
   - Depends on: Application, Contracts, Data

5. **Aspire Orchestration** (`DnDMapBuilder.Aspire.*`)
   - Container orchestration
   - Service discovery
   - Health checks
   - Telemetry

## 🔑 Key Features

### Authentication & Authorization
- JWT-based authentication
- Role-based authorization (Admin, User)
- User approval workflow
- Secure password hashing with BCrypt

### Campaign Management
- Create, read, update, delete campaigns
- User-owned campaigns
- Complete campaign hierarchy (Campaign → Mission → Map)

### Mission Management
- Organize missions within campaigns
- Mission descriptions and metadata
- Cascade delete with campaigns

### Map Builder
- Grid-based map system
- Custom map images
- Configurable grid (rows, columns, color, opacity)
- Token placement on maps

### Token Library
- User-specific token definitions
- Token types (player, enemy)
- Token sizes (1x1, 2x2, 3x3 grid squares)
- Image URL support

## 🗄️ Database Schema

### Users
- Id, Username, Email, PasswordHash
- Role (admin/user)
- Status (pending/approved/rejected)
- Timestamps

### Campaigns
- Id, Name, Description
- OwnerId → Users
- Timestamps

### Missions
- Id, Name, Description
- CampaignId → Campaigns

### GameMaps
- Id, Name, ImageUrl
- Rows, Cols, GridColor, GridOpacity
- MissionId → Missions

### TokenDefinitions
- Id, Name, ImageUrl, Size, Type
- UserId → Users

### MapTokenInstances
- Id, TokenId → TokenDefinitions
- MapId → GameMaps
- X, Y coordinates

## 🚀 Deployment Options

### Option 1: .NET Aspire (Recommended)
```bash
cd src/DnDMapBuilder.Aspire.AppHost
dotnet user-secrets set "Parameters:sql-password" "YourPassword"
dotnet run
```

**Advantages:**
- Automatic container orchestration
- Built-in service discovery
- Health monitoring dashboard
- Telemetry and logging
- Development-optimized

### Option 2: Docker Compose
```bash
docker-compose up --build
```

**Advantages:**
- Simple deployment
- Consistent environment
- Easy to share
- Production-ready

### Option 3: Direct Deployment
- Requires SQL Server instance
- Manual configuration
- More control over environment

## 🔐 Security Features

1. **JWT Authentication**
   - Secure token generation
   - Token expiration
   - Role-based claims

2. **Password Security**
   - BCrypt hashing
   - Salt per password
   - Secure password storage

3. **Authorization**
   - Role-based access control
   - User ownership validation
   - Admin-only endpoints

4. **API Security**
   - HTTPS support
   - CORS configuration
   - Input validation

## 📊 API Endpoints Summary

### Authentication (`/api/auth`)
- POST `/register` - Register new user
- POST `/login` - User login
- GET `/pending-users` - Get pending approvals (Admin)
- POST `/approve-user` - Approve/reject user (Admin)

### Campaigns (`/api/campaigns`)
- GET `/` - List user campaigns
- GET `/{id}` - Get campaign details
- POST `/` - Create campaign
- PUT `/{id}` - Update campaign
- DELETE `/{id}` - Delete campaign

### Missions (`/api/missions`)
- GET `/{id}` - Get mission
- GET `/campaign/{campaignId}` - List campaign missions
- POST `/` - Create mission
- PUT `/{id}` - Update mission
- DELETE `/{id}` - Delete mission

### Maps (`/api/maps`)
- GET `/{id}` - Get map with tokens
- GET `/mission/{missionId}` - List mission maps
- POST `/` - Create map
- PUT `/{id}` - Update map and tokens
- DELETE `/{id}` - Delete map

### Tokens (`/api/tokens`)
- GET `/` - List user tokens
- GET `/{id}` - Get token
- POST `/` - Create token
- PUT `/{id}` - Update token
- DELETE `/{id}` - Delete token

## 🛠️ Technology Stack

- **.NET 9.0** - Latest .NET framework
- **ASP.NET Core** - Web API framework
- **Entity Framework Core 9.0** - ORM
- **SQL Server 2022** - Database
- **JWT Bearer** - Authentication
- **BCrypt.Net** - Password hashing
- **Swagger/OpenAPI** - API documentation
- **.NET Aspire** - Cloud-native orchestration
- **Docker** - Containerization

## 📦 NuGet Packages

### API Project
- Microsoft.AspNetCore.Authentication.JwtBearer
- Microsoft.AspNetCore.OpenApi
- Swashbuckle.AspNetCore

### Application Project
- BCrypt.Net-Next
- System.IdentityModel.Tokens.Jwt

### Data Project
- Microsoft.EntityFrameworkCore
- Microsoft.EntityFrameworkCore.SqlServer
- Microsoft.EntityFrameworkCore.Tools

### Aspire Projects
- Aspire.Hosting.AppHost
- Aspire.Hosting.SqlServer
- OpenTelemetry packages

## 🎨 Design Patterns Used

1. **Repository Pattern** - Data access abstraction
2. **Service Layer Pattern** - Business logic separation
3. **Dependency Injection** - Loose coupling
4. **DTO Pattern** - Data transfer optimization
5. **Clean Architecture** - Layer separation
6. **Factory Pattern** - Object creation
7. **Strategy Pattern** - Service implementations

## 🔄 Data Flow

```
Client Request
    ↓
API Controller (Authentication/Authorization)
    ↓
Application Service (Business Logic)
    ↓
Repository (Data Access)
    ↓
Entity Framework Core
    ↓
SQL Server Database
    ↓
Response (via DTOs)
```

## 📝 Default Credentials

**Admin Account** (Pre-seeded):
- Email: `admin@dndmapbuilder.com`
- Password: `Admin123!`
- Role: `admin`
- Status: `approved`

## 🧪 Testing the API

### Using Swagger UI
1. Navigate to `https://localhost:5001/swagger`
2. Login to get a token
3. Click "Authorize" and enter: `Bearer <token>`
4. Test endpoints interactively

### Using cURL
```bash
# Login
curl -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@dndmapbuilder.com","password":"Admin123!"}'

# Create Campaign (replace <token>)
curl -X POST https://localhost:5001/api/campaigns \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","description":"Test campaign"}'
```

## 📈 Future Enhancements

Potential features to add:
- [ ] Real-time collaboration (SignalR)
- [ ] File upload for map images
- [ ] Export/import campaigns
- [ ] Campaign sharing between users
- [ ] Map templates
- [ ] Advanced token properties (HP, AC, etc.)
- [ ] Combat tracker
- [ ] Dice roller integration
- [ ] Character sheets
- [ ] Unit tests
- [ ] Integration tests
- [ ] Rate limiting
- [ ] API versioning
- [ ] GraphQL endpoint

## 📚 Documentation Files

1. **README.md** - Complete setup and overview
2. **API_DOCUMENTATION.md** - Full API reference
3. **QUICKSTART.md** - Fast setup guide
4. **setup.sh** - Automated setup script

## 🤝 Integration with Frontend

The React frontend can integrate with this API by:

1. **Authentication**
   ```typescript
   // Replace localStorage auth with API calls
   const login = async (email, password) => {
     const response = await fetch('https://api-url/api/auth/login', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ email, password })
     });
     const { data } = await response.json();
     localStorage.setItem('token', data.token);
   };
   ```

2. **Data Fetching**
   ```typescript
   // Fetch campaigns
   const getCampaigns = async () => {
     const token = localStorage.getItem('token');
     const response = await fetch('https://api-url/api/campaigns', {
       headers: { 'Authorization': `Bearer ${token}` }
     });
     return await response.json();
   };
   ```

3. **Replace local storage state** with API-backed state management

## ✅ Production Checklist

Before deploying to production:

- [ ] Change JWT secret key
- [ ] Update SQL Server credentials
- [ ] Configure HTTPS certificates
- [ ] Set up proper CORS policy
- [ ] Enable rate limiting
- [ ] Configure logging (Application Insights, Serilog)
- [ ] Set up CI/CD pipeline
- [ ] Database backup strategy
- [ ] Monitoring and alerting
- [ ] Load balancing (if needed)
- [ ] CDN for static assets
- [ ] Security headers
- [ ] Input validation
- [ ] Error handling
- [ ] API documentation versioning

## 🎓 Learning Resources

To understand this codebase:
1. Review the clean architecture layers
2. Follow a request from Controller → Service → Repository → Database
3. Examine the entity relationships in DbContext
4. Study the JWT authentication flow
5. Explore the Aspire orchestration setup

## 📄 License

MIT License - Feel free to use and modify

---

**Created**: January 2026  
**.NET Version**: 9.0  
**Database**: SQL Server 2022  
**Architecture**: Clean Architecture with Repository Pattern
</file>

<file path="prompt_plan.md">
# backend_prompt_plan.md

## Context
This backend belongs to a DnD map builder application. The current implementation incorrectly stores and retrieves images (maps and tokens) from the database, likely using base64 or JSON-embedded blobs. This causes corruption, size issues, and retrieval bugs. The fix is to move to **proper file transfer and storage**, with the database storing only metadata and file references.

---

## Goals
- Use multipart file upload instead of embedding images in JSON.
- Store images in a file system or object storage (local disk, S3-compatible, etc.).
- Persist only metadata (URL/path, size, type, ownership) in the database.
- Ensure backward-safe migration path if existing data exists.

---

## Step-by-step Implementation Plan

### Step 1: Audit Current Image Handling
**status: done**
- Identify all endpoints that accept or return images (maps, tokens).
- Confirm how images are currently:
  - Sent from frontend (base64, data URLs, JSON fields)
  - Stored in DB (byte array, string, JSON column)
- List affected entities (e.g., Map, Token).

**Findings:**
- Images are currently stored as URL strings only (nvarchar(1000) in SQL Server)
- Maps endpoint (POST/PUT/GET) with optional ImageUrl field
- Tokens endpoint (POST/PUT/GET) with required ImageUrl field
- Affected entities: GameMap, TokenDefinition
- No file upload system exists - all images are external URL references
- No binary storage, multipart/form-data handling, or file validation currently

---

### Step 2: Define File Storage Strategy
**status: done**
- Decide storage target:
  - Local filesystem (e.g., `/uploads/maps`, `/uploads/tokens`)
  - OR object storage abstraction (recommended for future scaling).
- Define naming strategy:
  - UUID-based filenames
  - Preserve original extension
- Define public vs private access rules.

**Strategy Decisions:**
- **Storage Target**: Abstraction layer with local filesystem as initial implementation
  - Directory structure: `wwwroot/uploads/maps/`, `wwwroot/uploads/tokens/`
  - Future: Can swap to S3/Azure Blob without API changes
- **Naming Strategy**:
  - Format: `{UUID}_{originalFileName}` (preserves context and extension)
  - Example: `a1b2c3d4-e5f6_dragon_token.png`
- **Access Rules**:
  - Maps: Public URLs (served via static middleware)
  - Tokens: User-specific ownership (check authorization on retrieval)
- **File Size Limits**:
  - Maps: 5MB max
  - Tokens: 2MB max
- **Allowed MIME Types**: `image/png`, `image/jpeg`, `image/webp`

---

### Step 3: Introduce File Storage Abstraction
**status: done**
- Create a `IFileStorageService` (or equivalent):
  - `UploadAsync(Stream file, FileMetadata metadata)`
  - `DeleteAsync(fileId)`
  - `GetPublicUrl(fileId)`
- Implement initial version using local filesystem.
- Ensure streaming is used (no full file buffering in memory).

**Implementation:**
- Created `IFileStorageService` interface in Application/Interfaces/IServices.cs
- Implemented `LocalFileStorageService` in Application/Services/FileStorageService.cs
- Uses async streaming (4096 buffer) - no full file buffering in memory
- Stores files in `wwwroot/uploads/{category}/{fileId}`
- Validates MIME types (png, jpeg, webp)
- Prevents path traversal attacks
- Registered as Singleton in Program.cs with logging
- Added static file middleware for serving uploads

---

### Step 4: Update Domain Models
**status: done**
- Remove image binary/base64 fields from entities.
- Add fields such as:
  - `ImageFileId`
  - `ImageUrl`
  - `ContentType`
  - `FileSize`
- Update ORM mappings and migrations accordingly.

**Implementation:**
- Updated GameMap entity: added ImageFileId, ImageContentType, ImageFileSize (kept ImageUrl for backward compatibility)
- Updated TokenDefinition entity: added ImageFileId, ImageContentType, ImageFileSize (kept ImageUrl for backward compatibility)
- Created migration: 20260117102707_AddImageFileStorageMetadata.cs
- Backward compatible: existing ImageUrl field remains for gradual migration

---

### Step 5: Update API Contracts
**status: done**
- Replace JSON-based image fields with:
  - `multipart/form-data` endpoints
- Separate responsibilities:
  - One endpoint for metadata (map config, token position, etc.)
  - One endpoint for file upload
- Example:
  - `POST /maps` (metadata only)
  - `POST /maps/{id}/image` (multipart file upload)

**Implementation:**
- Updated GameMapDto: added ImageFileId, ImageContentType, ImageFileSize fields
- Updated TokenDefinitionDto: added ImageFileId, ImageContentType, ImageFileSize fields
- Added ImageUploadResponse contract for file upload responses
- Updated mapping extensions to include new metadata fields
- IFormFile handling will be done directly in controllers (not in Contracts layer)

---

### Step 6: Implement Upload Endpoints
**status: done**
- Add endpoints using `multipart/form-data`.
- Validate:
  - File size limits
  - MIME types (png, jpg, webp)
- Store file via `IFileStorageService`.
- Persist file reference to DB.

**Implementation:**
- Added `POST /api/maps/{id}/image` endpoint in MapsController
  - Validates file size (5MB max for maps)
  - Validates MIME types (png, jpeg, webp)
  - Verifies ownership before upload
  - Stores file via IFileStorageService
  - Updates map metadata in DB
- Added `POST /api/tokens/{id}/image` endpoint in TokensController
  - Validates file size (2MB max for tokens)
  - Same validation and security checks as maps
- Both endpoints return ImageUploadResponse with file info
- Error handling for validation and storage failures

---

### Step 7: Implement Retrieval Strategy
**status: done**
- Serve images via:
  - Static file middleware (local disk)
  - OR signed URLs (if object storage)
- Ensure API returns image URLs, not raw bytes.

**Implementation:**
- Static file middleware already added to Program.cs
- Images served via `/uploads/{category}/{fileId}` routes
- File storage service returns public URLs for each file
- API endpoints return image URLs in DTO fields (ImageUrl)
- No raw bytes returned - only URL references
- Supports future S3/Azure Blob integration via IFileStorageService abstraction

---

### Step 8: Migration / Backward Compatibility
**status: done**
- Decide whether existing stored images must be migrated.
- If yes:
  - Write one-time migration script:
    - Read old image data
    - Save as file
    - Update DB references
- If no:
  - Explicitly drop legacy fields.

**Implementation:**
- **Backward Compatible Approach**: Existing ImageUrl field retained
- New file storage fields added as nullable (ImageFileId, ImageContentType, ImageFileSize)
- Old endpoints still work with existing ImageUrl data
- New upload endpoints populate both old and new fields
- Existing data can coexist during gradual migration
- Future: One-time migration script can convert existing URLs to file storage if needed
- No data loss - legacy fields preserved for rollback capability

---

### Step 9: Security & Validation
**status: done**
- Enforce authorization checks on upload/delete.
- Prevent path traversal.
- Validate file headers (not just extensions).

**Implementation:**
- **Authorization**:
  - [Authorize] attribute on all upload endpoints
  - GetUserId() verifies user identity from JWT claims
  - Ownership check: verify user owns map/token before allowing upload
- **Path Traversal Prevention**:
  - FileStorageService validates fileId to prevent ".." or "/" characters
  - Files stored in UUID format only (e.g., a1b2c3d4-e5f6.png)
  - No user-controlled path manipulation possible
- **File Validation**:
  - MIME type validation against allowlist (png, jpeg, webp)
  - File size limits enforced (5MB for maps, 2MB for tokens)
  - Validates IFormFile.Length before processing
  - Safe file operations with proper error handling
- **Storage Security**:
  - Files saved to isolated directory (wwwroot/uploads/)
  - Streaming used to avoid full-file memory buffering
  - Proper exception handling and cleanup on failures

---

### Step 10: Documentation for Frontend Team
**status: done**
- Document new endpoints and payload expectations.
- Provide example `curl` and Postman requests.

**Documentation:**

#### Map Image Upload
- **Endpoint**: `POST /api/maps/{mapId}/image`
- **Authentication**: Required (Bearer token)
- **Content-Type**: `multipart/form-data`
- **Parameters**:
  - `image` (file): The image file to upload (PNG, JPEG, or WebP)
- **File Limits**: Max 5MB
- **Response**:
  ```json
  {
    "success": true,
    "data": {
      "fileId": "a1b2c3d4-e5f6-7890.png",
      "url": "/uploads/maps/a1b2c3d4-e5f6-7890.png",
      "contentType": "image/png",
      "fileSize": 123456
    },
    "message": "Image uploaded successfully."
  }
  ```

#### Token Image Upload
- **Endpoint**: `POST /api/tokens/{tokenId}/image`
- **Authentication**: Required (Bearer token)
- **Content-Type**: `multipart/form-data`
- **Parameters**:
  - `image` (file): The image file to upload (PNG, JPEG, or WebP)
- **File Limits**: Max 2MB
- **Response**: Same format as map image upload

#### cURL Examples
```bash
# Upload map image
curl -X POST "https://api.example.com/api/maps/map-id-123/image" \
  -H "Authorization: Bearer <token>" \
  -F "image=@path/to/map.png"

# Upload token image
curl -X POST "https://api.example.com/api/tokens/token-id-456/image" \
  -H "Authorization: Bearer <token>" \
  -F "image=@path/to/token.png"
```

#### Client Implementation Notes
- Use `FormData` in JavaScript/fetch:
  ```javascript
  const formData = new FormData();
  formData.append('image', fileInput.files[0]);

  const response = await fetch(`/api/maps/${mapId}/image`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`
    },
    body: formData
  });
  ```

#### Retrieval
- Map/token images are returned in API responses via `ImageUrl` field
- Images are publicly accessible at: `/uploads/{category}/{fileId}`
- No additional API calls needed for retrieval - use URL directly in img tags

---
</file>

<file path="QUICKSTART.md">
# Quick Start Guide

## TL;DR - Fastest Way to Run

### Using .NET Aspire (Recommended)

```bash
# 1. Navigate to the project
cd DnDMapBuilder

# 2. Set SQL password
cd src/DnDMapBuilder.Aspire.AppHost
dotnet user-secrets set "Parameters:sql-password" "YourStrong@Passw0rd"

# 3. Run
dotnet run

# 4. Open the Aspire dashboard URL shown in console
# The API will be available at the URL shown for 'api' service
```

### Using Docker Compose

```bash
# From project root
docker-compose up --build
```

API available at: `http://localhost:5000`

### Using Direct API (Requires SQL Server)

```bash
# 1. Update connection string in src/DnDMapBuilder.Api/appsettings.json

# 2. Run migrations
cd src/DnDMapBuilder.Api
dotnet ef database update --project ../DnDMapBuilder.Data

# 3. Run API
dotnet run
```

## First Steps After Running

### 1. Access Swagger UI

Navigate to: `https://localhost:<port>/swagger`

### 2. Login as Admin

**Default Admin Credentials:**
- Email: `admin@dndmapbuilder.com`
- Password: `Admin123!`

### 3. Test the API

```bash
# Login
curl -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@dndmapbuilder.com","password":"Admin123!"}'

# Copy the token from response

# Create a campaign
curl -X POST https://localhost:5001/api/campaigns \
  -H "Authorization: Bearer <your-token>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Campaign","description":"My first campaign"}'
```

## Common Issues

### Issue: Port already in use

**Solution:** Change the port in `launchSettings.json` or stop the service using that port.

### Issue: SQL Server connection failed

**Aspire:** Wait for SQL Server container to be healthy (check Aspire dashboard)

**Docker Compose:** Check `docker-compose logs sqlserver`

**Direct:** Verify SQL Server is running: `sqlcmd -S localhost -U sa -P <password> -Q "SELECT @@VERSION"`

### Issue: Database migrations not applied

```bash
cd src/DnDMapBuilder.Api
dotnet ef database update --project ../DnDMapBuilder.Data
```

## Project Structure Quick Reference

```
src/
├── DnDMapBuilder.Api/              ← API Controllers & Startup
│   ├── Controllers/                ← REST endpoints
│   ├── Program.cs                  ← Application entry point
│   └── appsettings.json           ← Configuration
├── DnDMapBuilder.Application/      ← Business logic
│   ├── Services/                   ← Service implementations
│   └── Interfaces/                 ← Service contracts
├── DnDMapBuilder.Contracts/        ← DTOs & Models
│   ├── DTOs/                       ← Data transfer objects
│   ├── Requests/                   ← Request models
│   └── Responses/                  ← Response models
├── DnDMapBuilder.Data/             ← Data access
│   ├── Entities/                   ← Database entities
│   ├── Repositories/               ← Data repositories
│   └── DnDMapBuilderDbContext.cs  ← EF Core context
└── DnDMapBuilder.Aspire.AppHost/   ← Orchestration
    └── Program.cs                  ← Aspire configuration
```

## Next Steps

1. **Register a new user** via `/api/auth/register`
2. **Approve the user** as admin via `/api/auth/approve-user`
3. **Create campaigns, missions, and maps** using the authenticated user
4. **Define custom tokens** for your maps
5. **Build maps** and place tokens

## Useful Commands

```bash
# Restore dependencies
dotnet restore

# Build solution
dotnet build

# Run migrations
dotnet ef migrations add <name> --project src/DnDMapBuilder.Data

# Update database
dotnet ef database update --project src/DnDMapBuilder.Data

# Clean build artifacts
dotnet clean

# Watch for changes and auto-rebuild
dotnet watch run --project src/DnDMapBuilder.Api
```

## Environment Variables

When not using Aspire, you can override settings with environment variables:

```bash
export ConnectionStrings__DefaultConnection="Server=...;Database=...;"
export JwtSettings__SecretKey="your-secret-key"
export ASPNETCORE_ENVIRONMENT="Development"
```

## Testing with Postman

1. Import the API into Postman using the Swagger JSON: `https://localhost:5001/swagger/v1/swagger.json`
2. Set up an environment variable for the token
3. Use `{{token}}` in the Authorization header

## Production Checklist

Before deploying to production:

- [ ] Change JWT SecretKey in appsettings.json
- [ ] Update SQL Server password
- [ ] Configure proper CORS policy
- [ ] Enable HTTPS
- [ ] Set up proper logging
- [ ] Configure rate limiting
- [ ] Review and update default admin credentials
- [ ] Set up database backups
- [ ] Configure monitoring
- [ ] Review security headers

## Support

For issues or questions:
1. Check the full README.md
2. Review API_DOCUMENTATION.md
3. Check application logs
4. Review Aspire dashboard for container health
</file>

<file path="setup.sh">
#!/bin/bash

# DnD Map Builder - Quick Setup Script

echo "=========================================="
echo "DnD Map Builder - Backend Setup"
echo "=========================================="
echo ""

# Check if .NET is installed
if ! command -v dotnet &> /dev/null; then
    echo "❌ .NET SDK is not installed. Please install .NET 9.0 SDK first."
    echo "   Download from: https://dotnet.microsoft.com/download"
    exit 1
fi

echo "✅ .NET SDK found: $(dotnet --version)"
echo ""

# Check if Docker is running (optional, for Aspire)
if command -v docker &> /dev/null; then
    if docker info &> /dev/null; then
        echo "✅ Docker is running"
        DOCKER_AVAILABLE=true
    else
        echo "⚠️  Docker is installed but not running"
        DOCKER_AVAILABLE=false
    fi
else
    echo "⚠️  Docker is not installed (optional for Aspire)"
    DOCKER_AVAILABLE=false
fi
echo ""

# Ask user how they want to run the application
echo "How would you like to run the application?"
echo "1. Using .NET Aspire (Recommended - requires Docker)"
echo "2. Using Docker Compose"
echo "3. Run API directly (requires SQL Server)"
echo ""
read -p "Enter your choice (1-3): " choice

case $choice in
    1)
        if [ "$DOCKER_AVAILABLE" = false ]; then
            echo "❌ Docker is required for Aspire. Please start Docker or choose another option."
            exit 1
        fi
        
        echo ""
        echo "Setting up .NET Aspire..."
        
        # Set SQL password
        read -sp "Enter SQL Server password (default: YourStrong@Passw0rd): " sql_password
        echo ""
        if [ -z "$sql_password" ]; then
            sql_password="YourStrong@Passw0rd"
        fi
        
        cd src/DnDMapBuilder.Aspire.AppHost
        dotnet user-secrets set "Parameters:sql-password" "$sql_password"
        
        echo ""
        echo "✅ Setup complete!"
        echo ""
        echo "Starting .NET Aspire..."
        dotnet run
        ;;
        
    2)
        if [ "$DOCKER_AVAILABLE" = false ]; then
            echo "❌ Docker is required for Docker Compose. Please start Docker or choose another option."
            exit 1
        fi
        
        echo ""
        echo "Starting with Docker Compose..."
        docker-compose up --build
        ;;
        
    3)
        echo ""
        echo "⚠️  Make sure SQL Server is running and accessible."
        echo ""
        read -p "Enter SQL Server host (default: localhost): " sql_host
        sql_host=${sql_host:-localhost}
        
        read -p "Enter SQL Server port (default: 1433): " sql_port
        sql_port=${sql_port:-1433}
        
        read -p "Enter SQL Server username (default: sa): " sql_user
        sql_user=${sql_user:-sa}
        
        read -sp "Enter SQL Server password: " sql_password
        echo ""
        
        # Update appsettings.json
        connection_string="Server=${sql_host},${sql_port};Database=DnDMapBuilder;User Id=${sql_user};Password=${sql_password};TrustServerCertificate=True;"
        
        cd src/DnDMapBuilder.Api
        
        # Create a temporary appsettings.Development.json with the connection string
        cat > appsettings.Development.json << EOF
{
  "ConnectionStrings": {
    "DefaultConnection": "${connection_string}"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "System": "Information",
      "Microsoft": "Information"
    }
  }
}
EOF
        
        echo ""
        echo "Running database migrations..."
        dotnet ef database update --project ../DnDMapBuilder.Data
        
        echo ""
        echo "✅ Setup complete!"
        echo ""
        echo "Starting API..."
        dotnet run
        ;;
        
    *)
        echo "❌ Invalid choice. Please run the script again."
        exit 1
        ;;
esac
</file>

<file path="SMOKE_TESTS.md">
# Smoke Testing Guide

## Overview

Smoke tests are quick, automated tests that verify critical application functionality immediately after deployment. They're the first validation that the application is operational.

## Smoke Test Objectives

✓ Verify application startup and health endpoints
✓ Validate core authentication flow
✓ Ensure database connectivity
✓ Test CRUD operations for each entity
✓ Verify file upload functionality
✓ Confirm telemetry collection
✓ Validate security headers

## Test Environment

### Required Setup

```bash
# Environment variables
export API_URL="http://localhost:5000"
export API_USERNAME="smoketest@example.com"
export API_PASSWORD="SmokeTestPassword123!"
export TEST_ADMIN_USERNAME="admin@example.com"
export TEST_ADMIN_PASSWORD="AdminPassword123!"
```

## Smoke Test Scenarios

### 1. Application Health Check

**Test:** Verify application is running and healthy

```bash
#!/bin/bash

echo "Testing health endpoints..."

# Health endpoint (no auth required)
echo "1. GET /health"
curl -s -w "\nStatus: %{http_code}\n" http://localhost:5000/health | jq .

# Ready endpoint
echo "2. GET /health/ready"
curl -s -w "\nStatus: %{http_code}\n" http://localhost:5000/health/ready | jq .

# Live endpoint
echo "3. GET /health/live"
curl -s -w "\nStatus: %{http_code}\n" http://localhost:5000/health/live | jq .

echo "✓ Health checks complete"
```

### 2. Authentication Flow

**Test:** Verify user registration and login

```bash
#!/bin/bash

echo "Testing authentication flow..."

# Register new user
echo "1. POST /auth/register"
REGISTER_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "smoketest_'$(date +%s)'",
    "email": "smoketest_'$(date +%s)'@example.com",
    "password": "SmokeTest123!"
  }')

echo $REGISTER_RESPONSE | jq .

USER_ID=$(echo $REGISTER_RESPONSE | jq -r '.data.id')
echo "Created user: $USER_ID"

# Login as admin and approve user
echo "2. POST /auth/login (Admin)"
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "'$TEST_ADMIN_USERNAME'",
    "password": "'$TEST_ADMIN_PASSWORD'"
  }')

ADMIN_TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.data.token')
echo "Admin token: ${ADMIN_TOKEN:0:20}..."

# Approve user
echo "3. POST /auth/approve-user"
curl -s -X POST http://localhost:5000/api/v1/auth/approve-user \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"userId": "'$USER_ID'", "approved": true}' | jq .

# Login as new user
echo "4. POST /auth/login (New User)"
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "smoketest_'$(date +%s)'@example.com",
    "password": "SmokeTest123!"
  }')

TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.data.token')
echo "User token: ${TOKEN:0:20}..."

echo "✓ Authentication flow complete"
```

### 3. Campaign CRUD Operations

**Test:** Create, read, update, and delete campaigns

```bash
#!/bin/bash

echo "Testing Campaign CRUD..."

# CREATE
echo "1. POST /campaigns (Create)"
CREATE_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/campaigns \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Smoke Test Campaign",
    "description": "Campaign for smoke testing"
  }')

CAMPAIGN_ID=$(echo $CREATE_RESPONSE | jq -r '.data.id')
echo "Created campaign: $CAMPAIGN_ID"

# READ
echo "2. GET /campaigns/{id} (Read)"
curl -s -H "Authorization: Bearer $TOKEN" \
  http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID | jq .

# UPDATE
echo "3. PUT /campaigns/{id} (Update)"
curl -s -X PUT http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Updated Campaign Name",
    "description": "Updated description"
  }' | jq .

# LIST
echo "4. GET /campaigns (List)"
curl -s -H "Authorization: Bearer $TOKEN" \
  http://localhost:5000/api/v1/campaigns | jq .

# DELETE
echo "5. DELETE /campaigns/{id} (Delete)"
curl -s -X DELETE http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID \
  -H "Authorization: Bearer $TOKEN" | jq .

echo "✓ Campaign CRUD complete"
```

### 4. Mission Operations

**Test:** Create mission and verify relationships

```bash
#!/bin/bash

echo "Testing Mission operations..."

# Create campaign first
CAMPAIGN=$(curl -s -X POST http://localhost:5000/api/v1/campaigns \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name": "Mission Test", "description": "Test"}')

CAMPAIGN_ID=$(echo $CAMPAIGN | jq -r '.data.id')

# Create mission
echo "1. POST /missions (Create)"
MISSION=$(curl -s -X POST http://localhost:5000/api/v1/missions \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "campaignId": "'$CAMPAIGN_ID'",
    "name": "Test Mission",
    "description": "Mission for smoke testing"
  }')

MISSION_ID=$(echo $MISSION | jq -r '.data.id')
echo "Created mission: $MISSION_ID"

# Get mission
echo "2. GET /missions/{id}"
curl -s -H "Authorization: Bearer $TOKEN" \
  http://localhost:5000/api/v1/missions/$MISSION_ID | jq .

echo "✓ Mission operations complete"
```

### 5. Authorization Verification

**Test:** Verify authorization enforcement

```bash
#!/bin/bash

echo "Testing authorization..."

# Create different user
ANOTHER_USER=$(curl -s -X POST http://localhost:5000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "another_'$(date +%s)'",
    "email": "another_'$(date +%s)'@example.com",
    "password": "AnotherUser123!"
  }')

ANOTHER_USER_ID=$(echo $ANOTHER_USER | jq -r '.data.id')

# Approve other user
curl -s -X POST http://localhost:5000/api/v1/auth/approve-user \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"userId": "'$ANOTHER_USER_ID'", "approved": true}' > /dev/null

# Login as other user
ANOTHER_TOKEN=$(curl -s -X POST http://localhost:5000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "another_'$(date +%s)'@example.com",
    "password": "AnotherUser123!"
  }' | jq -r '.data.token')

# Try to access another user's campaign (should fail)
echo "1. Attempting unauthorized access (should get 404/403)"
curl -s -w "\nStatus: %{http_code}\n" -H "Authorization: Bearer $ANOTHER_TOKEN" \
  http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID | jq .

echo "✓ Authorization verification complete"
```

### 6. Rate Limiting Test

**Test:** Verify rate limiting is active

```bash
#!/bin/bash

echo "Testing rate limiting..."

# Make rapid requests
echo "1. Making 15 rapid requests (limit is 10/min for anonymous)"
for i in {1..15}; do
  STATUS=$(curl -s -w "%{http_code}" -o /dev/null http://localhost:5000/health)
  echo "Request $i: HTTP $STATUS"
  if [ "$STATUS" = "429" ]; then
    echo "✓ Rate limit hit at request $i (expected)"
    break
  fi
done

echo "✓ Rate limiting test complete"
```

### 7. Security Headers Verification

**Test:** Verify security headers are present

```bash
#!/bin/bash

echo "Testing security headers..."

# Get response headers
curl -s -i http://localhost:5000/health | grep -i "X-" | head -10

echo "Expected headers:"
echo "- X-Content-Type-Options: nosniff"
echo "- X-Frame-Options: DENY"
echo "- X-XSS-Protection: 1; mode=block"
echo "- Strict-Transport-Security"
echo "- Content-Security-Policy"

echo "✓ Security headers verification complete"
```

### 8. Telemetry Collection

**Test:** Verify telemetry is being collected

```bash
#!/bin/bash

echo "Testing telemetry collection..."

# Check OpenTelemetry metrics endpoint (if configured)
echo "1. Checking metrics endpoint"
curl -s http://localhost:5000/metrics | head -20

# Check application logs contain request/response data
echo "2. Checking logs for structured logging"
docker logs dnd-api | grep -i "request\|response" | head -5

echo "✓ Telemetry collection verification complete"
```

## Automated Smoke Test Suite

### shell Script

Create `scripts/smoke_tests.sh`:

```bash
#!/bin/bash

set -e

API_URL="${1:-http://localhost:5000}"
FAILED=0
PASSED=0

test_endpoint() {
  local method=$1
  local endpoint=$2
  local expected_status=$3
  local data=$4
  
  echo -n "Testing $method $endpoint... "
  
  if [ -z "$data" ]; then
    STATUS=$(curl -s -w "%{http_code}" -o /dev/null -X $method $API_URL$endpoint)
  else
    STATUS=$(curl -s -w "%{http_code}" -o /dev/null -X $method $API_URL$endpoint \
      -H "Content-Type: application/json" \
      -d "$data")
  fi
  
  if [ "$STATUS" = "$expected_status" ] || [ "$STATUS" = "200" ]; then
    echo "✓ ($STATUS)"
    ((PASSED++))
  else
    echo "✗ (Expected $expected_status, got $STATUS)"
    ((FAILED++))
  fi
}

# Run tests
echo "Running Smoke Tests for $API_URL"
echo "=================================="

test_endpoint "GET" "/health" "200"
test_endpoint "GET" "/health/ready" "200"
test_endpoint "GET" "/health/live" "200"

echo "=================================="
echo "Results: $PASSED passed, $FAILED failed"

if [ $FAILED -gt 0 ]; then
  exit 1
fi
```

### k6 Script

Create `scripts/smoke_tests.js`:

```javascript
import http from 'k6/http';
import { check } from 'k6';

const API_URL = 'http://localhost:5000';

export let options = {
  vus: 1,
  duration: '1m',
  thresholds: {
    http_req_failed: ['rate<0.1'],
  },
};

export default function() {
  // Test health endpoints
  let res = http.get(`${API_URL}/health`);
  check(res, {
    'health status is 200': (r) => r.status === 200,
  });

  res = http.get(`${API_URL}/health/ready`);
  check(res, {
    'health ready status is 200': (r) => r.status === 200,
  });

  res = http.get(`${API_URL}/health/live`);
  check(res, {
    'health live status is 200': (r) => r.status === 200,
  });

  // Test auth endpoint
  res = http.post(`${API_URL}/api/v1/auth/login`, JSON.stringify({
    email: 'test@example.com',
    password: 'TestPassword123!',
  }), {
    headers: { 'Content-Type': 'application/json' },
  });

  check(res, {
    'login response received': (r) => r.status === 200 || r.status === 401,
  });
}
```

## Running Smoke Tests

```bash
# Run shell script
./scripts/smoke_tests.sh http://localhost:5000

# Run k6 script
k6 run scripts/smoke_tests.js

# Run in CI/CD
./scripts/smoke_tests.sh https://api.production.com
```

## Success Criteria

All smoke tests must pass:
- [ ] Health endpoints return 200 OK
- [ ] Authentication flow works (register → approve → login)
- [ ] CRUD operations functional
- [ ] Authorization enforced
- [ ] Rate limiting active
- [ ] Security headers present
- [ ] No 5xx errors in logs
- [ ] Telemetry collection active

## Post-Deployment Verification Checklist

- [ ] Application responding to requests
- [ ] Database connectivity verified
- [ ] Authentication working
- [ ] Authorization working
- [ ] Rate limiting active
- [ ] Security headers present
- [ ] Telemetry flowing
- [ ] No critical errors in logs
- [ ] Performance acceptable
- [ ] All smoke tests passing

## Troubleshooting

### Connection Refused
- Verify API is running: `docker ps`
- Check port: `netstat -an | grep 5000`
- Review startup logs: `docker logs dnd-api`

### Authentication Failed
- Verify user exists and is approved
- Check JWT configuration
- Review auth logs

### Health Check Failed
- Check database connection
- Verify configuration
- Review startup logs

### Rate Limiting Not Working
- Verify rate limiting middleware is configured
- Check configuration values
- Verify rate limiting policy applied
</file>

<file path="STRUCTURE_DIAGRAM.md">
# Visual Structure

```
DnDMapBuilder/
│
├── 📄 DnDMapBuilder.sln
├── 📄 .gitignore
├── 🐳 docker-compose.yml
├── 🔧 setup.sh
├── 🔧 verify-structure.sh
│
├── 📚 Documentation
│   ├── 📖 README.md
│   ├── 📖 QUICKSTART.md
│   ├── 📖 API_DOCUMENTATION.md
│   ├── 📖 PROJECT_SUMMARY.md
│   └── 📖 FILE_STRUCTURE.md
│
└── 📁 src/
    │
    ├── 📦 DnDMapBuilder.Contracts/
    │   ├── 📄 DnDMapBuilder.Contracts.csproj
    │   ├── 📁 DTOs/
    │   │   └── 📝 DomainDtos.cs
    │   ├── 📁 Requests/
    │   │   └── 📝 ApiRequests.cs
    │   └── 📁 Responses/
    │       └── 📝 ApiResponses.cs
    │
    ├── 📦 DnDMapBuilder.Data/
    │   ├── 📄 DnDMapBuilder.Data.csproj
    │   ├── 📝 DnDMapBuilderDbContext.cs
    │   ├── 📁 Entities/
    │   │   └── 📝 DomainEntities.cs
    │   └── 📁 Repositories/
    │       ├── 📝 IRepositories.cs
    │       └── 📝 Repositories.cs
    │
    ├── 📦 DnDMapBuilder.Application/
    │   ├── 📄 DnDMapBuilder.Application.csproj
    │   ├── 📁 Interfaces/
    │   │   └── 📝 IServices.cs
    │   ├── 📁 Mappings/
    │   │   └── 📝 MappingExtensions.cs
    │   └── 📁 Services/
    │       ├── 📝 AuthService.cs
    │       ├── 📝 JwtService.cs
    │       ├── 📝 CampaignService.cs
    │       ├── 📝 MissionService.cs
    │       └── 📝 GameMapAndTokenServices.cs
    │
    ├── 📦 DnDMapBuilder.Api/
    │   ├── 📄 DnDMapBuilder.Api.csproj
    │   ├── 📝 Program.cs
    │   ├── 🐳 Dockerfile
    │   ├── ⚙️ appsettings.json
    │   ├── ⚙️ appsettings.Development.json
    │   ├── 📁 Controllers/
    │   │   ├── 📝 AuthController.cs
    │   │   ├── 📝 CampaignsController.cs
    │   │   └── 📝 OtherControllers.cs
    │   └── 📁 Properties/
    │       └── ⚙️ launchSettings.json
    │
    ├── 📦 DnDMapBuilder.Aspire.AppHost/
    │   ├── 📄 DnDMapBuilder.Aspire.AppHost.csproj
    │   └── 📝 Program.cs
    │
    └── 📦 DnDMapBuilder.Aspire.ServiceDefaults/
        ├── 📄 DnDMapBuilder.Aspire.ServiceDefaults.csproj
        └── 📝 Extensions.cs
```

## Legend

- 📄 Project/Solution Files (.csproj, .sln)
- 📝 C# Source Files (.cs)
- 📖 Documentation (.md)
- ⚙️ Configuration (.json)
- 🐳 Docker Files
- 🔧 Scripts (.sh)
- 📦 Project Folders
- 📁 Code Organization Folders
- 📚 Documentation Section

## Statistics

- **Total Projects**: 6
- **Total C# Files**: 20
- **Total Lines of Code**: ~2,500
- **Total Documentation Files**: 5
- **Total Configuration Files**: 4
- **Total Scripts**: 2

## Quick Access

| What You Need | Where to Find It |
|---------------|------------------|
| Start the app | `setup.sh` or `docker-compose.yml` |
| API endpoints | `src/DnDMapBuilder.Api/Controllers/` |
| Database setup | `src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs` |
| Business logic | `src/DnDMapBuilder.Application/Services/` |
| API contracts | `src/DnDMapBuilder.Contracts/` |
| Configuration | `src/DnDMapBuilder.Api/appsettings.json` |
| Documentation | Root `*.md` files |
</file>

<file path="verify-structure.sh">
#!/bin/bash

# DnD Map Builder - Structure Verification Script
# This script verifies that all necessary files are present

echo "=========================================="
echo "DnD Map Builder - Structure Verification"
echo "=========================================="
echo ""

ERRORS=0

# Function to check if file exists
check_file() {
    if [ -f "$1" ]; then
        echo "✅ $1"
    else
        echo "❌ MISSING: $1"
        ERRORS=$((ERRORS + 1))
    fi
}

# Function to check if directory exists
check_dir() {
    if [ -d "$1" ]; then
        echo "✅ $1/"
    else
        echo "❌ MISSING: $1/"
        ERRORS=$((ERRORS + 1))
    fi
}

echo "Checking root files..."
check_file "DnDMapBuilder.sln"
check_file ".gitignore"
check_file "docker-compose.yml"
check_file "setup.sh"
check_file "README.md"
check_file "QUICKSTART.md"
check_file "API_DOCUMENTATION.md"
check_file "PROJECT_SUMMARY.md"
check_file "FILE_STRUCTURE.md"
echo ""

echo "Checking project directories..."
check_dir "src/DnDMapBuilder.Contracts"
check_dir "src/DnDMapBuilder.Data"
check_dir "src/DnDMapBuilder.Application"
check_dir "src/DnDMapBuilder.Api"
check_dir "src/DnDMapBuilder.Aspire.AppHost"
check_dir "src/DnDMapBuilder.Aspire.ServiceDefaults"
echo ""

echo "Checking Contracts project..."
check_file "src/DnDMapBuilder.Contracts/DnDMapBuilder.Contracts.csproj"
check_file "src/DnDMapBuilder.Contracts/DTOs/DomainDtos.cs"
check_file "src/DnDMapBuilder.Contracts/Requests/ApiRequests.cs"
check_file "src/DnDMapBuilder.Contracts/Responses/ApiResponses.cs"
echo ""

echo "Checking Data project..."
check_file "src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj"
check_file "src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs"
check_file "src/DnDMapBuilder.Data/Entities/DomainEntities.cs"
check_file "src/DnDMapBuilder.Data/Repositories/IRepositories.cs"
check_file "src/DnDMapBuilder.Data/Repositories/Repositories.cs"
echo ""

echo "Checking Application project..."
check_file "src/DnDMapBuilder.Application/DnDMapBuilder.Application.csproj"
check_file "src/DnDMapBuilder.Application/Interfaces/IServices.cs"
check_file "src/DnDMapBuilder.Application/Mappings/MappingExtensions.cs"
check_file "src/DnDMapBuilder.Application/Services/AuthService.cs"
check_file "src/DnDMapBuilder.Application/Services/JwtService.cs"
check_file "src/DnDMapBuilder.Application/Services/CampaignService.cs"
check_file "src/DnDMapBuilder.Application/Services/MissionService.cs"
check_file "src/DnDMapBuilder.Application/Services/GameMapAndTokenServices.cs"
echo ""

echo "Checking API project..."
check_file "src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj"
check_file "src/DnDMapBuilder.Api/Program.cs"
check_file "src/DnDMapBuilder.Api/Dockerfile"
check_file "src/DnDMapBuilder.Api/appsettings.json"
check_file "src/DnDMapBuilder.Api/appsettings.Development.json"
check_file "src/DnDMapBuilder.Api/Properties/launchSettings.json"
check_file "src/DnDMapBuilder.Api/Controllers/AuthController.cs"
check_file "src/DnDMapBuilder.Api/Controllers/CampaignsController.cs"
check_file "src/DnDMapBuilder.Api/Controllers/OtherControllers.cs"
echo ""

echo "Checking Aspire projects..."
check_file "src/DnDMapBuilder.Aspire.AppHost/DnDMapBuilder.Aspire.AppHost.csproj"
check_file "src/DnDMapBuilder.Aspire.AppHost/Program.cs"
check_file "src/DnDMapBuilder.Aspire.ServiceDefaults/DnDMapBuilder.Aspire.ServiceDefaults.csproj"
check_file "src/DnDMapBuilder.Aspire.ServiceDefaults/Extensions.cs"
echo ""

echo "=========================================="
if [ $ERRORS -eq 0 ]; then
    echo "✅ All files present! Structure is correct."
    echo ""
    echo "File counts:"
    echo "  - C# Project files: $(find . -name "*.csproj" | wc -l)"
    echo "  - C# Source files: $(find . -name "*.cs" | wc -l)"
    echo "  - Documentation files: $(find . -maxdepth 1 -name "*.md" | wc -l)"
    echo ""
    echo "You can now:"
    echo "  1. Run './setup.sh' for quick setup"
    echo "  2. Or run 'docker-compose up' for Docker deployment"
    echo "  3. Or read README.md for detailed instructions"
else
    echo "❌ Found $ERRORS missing file(s)!"
    echo "Please check the structure and ensure all files are present."
fi
echo "=========================================="
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(move \"DnDMapBuilder.Aspire.ServiceDefaults.csproj\" \"src\\DnDMapBuilder.Aspire.ServiceDefaults\"\" && move \"Extensions.cs\" \"srcDnDMapBuilder.Aspire.ServiceDefaults\"\")",
      "Bash(git -C /Users/mikedeiktakis/RiderProjects/DnDMapbuilder-Api show:*)",
      "Bash(dotnet build:*)",
      "Bash(dotnet workload list:*)",
      "Bash(dotnet workload install:*)",
      "Bash(dotnet ef migrations:*)",
      "Bash(dotnet tool install:*)",
      "Bash(dotnet tool update:*)",
      "Bash(export PATH=\"$PATH:/Users/mikedeiktakis/.dotnet/tools\")",
      "Bash(docker ps:*)",
      "Bash(git checkout:*)",
      "Bash(dotnet test:*)",
      "Bash(tree:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(ls:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="src/DnDMapBuilder.AppHost/AppHost.cs">
var builder = DistributedApplication.CreateBuilder(args);

// Disable IDE run session integration (use direct process launching)
builder.Configuration["RunSession:UseIdeRunSession"] = "false";

var sql = builder.AddSqlServer("Database")
    .WithLifetime(ContainerLifetime.Persistent)
    .AddDatabase("dndmapbuilder");

builder.AddProject<Projects.DnDMapBuilder_Api>("dndmapapi")
    .WithReference(sql)
    .WithEnvironment("ConnectionStrings__DefaultConnection", sql)
    .WaitFor(sql)
    .WithEnvironment("ADMIN_EMAIL", "admin@test.com")
    .WithEnvironment("ADMIN_DEFAULT_PASSWORD", "1234")
    .WithEnvironment("MIGRATIONS_EXECUTE", "true");

builder.Build().Run();
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IAuthService.cs">
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for authentication operations (user login and token generation).
/// </summary>
public interface IAuthService
{
    /// <summary>
    /// Authenticates a user and returns a JWT token.
    /// </summary>
    /// <param name="request">Login request with email and password</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Authentication response with token or null if login fails</returns>
    Task<AuthResponse?> LoginAsync(LoginRequest request, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Mappings/MappingExtensions.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Application.Mappings;

public static class MappingExtensions
{
    public static UserDto ToDto(this User user)
    {
        return new UserDto(
            user.Id,
            user.Username,
            user.Email,
            user.Role,
            user.Status
        );
    }

    public static TokenDefinitionDto ToDto(this TokenDefinition token)
    {
        return new TokenDefinitionDto(
            token.Id,
            token.Name,
            token.ImageUrl,
            token.Size,
            token.Type,
            token.UserId,
            token.ImageFileId,
            token.ImageContentType,
            token.ImageFileSize
        );
    }

    public static MapTokenInstanceDto ToDto(this MapTokenInstance instance)
    {
        return new MapTokenInstanceDto(
            instance.Id,
            instance.TokenId,
            instance.X,
            instance.Y
        );
    }

    public static GameMapDto ToDto(this GameMap map)
    {
        return new GameMapDto(
            map.Id,
            map.Name,
            map.ImageUrl,
            map.Rows,
            map.Cols,
            map.Tokens.Select(t => t.ToDto()).ToList(),
            map.GridColor,
            map.GridOpacity,
            map.MissionId,
            map.ImageFileId,
            map.ImageContentType,
            map.ImageFileSize
        );
    }

    public static MissionDto ToDto(this Mission mission)
    {
        return new MissionDto(
            mission.Id,
            mission.Name,
            mission.Description,
            mission.Maps.Select(m => m.ToDto()).ToList(),
            mission.CampaignId
        );
    }

    public static CampaignDto ToDto(this Campaign campaign)
    {
        return new CampaignDto(
            campaign.Id,
            campaign.Name,
            campaign.Description,
            campaign.Missions.Select(m => m.ToDto()).ToList(),
            campaign.OwnerId,
            campaign.CreatedAt,
            campaign.UpdatedAt
        );
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/FileStorageService.cs">
using Microsoft.Extensions.Logging;
using DnDMapBuilder.Application.Interfaces;

namespace DnDMapBuilder.Application.Services;

public class LocalFileStorageService : IFileStorageService
{
    private readonly string _baseStoragePath;
    private readonly string _basePublicUrl;
    private readonly ILogger<LocalFileStorageService> _logger;

    public LocalFileStorageService(string baseStoragePath, string basePublicUrl, ILogger<LocalFileStorageService> logger)
    {
        _baseStoragePath = baseStoragePath ?? throw new ArgumentNullException(nameof(baseStoragePath));
        _basePublicUrl = basePublicUrl ?? throw new ArgumentNullException(nameof(basePublicUrl));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        EnsureStorageDirectoriesExist();
    }

    public async Task<string> UploadAsync(Stream file, string fileName, string contentType, string storageCategory, CancellationToken cancellationToken = default)
    {
        if (file == null || file.Length == 0)
            throw new ArgumentException("File stream is empty", nameof(file));

        if (string.IsNullOrWhiteSpace(fileName))
            throw new ArgumentException("File name is required", nameof(fileName));

        if (string.IsNullOrWhiteSpace(contentType))
            throw new ArgumentException("Content type is required", nameof(contentType));

        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));

        // Validate MIME type
        var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
        if (!allowedMimeTypes.Contains(contentType.ToLower()))
            throw new InvalidOperationException($"MIME type '{contentType}' is not allowed");

        // Generate file ID with extension
        var fileExtension = Path.GetExtension(fileName);
        if (string.IsNullOrWhiteSpace(fileExtension))
            fileExtension = GetExtensionFromMimeType(contentType);

        var fileId = $"{Guid.NewGuid()}{fileExtension}";
        var categoryPath = Path.Combine(_baseStoragePath, storageCategory);
        var fullFilePath = Path.Combine(categoryPath, fileId);

        // Ensure directory exists
        if (!Directory.Exists(categoryPath))
            Directory.CreateDirectory(categoryPath);

        try
        {
            // Save file to disk using streaming (no full buffering)
            using (var fileStream = new FileStream(fullFilePath, FileMode.Create, FileAccess.Write, FileShare.None, 4096, useAsync: true))
            {
                await file.CopyToAsync(fileStream, cancellationToken);
            }

            _logger.LogInformation($"File uploaded successfully: {fileId} to category {storageCategory}");
            return fileId;
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error uploading file: {ex.Message}");
            if (File.Exists(fullFilePath))
                File.Delete(fullFilePath);
            throw;
        }
    }

    public string GetPublicUrl(string fileId, string storageCategory)
    {
        if (string.IsNullOrWhiteSpace(fileId))
            throw new ArgumentException("File ID is required", nameof(fileId));

        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));

        // Prevent path traversal attacks
        if (fileId.Contains("..") || fileId.Contains("/") || fileId.Contains("\\"))
            throw new InvalidOperationException("Invalid file ID");

        return $"{_basePublicUrl}/{storageCategory}/{fileId}";
    }

    public async Task<bool> DeleteAsync(string fileId, string storageCategory, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(fileId))
            throw new ArgumentException("File ID is required", nameof(fileId));

        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));

        // Prevent path traversal attacks
        if (fileId.Contains("..") || fileId.Contains("/") || fileId.Contains("\\"))
            throw new InvalidOperationException("Invalid file ID");

        var categoryPath = Path.Combine(_baseStoragePath, storageCategory);
        var fullFilePath = Path.Combine(categoryPath, fileId);

        try
        {
            if (File.Exists(fullFilePath))
            {
                File.Delete(fullFilePath);
                _logger.LogInformation($"File deleted successfully: {fileId} from category {storageCategory}");
                return true;
            }

            _logger.LogWarning($"File not found for deletion: {fileId} in category {storageCategory}");
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error deleting file: {ex.Message}");
            throw;
        }
    }

    private void EnsureStorageDirectoriesExist()
    {
        var categories = new[] { "maps", "tokens" };
        foreach (var category in categories)
        {
            var categoryPath = Path.Combine(_baseStoragePath, category);
            if (!Directory.Exists(categoryPath))
                Directory.CreateDirectory(categoryPath);
        }
    }

    private string GetExtensionFromMimeType(string mimeType)
    {
        return mimeType.ToLower() switch
        {
            "image/png" => ".png",
            "image/jpeg" => ".jpg",
            "image/webp" => ".webp",
            _ => ".bin"
        };
    }
}
</file>

<file path="src/DnDMapBuilder.ArchitectureTests/DnDMapBuilder.ArchitectureTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- xUnit Testing Framework -->
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />

    <!-- Architecture Testing -->
    <PackageReference Include="NetArchTest.Rules" Version="1.3.2" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Aspire.ServiceDefaults/DnDMapBuilder.Aspire.ServiceDefaults.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsAspireSharedProject>true</IsAspireSharedProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Http.Resilience" Version="10.2.0" />
    <PackageReference Include="Microsoft.Extensions.ServiceDiscovery" Version="10.2.0" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Contracts/DnDMapBuilder.Contracts.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/ICampaignRepository.cs">
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories.Interfaces;

/// <summary>
/// Repository interface for Campaign entities with domain-specific queries.
/// </summary>
public interface ICampaignRepository : IGenericRepository<Campaign>
{
    /// <summary>
    /// Gets all campaigns owned by a specific user.
    /// </summary>
    /// <param name="ownerId">The owner's user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All campaigns owned by the user</returns>
    Task<IEnumerable<Campaign>> GetByOwnerIdAsync(string ownerId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a campaign with all its missions included.
    /// </summary>
    /// <param name="id">The campaign ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The campaign with missions or null if not found</returns>
    Task<Campaign?> GetWithMissionsAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a campaign with all related data (missions, maps, and tokens).
    /// </summary>
    /// <param name="id">The campaign ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The campaign with all related entities or null if not found</returns>
    Task<Campaign?> GetCompleteAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IGameMapRepository.cs">
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories.Interfaces;

/// <summary>
/// Repository interface for GameMap entities with domain-specific queries.
/// </summary>
public interface IGameMapRepository : IGenericRepository<GameMap>
{
    /// <summary>
    /// Gets all game maps for a specific mission.
    /// </summary>
    /// <param name="missionId">The mission ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All maps in the mission</returns>
    Task<IEnumerable<GameMap>> GetByMissionIdAsync(string missionId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a game map with all its token instances included.
    /// </summary>
    /// <param name="id">The game map ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The game map with tokens or null if not found</returns>
    Task<GameMap?> GetWithTokensAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IMapTokenInstanceRepository.cs">
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories.Interfaces;

/// <summary>
/// Repository interface for MapTokenInstance entities with domain-specific queries.
/// </summary>
public interface IMapTokenInstanceRepository : IGenericRepository<MapTokenInstance>
{
    /// <summary>
    /// Gets all token instances on a specific game map.
    /// </summary>
    /// <param name="mapId">The game map ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All token instances on the map</returns>
    Task<IEnumerable<MapTokenInstance>> GetByMapIdAsync(string mapId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes all token instances on a specific game map.
    /// </summary>
    /// <param name="mapId">The game map ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    Task DeleteByMapIdAsync(string mapId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IMissionRepository.cs">
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories.Interfaces;

/// <summary>
/// Repository interface for Mission entities with domain-specific queries.
/// </summary>
public interface IMissionRepository : IGenericRepository<Mission>
{
    /// <summary>
    /// Gets all missions for a specific campaign.
    /// </summary>
    /// <param name="campaignId">The campaign ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All missions in the campaign</returns>
    Task<IEnumerable<Mission>> GetByCampaignIdAsync(string campaignId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a mission with all its game maps included.
    /// </summary>
    /// <param name="id">The mission ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The mission with maps or null if not found</returns>
    Task<Mission?> GetWithMapsAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/ITokenDefinitionRepository.cs">
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories.Interfaces;

/// <summary>
/// Repository interface for TokenDefinition entities with domain-specific queries.
/// </summary>
public interface ITokenDefinitionRepository : IGenericRepository<TokenDefinition>
{
    /// <summary>
    /// Gets all token definitions for a specific user.
    /// </summary>
    /// <param name="userId">The user ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All token definitions owned by the user</returns>
    Task<IEnumerable<TokenDefinition>> GetByUserIdAsync(string userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all token definitions of a specific type.
    /// </summary>
    /// <param name="type">The token type (e.g., "player" or "enemy")</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All tokens of the specified type</returns>
    Task<IEnumerable<TokenDefinition>> GetByTypeAsync(string type, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IUserRepository.cs">
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data.Repositories.Interfaces;

/// <summary>
/// Repository interface for User entities with domain-specific queries.
/// </summary>
public interface IUserRepository : IGenericRepository<User>
{
    /// <summary>
    /// Gets a user by email address.
    /// </summary>
    /// <param name="email">The email address</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The user or null if not found</returns>
    Task<User?> GetByEmailAsync(string email, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a user by username.
    /// </summary>
    /// <param name="username">The username</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The user or null if not found</returns>
    Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all users with pending status.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All pending users</returns>
    Task<IEnumerable<User>> GetPendingUsersAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all users with a specific role.
    /// </summary>
    /// <param name="role">The role name</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>All users with the specified role</returns>
    Task<IEnumerable<User>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/GenericRepository.cs">
using Microsoft.EntityFrameworkCore;

namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Base repository implementation providing standard CRUD operations.
/// </summary>
/// <typeparam name="T">The entity type</typeparam>
public class GenericRepository<T> : IGenericRepository<T> where T : class
{
    protected readonly DnDMapBuilderDbContext _context;
    protected readonly DbSet<T> _dbSet;

    /// <summary>
    /// Initializes a new instance of the GenericRepository class.
    /// </summary>
    /// <param name="context">The database context</param>
    public GenericRepository(DnDMapBuilderDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public virtual async Task<T?> GetByIdAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, cancellationToken);
    }

    public virtual async Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.ToListAsync(cancellationToken);
    }

    public virtual async Task<T> AddAsync(T entity, CancellationToken cancellationToken = default)
    {
        await _dbSet.AddAsync(entity, cancellationToken);
        await _context.SaveChangesAsync(cancellationToken);
        return entity;
    }

    public virtual async Task UpdateAsync(T entity, CancellationToken cancellationToken = default)
    {
        _dbSet.Update(entity);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public virtual async Task DeleteAsync(string id, CancellationToken cancellationToken = default)
    {
        var entity = await GetByIdAsync(id, cancellationToken);
        if (entity != null)
        {
            _dbSet.Remove(entity);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }

    public virtual async Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, cancellationToken) != null;
    }

    /// <summary>
    /// Gets a paginated list of all entities.
    /// </summary>
    /// <param name="pageNumber">The page number (1-based)</param>
    /// <param name="pageSize">The page size</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>A paginated response with items and metadata</returns>
    public virtual async Task<(IEnumerable<T> Items, int TotalCount)> GetPagedAsync(int pageNumber, int pageSize, CancellationToken cancellationToken = default)
    {
        // Validate pagination parameters
        if (pageNumber < 1) pageNumber = 1;
        if (pageSize < 1) pageSize = 20;
        if (pageSize > 100) pageSize = 100;

        // Get total count
        var totalCount = await _dbSet.AsNoTracking().CountAsync(cancellationToken);

        // Get paginated items
        var items = await _dbSet
            .AsNoTracking()
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(cancellationToken);

        return (items, totalCount);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/DbInitializer.cs">
using DnDMapBuilder.Data.Entities;
using Microsoft.EntityFrameworkCore;

namespace DnDMapBuilder.Data;

public static class DbInitializer
{
    public static async Task InitializeAsync(DnDMapBuilderDbContext context)
    {
        // Ensure database is created
        await context.Database.MigrateAsync();

        // Check if admin user already exists
        var adminEmail = Environment.GetEnvironmentVariable("ADMIN_EMAIL")
            ?? throw new InvalidOperationException("ADMIN_EMAIL environment variable is required");

        var adminPassword = Environment.GetEnvironmentVariable("ADMIN_DEFAULT_PASSWORD")
            ?? throw new InvalidOperationException("ADMIN_DEFAULT_PASSWORD environment variable is required");

        var existingAdmin = await context.Users
            .FirstOrDefaultAsync(u => u.Role == "admin" && u.Email == adminEmail);

        if (existingAdmin == null)
        {
            // Create new admin user
            var admin = new User
            {
                Id = Guid.NewGuid().ToString(),
                Username = "admin",
                Email = adminEmail,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(adminPassword, 11),
                Role = "admin",
                Status = "approved",
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            context.Users.Add(admin);
            await context.SaveChangesAsync();

            Console.WriteLine($"Admin user created: {adminEmail}");
        }
        else
        {
            // Update existing admin user's password
            existingAdmin.PasswordHash = BCrypt.Net.BCrypt.HashPassword(adminPassword, 11);
            existingAdmin.UpdatedAt = DateTime.UtcNow;

            await context.SaveChangesAsync();

            Console.WriteLine($"Admin user password updated: {adminEmail}");
        }
    }
}
</file>

<file path="README.md">
# DnD Map Builder - Backend API

A comprehensive ASP.NET Web API for managing D&D campaigns, missions, maps, and tokens with authentication and authorization.

## Architecture

The solution follows a layered architecture with clean separation of concerns:

### Project Organization

- **DnDMapBuilder.Contracts**: DTOs, Requests, and Response models
- **DnDMapBuilder.Data**: Entity Framework Core, Entities, DbContext, and Repositories
- **DnDMapBuilder.Application**: Business logic, services, and domain validation
- **DnDMapBuilder.Infrastructure**: Cross-cutting concerns (logging, telemetry, middleware, security)
- **DnDMapBuilder.Api**: ASP.NET Core Web API with controllers and route handlers
- **DnDMapBuilder.UnitTests**: Unit tests with mocked dependencies
- **DnDMapBuilder.IntegrationTests**: Integration tests with real database
- **DnDMapBuilder.ArchitectureTests**: Architectural rule enforcement

### Layered Architecture

```
Client (Frontend)
    ↓
API Layer (Controllers, Routes)
    ↓
Application Layer (Services, Business Logic)
    ↓
Data Layer (Repositories, EF Core)
    ↓
Database (SQL Server)
```

**Separation of Concerns:**
- Controllers handle HTTP concerns only
- Services handle business logic
- Repositories handle data access
- Entities are database models (not exposed to clients)
- DTOs are used for API contracts

## Prerequisites

- .NET 10.0 SDK
- Docker Desktop (for containerized deployment and SQL Server)
- Visual Studio 2022 or Visual Studio Code
- SQL Server 2022 (local or cloud-based)
- Git for version control

## Getting Started

### Option 1: Run with .NET Aspire (Recommended)

.NET Aspire orchestrates the SQL Server database and API application in Docker containers.

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd DnDMapBuilder
   ```

2. **Set SQL Server password**
   
   When running for the first time, Aspire will prompt for a SQL Server password. You can also set it via:
   ```bash
   dotnet user-secrets set Parameters:sql-password "YourStrong@Passw0rd" --project src/DnDMapBuilder.Aspire.AppHost
   ```

3. **Run the Aspire AppHost**
   ```bash
   cd src/DnDMapBuilder.Aspire.AppHost
   dotnet run
   ```

4. **Access the application**
   - Aspire Dashboard: https://localhost:17001 (or check console output)
   - API: https://localhost:7001 (check Aspire dashboard for actual port)
   - Swagger UI: https://localhost:7001/swagger

### Option 2: Run API Directly

1. **Set up SQL Server**
   
   Update the connection string in `src/DnDMapBuilder.Api/appsettings.json`:
   ```json
   "ConnectionStrings": {
     "DefaultConnection": "Server=localhost;Database=DnDMapBuilder;User Id=sa;Password=YourPassword;TrustServerCertificate=True;"
   }
   ```

2. **Run migrations**
   ```bash
   cd src/DnDMapBuilder.Api
   dotnet ef database update
   ```

3. **Run the API**
   ```bash
   dotnet run
   ```

4. **Access Swagger UI**
   - Navigate to: https://localhost:5001/swagger

## Database Migrations

To create a new migration:

```bash
cd src/DnDMapBuilder.Api
dotnet ef migrations add <MigrationName> --project ../DnDMapBuilder.Data
```

To update the database:

```bash
dotnet ef database update --project ../DnDMapBuilder.Data
```

## Default Admin Account

A default admin account is seeded automatically:

- **Email**: admin@dndmapbuilder.com
- **Password**: Admin123!
- **Role**: admin
- **Status**: approved

## API Endpoints

### Authentication

- `POST /api/auth/register` - Register a new user (requires admin approval)
- `POST /api/auth/login` - Login and receive JWT token
- `GET /api/auth/pending-users` - Get pending user registrations (Admin only)
- `POST /api/auth/approve-user` - Approve/reject user registration (Admin only)

### Campaigns

- `GET /api/campaigns` - Get all campaigns for the authenticated user
- `GET /api/campaigns/{id}` - Get a specific campaign
- `POST /api/campaigns` - Create a new campaign
- `PUT /api/campaigns/{id}` - Update a campaign
- `DELETE /api/campaigns/{id}` - Delete a campaign

### Missions

- `GET /api/missions/{id}` - Get a specific mission
- `GET /api/missions/campaign/{campaignId}` - Get all missions for a campaign
- `POST /api/missions` - Create a new mission
- `PUT /api/missions/{id}` - Update a mission
- `DELETE /api/missions/{id}` - Delete a mission

### Maps

- `GET /api/maps/{id}` - Get a specific map
- `GET /api/maps/mission/{missionId}` - Get all maps for a mission
- `POST /api/maps` - Create a new map
- `PUT /api/maps/{id}` - Update a map (including tokens)
- `DELETE /api/maps/{id}` - Delete a map

### Tokens

- `GET /api/tokens` - Get all tokens for the authenticated user
- `GET /api/tokens/{id}` - Get a specific token
- `POST /api/tokens` - Create a new token
- `PUT /api/tokens/{id}` - Update a token
- `DELETE /api/tokens/{id}` - Delete a token

## Authentication

The API uses JWT Bearer token authentication. To authenticate:

1. Register or login via `/api/auth/register` or `/api/auth/login`
2. Copy the token from the response
3. In Swagger UI, click "Authorize" and enter: `Bearer <your-token>`
4. Or include the header in your requests: `Authorization: Bearer <your-token>`

## Configuration

### JWT Settings

Update in `appsettings.json`:

```json
"JwtSettings": {
  "SecretKey": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
  "Issuer": "DnDMapBuilderApi",
  "Audience": "DnDMapBuilderClient",
  "ExpirationMinutes": "1440"
}
```

### CORS

CORS is configured via `CorsSettings` in `appsettings.json`:

```json
"CorsSettings": {
  "AllowedOrigins": [
    "http://localhost:3000",
    "https://yourdomain.com"
  ]
}
```

## Security Features

The API includes several security features by default:

### Security Headers

The following security headers are automatically included in all responses:
- `X-Content-Type-Options: nosniff` - Prevent MIME sniffing
- `X-Frame-Options: DENY` - Prevent clickjacking
- `X-XSS-Protection: 1; mode=block` - Enable XSS protection
- `Strict-Transport-Security: max-age=31536000` - Force HTTPS
- `Content-Security-Policy: default-src 'self'` - Restrict content to same-origin
- `Referrer-Policy: strict-origin-when-cross-origin` - Control referrer information
- `Permissions-Policy: geolocation=(), microphone=(), camera=()` - Disable dangerous APIs

### Rate Limiting

Rate limiting is enabled to prevent abuse:
- **Anonymous users**: 100 requests per minute (IP-based)
- **Authenticated users**: 300 requests per minute (User ID-based)
- **File uploads**: 10 requests per minute

Exceeded rate limits return HTTP 429 (Too Many Requests) with a Retry-After header.

### Request/Response Logging

All HTTP requests and responses are logged with:
- Request method, path, query string, and user identity
- Response status code and duration
- Correlation IDs for request tracing
- Sensitive headers (Authorization, Cookie) are sanitized in logs

### API Versioning

The API supports versioning via URL path. Current version is **v1.0**.

Routes follow the pattern: `/api/v{version:apiVersion}/[controller]`

Example: `/api/v1.0/auth/login`

## Testing

### Running Tests

Execute all tests:
```bash
dotnet test
```

Run only unit tests:
```bash
dotnet test --filter Category=Unit
```

Run only integration tests (requires database):
```bash
dotnet test --filter Category=Integration
```

Run only architecture tests:
```bash
dotnet test --filter Category=Architecture
```

### Test Coverage

The project includes:
- **75+ Unit Tests**: Services, repositories, entities, and utilities
- **8 Architecture Tests**: Enforce layered architecture and design principles
- **7 Integration Tests**: Database operations and API endpoints (with database)

Target coverage: >80% for core business logic

### Running Tests in CI/CD

Tests are automatically run in the GitHub Actions pipeline on every push to `main` or `develop` branches.

## Monitoring and Logging

### Application Logging

Structured logging is configured with Serilog:
- **Console**: Real-time log output in development
- **File**: Rolling file logs (daily rotation, 100MB max size)
- **Structured JSON**: Machine-readable log format

### Optional: External Monitoring

You can configure optional monitoring integrations by setting secrets in GitHub:

#### Azure Application Insights
```bash
APPLICATIONINSIGHTS_CONNECTION_STRING=<your-connection-string>
```

#### OpenTelemetry (OTEL)
```bash
OTEL_EXPORTER_OTLP_ENDPOINT=http://your-otel-collector:4317
```

#### Log Level Configuration
```bash
LOG_LEVEL=Information  # Options: Debug, Information, Warning, Error, Critical
```

## Docker Support

The Aspire AppHost automatically manages Docker containers for:

- SQL Server 2022 (with persistent data volume)
- The API application

Container orchestration is handled automatically by .NET Aspire.

## Project Structure

```
DnDMapBuilder/
├── src/
│   ├── DnDMapBuilder.Api/           # Web API Controllers
│   ├── DnDMapBuilder.Application/   # Business Logic & Services
│   ├── DnDMapBuilder.Contracts/     # DTOs & Request/Response Models
│   ├── DnDMapBuilder.Data/          # EF Core, Entities, Repositories
│   ├── DnDMapBuilder.Aspire.AppHost/         # Aspire Orchestration
│   └── DnDMapBuilder.Aspire.ServiceDefaults/ # Shared Aspire Config
└── DnDMapBuilder.sln
```

## Technologies Used

**Core Framework:**
- .NET 10.0
- ASP.NET Core Web API
- Entity Framework Core 10.0
- SQL Server 2022 / Azure SQL Edge

**Authentication & Security:**
- JWT Bearer Token Authentication
- BCrypt.Net for secure password hashing
- Security headers middleware
- CORS policy enforcement
- Rate limiting

**API Documentation & Testing:**
- Swagger/OpenAPI with XML documentation
- xUnit testing framework
- FluentAssertions for readable test assertions
- Moq for mocking dependencies
- AutoFixture for test data generation

**Logging & Observability:**
- Serilog for structured logging
- OpenTelemetry for distributed tracing
- Health checks endpoints
- Request/response logging middleware

**Infrastructure & Deployment:**
- Docker containerization
- GitHub Actions for CI/CD
- Alpine Linux for minimal image size
- Non-root container user for security

## Development

### Running Tests

```bash
dotnet test
```

### Code Style

The project follows standard C# coding conventions with nullable reference types enabled.

## Continuous Integration & Deployment

### GitHub Actions Pipeline

The project includes automated CI/CD pipeline (`.github/workflows/main.yml`) that:

1. **Build & Test** (on every push)
   - Restores dependencies
   - Builds in Release mode
   - Runs all unit, integration, and architecture tests

2. **Docker Image Build** (on main branch only)
   - Builds multi-platform Docker image (linux/amd64, linux/arm64)
   - Pushes to GitHub Container Registry (ghcr.io)
   - Uses layer caching for faster builds

3. **Deployment** (on main branch only)
   - Creates Docker network if needed
   - Runs database migrations
   - Deploys API container with health checks
   - Verifies deployment with health endpoints
   - Cleans up old images

### Required GitHub Secrets

To enable CI/CD deployment, configure these secrets in GitHub repository settings:

| Secret | Description | Example |
|--------|-------------|---------|
| `DB_CONNECTION_STRING` | SQL Server connection string | `Server=your-server;Database=dndmapbuilder;User Id=sa;Password=***;` |
| `SERVER_HOST` | Deployment server hostname | `api.example.com` |
| `SERVER_USERNAME` | SSH username for deployment | `deploy` |
| `SSH_PRIVATE_KEY` | SSH private key for authentication | (SSH RSA private key) |
| `SERVER_PORT` | SSH port (optional) | `22` |

### Optional Monitoring Secrets

Configure these secrets if using external monitoring services:

| Secret | Description |
|--------|-------------|
| `APPLICATIONINSIGHTS_CONNECTION_STRING` | Azure Application Insights connection string |
| `OTEL_EXPORTER_OTLP_ENDPOINT` | OpenTelemetry collector endpoint |

### Deployment Flow

```
Push to main
    ↓
Run tests in GitHub
    ↓
Build Docker image
    ↓
Push to container registry
    ↓
SSH to deployment server
    ↓
Pull latest image
    ↓
Run database migrations
    ↓
Start new API container
    ↓
Verify health checks
```

### Local Docker Deployment

To test deployment locally:

```bash
# Build Docker image
docker build -t dnd-api:latest -f src/DnDMapBuilder.Api/Dockerfile .

# Create network
docker network create dnd-network

# Run migrations
docker run --rm \
  -e ConnectionStrings__DefaultConnection="<connection-string>" \
  dnd-api:latest \
  sh -c "dotnet ef database update --project src/DnDMapBuilder.Data --startup-project src/DnDMapBuilder.Api"

# Start API container
docker run -d \
  --name dnd-api \
  -p 5000:8080 \
  -e ASPNETCORE_ENVIRONMENT=Production \
  -e ConnectionStrings__DefaultConnection="<connection-string>" \
  --network dnd-network \
  dnd-api:latest

# Check health
curl http://localhost:5000/health/live
```

## License

This project is licensed under the MIT License.
</file>

<file path="SECURITY.md">
# Security Policy and Procedures

## Overview

This document outlines the security measures, best practices, and incident response procedures for the DnDMapBuilder backend API.

## Security Features

### Authentication

- **JWT (JSON Web Tokens)** for stateless authentication
  - Configurable secret key (via environment or Key Vault)
  - HS256 signing algorithm
  - Configurable expiration (default: 24 hours)
  - Token validation includes issuer, audience, and signature checks
  - Location: `src/DnDMapBuilder.Infrastructure/Security/JwtService.cs`

### Authorization

- **Role-Based Access Control (RBAC)**
  - User role: Standard user with personal resource access
  - Admin role: Administrative operations (user approval, etc.)
  - Authorization enforced via `[Authorize]` and `[Authorize(Roles = "admin")]` attributes
  - Per-resource ownership verification for multi-tenant scenarios

### Password Security

- **BCrypt hashing** with configurable work factor
- Passwords are hashed before storage
- Password verification without storing plaintext
- Unit tests verify hash security and uniqueness
- Service: `src/DnDMapBuilder.Application/Services/PasswordService.cs`

## Data Protection

### HTTPS/TLS

- HTTPS enforcement via middleware: `app.UseHttpsRedirection()`
- All API communications encrypted in transit
- TLS 1.2+ enforced by ASP.NET Core defaults

### Secrets Management

#### Development Environment
```bash
# Set up local secrets (not in source control)
dotnet user-secrets init
dotnet user-secrets set "JwtSettings:SecretKey" "your-dev-secret-key"
dotnet user-secrets set "ConnectionStrings:DefaultConnection" "your-dev-connection-string"
```

#### Production Environment
- **Recommended:** Azure Key Vault or HashiCorp Vault
- Environment variables for secrets:
  - `JwtSettings__SecretKey`
  - `ConnectionStrings__DefaultConnection`
  - `Database__ConnectionString`

### SQL Injection Prevention

- **Entity Framework Core** with parameterized queries
- All LINQ queries use parameter placeholders
- No string concatenation or raw SQL for user-provided data

### XSS Protection

- **Security Headers Middleware** configured:
  - X-Content-Type-Options: nosniff
  - X-Frame-Options: DENY
  - X-XSS-Protection: 1; mode=block
  - Strict-Transport-Security for HTTPS enforcement
  - Content-Security-Policy: default-src 'self'

### CORS (Cross-Origin Resource Sharing)

- Whitelist-based CORS configuration (not AllowAll)
- Configurable allowed origins
- Credentials support enabled for authenticated requests

## API Security

### Rate Limiting

- Anonymous users: 100 requests/minute
- Authenticated users: 300 requests/minute
- File uploads: 10 requests/minute
- Returns 429 (Too Many Requests) with Retry-After header

### File Upload Security

- File size limits: Maps (5MB), Tokens (2MB), Default (10MB)
- MIME type validation: image/png, image/jpeg, image/webp
- Storage isolation and directory traversal protection
- Comprehensive validation service with unit tests

## Logging and Monitoring

### Structured Logging

- Serilog for structured, machine-readable logs
- Correlation IDs for request tracing
- Sensitive data filtering to prevent leakage
- Environment-specific log levels (Debug in dev, Warning in prod)

### Request/Response Logging

- RequestResponseLoggingMiddleware logs requests, responses, and duration
- User identity tracking for authenticated requests
- Correlation ID propagation
- Excludes health check endpoints

### OpenTelemetry Tracing

- Distributed tracing for request flow
- Custom metrics for security events
- OTLP exporter for centralized collection

## OWASP Top 10 Compliance

| Vulnerability | Status | Details |
|---|---|---|
| A01: Broken Access Control | ✓ | Authorization checks; resource ownership verified |
| A02: Cryptographic Failures | ✓ | HTTPS enforced; BCrypt hashing; no hardcoded secrets |
| A03: Injection | ✓ | EF Core parameterized queries; no command injection |
| A04: Insecure Design | ✓ | Security headers; rate limiting; authentication required |
| A05: Security Misconfiguration | ✓ | Security headers; proper CORS; reduced SQL logging |
| A06: Vulnerable Components | ✓ | No vulnerable packages; .NET 10.0 latest |
| A07: Authentication Failures | ✓ | JWT; BCrypt; user status verification |
| A08: Data Integrity | ✓ | Secure CI/CD; code review required |
| A09: Logging & Monitoring | ✓ | Serilog; request logging; OpenTelemetry tracing |
| A10: SSRF | ✓ | No user-controlled URLs; no untrusted outbound requests |

## Dependency Vulnerability Status

**Result:** No vulnerable packages identified
- All NuGet packages up-to-date
- Regular automated scanning recommended
- .NET 10.0 runtime (latest stable)

## Best Practices for Deployment

### Pre-Deployment Checklist

- [ ] All tests passing (unit, integration, architecture)
- [ ] No vulnerable dependencies (`dotnet list package --vulnerable`)
- [ ] Secrets configured in Key Vault (not in code)
- [ ] CORS origins configured for production domain
- [ ] Security headers configured and tested
- [ ] Database migrations tested
- [ ] Health checks verified
- [ ] Monitoring and alerting configured

### Security Update Frequency

- Critical: Immediate (within 24 hours)
- High: Within 1 week
- Medium: Within 2 weeks
- Low: Next scheduled release

## Incident Response

### Reporting Security Issues

DO NOT create public GitHub issues for security vulnerabilities.

Contact project maintainers directly with:
- Detailed vulnerability description
- Reproduction steps
- Severity assessment
- Allow 30 days for patch development

### Response Process

1. Acknowledge receipt within 24 hours
2. Assess severity and impact
3. Develop and test patch
4. Release security update with advisory
5. Notify affected users

## Regular Security Activities

- **Daily:** Monitor logs for errors; check health endpoints
- **Weekly:** Review auth logs; check dependency notifications
- **Monthly:** Security log analysis; vulnerability scanning
- **Quarterly:** Full security audit; penetration testing prep
- **Annually:** Third-party pen testing; compliance verification

## References

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [ASP.NET Core Security](https://learn.microsoft.com/aspnet/core/security)
- [JWT Best Practices](https://tools.ietf.org/html/rfc7519)
</file>

<file path=".claude/commands/execute_prompt_plan.md">
## You are a senior .NET engineer implementing refactorings 
- Read the @../BACKEND_ENHANCEMENT_PROMPT_PLAN.md file and identify pending steps
- Create a new branch with the feature name from the context session if it does not exist. You only work on this branch
- Implement the step and run all tests and build the solution
- If both succeed  update the step status to done. Else fix the errors
- continue with the next step.
</file>

<file path="src/DnDMapBuilder.Api/Dockerfile">
# Stage 1: Build stage using SDK image
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

# Copy solution and project files to optimize layer caching
COPY ["DnDMapBuilder.sln", "./"]
COPY ["src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj", "src/DnDMapBuilder.Api/"]
COPY ["src/DnDMapBuilder.Application/DnDMapBuilder.Application.csproj", "src/DnDMapBuilder.Application/"]
COPY ["src/DnDMapBuilder.Aspire.ServiceDefaults/DnDMapBuilder.Aspire.ServiceDefaults.csproj", "src/DnDMapBuilder.Aspire.ServiceDefaults/"]
COPY ["src/DnDMapBuilder.Contracts/DnDMapBuilder.Contracts.csproj", "src/DnDMapBuilder.Contracts/"]
COPY ["src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj", "src/DnDMapBuilder.Data/"]
COPY ["src/DnDMapBuilder.Infrastructure/DnDMapBuilder.Infrastructure.csproj", "src/DnDMapBuilder.Infrastructure/"]

# Restore NuGet dependencies (separate layer for better caching)
RUN dotnet restore "src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj"

# Copy remaining source code
COPY . .

# Build the application in Release mode
WORKDIR "/src/src/DnDMapBuilder.Api"
RUN dotnet build "DnDMapBuilder.Api.csproj" -c Release -o /app/build --no-restore

# Stage 2: Publish stage
FROM build AS publish
RUN dotnet publish "DnDMapBuilder.Api.csproj" \
    -c Release \
    -o /app/publish \
    /p:UseAppHost=false \
    /p:PublishReadyToRun=true

# Stage 3: Runtime stage using minimal runtime image
FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine AS final

# Install curl for health checks
RUN apk add --no-cache curl

# Create non-root user for security
RUN addgroup -g 1001 -S dotnetuser && \
    adduser -u 1001 -S dotnetuser -G dotnetuser

WORKDIR /app

# Copy published application from publish stage
COPY --from=publish --chown=dotnetuser:dotnetuser /app/publish .

# Create uploads directory with proper permissions
RUN mkdir -p /app/wwwroot/uploads && \
    chown -R dotnetuser:dotnetuser /app

# Switch to non-root user
USER dotnetuser

# Expose ports
EXPOSE 8080
EXPOSE 8443

# Health check configuration
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health/live || exit 1

# Set environment for .NET to use the non-root user
ENV DOTNET_RUNNING_IN_CONTAINER=true
ENV ASPNETCORE_HTTP_PORT=8080
ENV ASPNETCORE_HTTPS_PORT=8443

# Entry point
ENTRYPOINT ["dotnet", "DnDMapBuilder.Api.dll"]
</file>

<file path="src/DnDMapBuilder.Application/Services/CampaignService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Application.Services;

public class CampaignService : ICampaignService
{
    private readonly ICampaignRepository _campaignRepository;

    public CampaignService(ICampaignRepository campaignRepository)
    {
        _campaignRepository = campaignRepository;
    }

    public async Task<CampaignDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetCompleteAsync(id, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        return campaign.ToDto();
    }

    public async Task<IEnumerable<CampaignDto>> GetUserCampaignsAsync(string userId, CancellationToken cancellationToken = default)
    {
        var campaigns = await _campaignRepository.GetByOwnerIdAsync(userId, cancellationToken);
        return campaigns.Select(c => c.ToDto());
    }

    public async Task<CampaignDto> CreateAsync(CreateCampaignRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = new Campaign
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            Description = request.Description,
            OwnerId = userId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _campaignRepository.AddAsync(campaign, cancellationToken);
        return campaign.ToDto();
    }

    public async Task<CampaignDto?> UpdateAsync(string id, UpdateCampaignRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(id, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        campaign.Name = request.Name;
        campaign.Description = request.Description;
        campaign.UpdatedAt = DateTime.UtcNow;

        await _campaignRepository.UpdateAsync(campaign, cancellationToken);
        return campaign.ToDto();
    }

    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(id, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return false;
        }

        await _campaignRepository.DeleteAsync(id, cancellationToken);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/MissionService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Application.Services;

public class MissionService : IMissionService
{
    private readonly IMissionRepository _missionRepository;
    private readonly ICampaignRepository _campaignRepository;

    public MissionService(IMissionRepository missionRepository, ICampaignRepository campaignRepository)
    {
        _missionRepository = missionRepository;
        _campaignRepository = campaignRepository;
    }

    public async Task<MissionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetWithMapsAsync(id, cancellationToken);
        if (mission == null)
        {
            return null;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        return mission.ToDto();
    }

    public async Task<IEnumerable<MissionDto>> GetByCampaignIdAsync(string campaignId, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(campaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return Enumerable.Empty<MissionDto>();
        }

        var missions = await _missionRepository.GetByCampaignIdAsync(campaignId, cancellationToken);
        return missions.Select(m => m.ToDto());
    }

    public async Task<MissionDto> CreateAsync(CreateMissionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(request.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            throw new UnauthorizedAccessException("You don't have permission to add missions to this campaign.");
        }

        var mission = new Mission
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            Description = request.Description,
            CampaignId = request.CampaignId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        await _missionRepository.AddAsync(mission, cancellationToken);
        return mission.ToDto();
    }

    public async Task<MissionDto?> UpdateAsync(string id, UpdateMissionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetByIdAsync(id, cancellationToken);
        if (mission == null)
        {
            return null;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }

        mission.Name = request.Name;
        mission.Description = request.Description;
        mission.UpdatedAt = DateTime.UtcNow;

        await _missionRepository.UpdateAsync(mission, cancellationToken);
        return mission.ToDto();
    }

    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetByIdAsync(id, cancellationToken);
        if (mission == null)
        {
            return false;
        }

        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return false;
        }

        await _missionRepository.DeleteAsync(id, cancellationToken);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/DnDMapBuilder.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
    <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="8.15.0" />
    <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.15.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Data/Repositories/CampaignRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Repository implementation for Campaign entities.
/// </summary>
public class CampaignRepository : GenericRepository<Campaign>, ICampaignRepository
{
    /// <summary>
    /// Initializes a new instance of the CampaignRepository class.
    /// </summary>
    /// <param name="context">The database context</param>
    public CampaignRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<Campaign>> GetByOwnerIdAsync(string ownerId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(c => c.OwnerId == ownerId)
            .Include(c => c.Missions)
            .ToListAsync(cancellationToken);
    }

    public async Task<Campaign?> GetWithMissionsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(c => c.Missions)
            .FirstOrDefaultAsync(c => c.Id == id, cancellationToken);
    }

    public async Task<Campaign?> GetCompleteAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(c => c.Missions)
                .ThenInclude(m => m.Maps)
                    .ThenInclude(map => map.Tokens)
            .FirstOrDefaultAsync(c => c.Id == id, cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/GameMapRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Repository implementation for GameMap entities.
/// </summary>
public class GameMapRepository : GenericRepository<GameMap>, IGameMapRepository
{
    /// <summary>
    /// Initializes a new instance of the GameMapRepository class.
    /// </summary>
    /// <param name="context">The database context</param>
    public GameMapRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<GameMap>> GetByMissionIdAsync(string missionId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(m => m.MissionId == missionId)
            .Include(m => m.Tokens)
            .ToListAsync(cancellationToken);
    }

    public async Task<GameMap?> GetWithTokensAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(m => m.Tokens)
            .FirstOrDefaultAsync(m => m.Id == id, cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/MapTokenInstanceRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Repository implementation for MapTokenInstance entities.
/// </summary>
public class MapTokenInstanceRepository : GenericRepository<MapTokenInstance>, IMapTokenInstanceRepository
{
    /// <summary>
    /// Initializes a new instance of the MapTokenInstanceRepository class.
    /// </summary>
    /// <param name="context">The database context</param>
    public MapTokenInstanceRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<MapTokenInstance>> GetByMapIdAsync(string mapId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(t => t.MapId == mapId)
            .Include(t => t.Token)
            .ToListAsync(cancellationToken);
    }

    public async Task DeleteByMapIdAsync(string mapId, CancellationToken cancellationToken = default)
    {
        var tokens = await _dbSet.Where(t => t.MapId == mapId).ToListAsync(cancellationToken);
        _dbSet.RemoveRange(tokens);
        await _context.SaveChangesAsync(cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/MissionRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Repository implementation for Mission entities.
/// </summary>
public class MissionRepository : GenericRepository<Mission>, IMissionRepository
{
    /// <summary>
    /// Initializes a new instance of the MissionRepository class.
    /// </summary>
    /// <param name="context">The database context</param>
    public MissionRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<Mission>> GetByCampaignIdAsync(string campaignId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(m => m.CampaignId == campaignId)
            .Include(m => m.Maps)
            .ToListAsync(cancellationToken);
    }

    public async Task<Mission?> GetWithMapsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(m => m.Maps)
            .FirstOrDefaultAsync(m => m.Id == id, cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/TokenDefinitionRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Repository implementation for TokenDefinition entities.
/// </summary>
public class TokenDefinitionRepository : GenericRepository<TokenDefinition>, ITokenDefinitionRepository
{
    /// <summary>
    /// Initializes a new instance of the TokenDefinitionRepository class.
    /// </summary>
    /// <param name="context">The database context</param>
    public TokenDefinitionRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<IEnumerable<TokenDefinition>> GetByUserIdAsync(string userId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(t => t.UserId == userId)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<TokenDefinition>> GetByTypeAsync(string type, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(t => t.Type == type)
            .ToListAsync(cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/UserRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Data.Repositories;

/// <summary>
/// Repository implementation for User entities.
/// </summary>
public class UserRepository : GenericRepository<User>, IUserRepository
{
    /// <summary>
    /// Initializes a new instance of the UserRepository class.
    /// </summary>
    /// <param name="context">The database context</param>
    public UserRepository(DnDMapBuilderDbContext context) : base(context) { }

    public async Task<User?> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().FirstOrDefaultAsync(u => u.Email == email, cancellationToken);
    }

    public async Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().FirstOrDefaultAsync(u => u.Username == username, cancellationToken);
    }

    public async Task<IEnumerable<User>> GetPendingUsersAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().Where(u => u.Status == "pending").ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<User>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().Where(u => u.Role == role).ToListAsync(cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/MigrationRunner.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace DnDMapBuilder.Data;

/// <summary>
/// Utility class for running database migrations and seeding.
/// Can be used by CI/CD pipelines to run migrations before deployment.
/// </summary>
public class MigrationRunner
{
    private readonly DnDMapBuilderDbContext _context;
    private readonly ILogger<MigrationRunner> _logger;

    public MigrationRunner(DnDMapBuilderDbContext context, ILogger<MigrationRunner> logger)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Runs all pending migrations and seeds the database with initial data.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if migrations were applied successfully, false if an error occurred</returns>
    public async Task<bool> MigrateAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("Starting database migration...");

            // Get pending migrations
            var pendingMigrations = (await _context.Database.GetPendingMigrationsAsync(cancellationToken)).ToList();

            if (pendingMigrations.Any())
            {
                _logger.LogInformation("Found {PendingMigrationCount} pending migrations: {Migrations}",
                    pendingMigrations.Count,
                    string.Join(", ", pendingMigrations));

                // Apply migrations
                await _context.Database.MigrateAsync(cancellationToken);
                _logger.LogInformation(" Database migrations completed successfully");
            }
            else
            {
                _logger.LogInformation(" Database is up to date. No migrations to apply.");
            }

            // Initialize database with seed data if needed
            _logger.LogInformation("Initializing database with seed data...");
            await DbInitializer.InitializeAsync(_context);
            _logger.LogInformation(" Database initialization completed successfully");

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error occurred during database migration");
            return false;
        }
    }

    /// <summary>
    /// Runs all pending migrations without seeding data.
    /// Useful for migration-only operations in CI/CD pipelines.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>True if migrations were applied successfully, false if an error occurred</returns>
    public async Task<bool> MigrateOnlyAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("Starting database migration (migration only, no seeding)...");

            // Get pending migrations
            var pendingMigrations = (await _context.Database.GetPendingMigrationsAsync(cancellationToken)).ToList();

            if (pendingMigrations.Any())
            {
                _logger.LogInformation("Found {PendingMigrationCount} pending migrations: {Migrations}",
                    pendingMigrations.Count,
                    string.Join(", ", pendingMigrations));

                // Apply migrations
                await _context.Database.MigrateAsync(cancellationToken);
                _logger.LogInformation("Database migrations completed successfully");
            }
            else
            {
                _logger.LogInformation("Database is up to date. No migrations to apply.");
            }

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error occurred during database migration");
            return false;
        }
    }

    /// <summary>
    /// Gets information about the current database state.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    public async Task<DatabaseInfo> GetDatabaseInfoAsync(CancellationToken cancellationToken = default)
    {
        var appliedMigrations = (await _context.Database.GetAppliedMigrationsAsync(cancellationToken)).ToList();
        var pendingMigrations = (await _context.Database.GetPendingMigrationsAsync(cancellationToken)).ToList();

        return new DatabaseInfo
        {
            AppliedMigrationsCount = appliedMigrations.Count,
            AppliedMigrations = appliedMigrations,
            PendingMigrationsCount = pendingMigrations.Count,
            PendingMigrations = pendingMigrations,
            IsDatabaseCreated = await _context.Database.CanConnectAsync(cancellationToken)
        };
    }
}

/// <summary>
/// Information about the current database state.
/// </summary>
public class DatabaseInfo
{
    public int AppliedMigrationsCount { get; set; }
    public List<string> AppliedMigrations { get; set; } = new();
    public int PendingMigrationsCount { get; set; }
    public List<string> PendingMigrations { get; set; } = new();
    public bool IsDatabaseCreated { get; set; }

    public override string ToString()
    {
        return $"Database Info:\n" +
               $"  - Is Created: {IsDatabaseCreated}\n" +
               $"  - Applied Migrations: {AppliedMigrationsCount}\n" +
               $"    {string.Join("\n    ", AppliedMigrations.Select(m => $"{m}"))}\n" +
               $"  - Pending Migrations: {PendingMigrationsCount}\n" +
               $"    {string.Join("\n    ", PendingMigrations.Select(m => $"{m}"))}";
    }
}
</file>

<file path="src/DnDMapBuilder.IntegrationTests/DnDMapBuilder.IntegrationTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- xUnit Testing Framework -->
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />

    <!-- Assertion Library -->
    <PackageReference Include="FluentAssertions" Version="8.8.0" />

    <!-- ASP.NET Core Testing -->
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="10.0.2" />

    <!-- Database Testing -->
    <PackageReference Include="Testcontainers" Version="4.10.0" />
    <PackageReference Include="Testcontainers.MsSql" Version="4.10.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="10.0.2" />

    <!-- Test Data Generation -->
    <PackageReference Include="AutoFixture.Xunit2" Version="4.18.1" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.UnitTests/Repositories/GenericRepositoryTests.cs">
using Microsoft.EntityFrameworkCore;
using Xunit;
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;

namespace DnDMapBuilder.UnitTests.Repositories;

/// <summary>
/// Unit tests for GenericRepository CRUD operations using in-memory database.
/// </summary>
public class GenericRepositoryTests
{
    private DnDMapBuilderDbContext CreateInMemoryDbContext()
    {
        var options = new DbContextOptionsBuilder<DnDMapBuilderDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        return new DnDMapBuilderDbContext(options);
    }

    [Fact]
    public async Task AddAsync_ShouldAddEntity_WhenCalledWithValidEntity()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);
        var user = new User
        {
            Id = Guid.NewGuid().ToString(),
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        // Act
        await repository.AddAsync(user);
        await context.SaveChangesAsync();

        // Assert
        var addedUser = await repository.GetByIdAsync(user.Id);
        Assert.NotNull(addedUser);
        Assert.Equal("testuser", addedUser.Username);
    }

    [Fact]
    public async Task GetByIdAsync_ShouldReturnEntity_WhenEntityExists()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();

        var repository = new GenericRepository<User>(context);

        // Act
        var retrievedUser = await repository.GetByIdAsync(userId);

        // Assert
        Assert.NotNull(retrievedUser);
        Assert.Equal(userId, retrievedUser.Id);
        Assert.Equal("testuser", retrievedUser.Username);
    }

    [Fact]
    public async Task GetByIdAsync_ShouldReturnNull_WhenEntityDoesNotExist()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);

        // Act
        var result = await repository.GetByIdAsync("non-existent-id");

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public async Task GetAllAsync_ShouldReturnAllEntities()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var user1 = new User { Id = "1", Username = "user1", Email = "u1@test.com", PasswordHash = "hash", Role = "user", Status = "pending", CreatedAt = DateTime.UtcNow, UpdatedAt = DateTime.UtcNow };
        var user2 = new User { Id = "2", Username = "user2", Email = "u2@test.com", PasswordHash = "hash", Role = "user", Status = "pending", CreatedAt = DateTime.UtcNow, UpdatedAt = DateTime.UtcNow };
        context.Users.AddRange(user1, user2);
        await context.SaveChangesAsync();

        var repository = new GenericRepository<User>(context);

        // Act
        var users = await repository.GetAllAsync();

        // Assert
        Assert.NotNull(users);
        Assert.Equal(2, users.Count());
    }

    [Fact]
    public async Task UpdateAsync_ShouldUpdateEntity_WhenCalledWithValidEntity()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "originalname",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();

        var repository = new GenericRepository<User>(context);
        user.Username = "updatedname";

        // Act
        await repository.UpdateAsync(user);
        await context.SaveChangesAsync();

        // Assert
        var updatedUser = await repository.GetByIdAsync(userId);
        Assert.NotNull(updatedUser);
        Assert.Equal("updatedname", updatedUser.Username);
    }
    [Fact]
    public async Task DeleteAsync_ShouldDeleteEntity_WhenCalledWithValidId()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();

        var repository = new GenericRepository<User>(context);

        // Act
        await repository.DeleteAsync(userId);

        // Assert
        var deletedUser = await repository.GetByIdAsync(userId);
        Assert.Null(deletedUser);
    }

    [Fact]
    public async Task ExistsAsync_ShouldReturnTrue_WhenEntityExists()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();

        var repository = new GenericRepository<User>(context);

        // Act
        var exists = await repository.ExistsAsync(userId);

        // Assert
        Assert.True(exists);
    }

    [Fact]
    public async Task ExistsAsync_ShouldReturnFalse_WhenEntityDoesNotExist()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);

        // Act
        var exists = await repository.ExistsAsync("non-existent-id");

        // Assert
        Assert.False(exists);
    }

    [Fact]
    public async Task AddAsync_ShouldRespectCancellationToken()
    {
        // Arrange
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);
        var user = new User
        {
            Id = Guid.NewGuid().ToString(),
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        var cts = new CancellationTokenSource();
        cts.Cancel();

        // Act & Assert - Repository methods accept CancellationToken, but the test verifies it's handled
        try
        {
            await repository.AddAsync(user, cts.Token);
        }
        catch (OperationCanceledException)
        {
            // Expected behavior
        }
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/DnDMapBuilder.UnitTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- xUnit Testing Framework -->
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />

    <!-- Assertion Library -->
    <PackageReference Include="FluentAssertions" Version="8.8.0" />

    <!-- Mocking Framework -->
    <PackageReference Include="Moq" Version="4.20.72" />

    <!-- Test Data Generation -->
    <PackageReference Include="AutoFixture.Xunit2" Version="4.18.1" />

    <!-- Entity Framework Core In-Memory Database for Unit Tests -->
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="10.0.0" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path=".gitignore">
# Build results
bin/
obj/
Debug/
Release/
x64/
x86/
*.o
*.a
*.so
*.exe
*.dll
*.pdb
*.mdb

# All project build directories
src/**/bin/
src/**/obj/
src/**/Debug/
src/**/Release/

# Visual Studio and Rider cache and settings
.vs/
.vscode/
.idea/
*.suo
*.user
*.userosscache
*.sln.docstates
*.sln.DotSettings.user

# ReSharper
.resharper
.resharper.user
*.resharper.user
_ReSharper*/
*_resharper.jfm

# JetBrains Rider
.idea/
*.sln.iml
riderModule.iml

# NuGet
*.nupkg
*.snupkg
.nuget/
packages/
.packages/
src/**/packages/
*.nuget.props
*.nuget.targets

# Local environment files
.env
.env.local
appsettings.local.json
appsettings.Development.json

# macOS
.DS_Store
.AppleDouble
.LSOverride
*.swp
*.swo

# Windows
Thumbs.db
Desktop.ini

# Logs
logs/
*.log
npm-debug.log*

# Temporary files
*.tmp
*.temp
*~

# Build and test artifacts
TestResults/
coverage/
.coverage
*.trx

# ASP.NET Core
Properties/launchSettings.json
launchSettings.json

# Uploaded files (user content)
src/DnDMapBuilder.Api/wwwroot/uploads/

# Entity Framework Core
# Note: Migrations SHOULD be committed to track database schema changes

# Azure DevOps
.vs_extensions/

# Global settings
global.json
DnDMapBuilder.sln.DotSettings.user
BACKEND_ENHANCEMENT_PROMPT_PLAN.md
</file>

<file path="src/DnDMapBuilder.Api/Controllers/CampaignsController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

/// <summary>
/// Controller for managing campaigns.
/// </summary>
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class CampaignsController : ControllerBase
{
    private readonly ICampaignService _campaignService;

    public CampaignsController(ICampaignService campaignService)
    {
        _campaignService = campaignService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    [HttpGet]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<IEnumerable<CampaignDto>>>> GetUserCampaigns(CancellationToken cancellationToken)
    {
        var campaigns = await _campaignService.GetUserCampaignsAsync(GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<CampaignDto>>(true, campaigns));
    }

    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> GetCampaign(string id, CancellationToken cancellationToken)
    {
        var campaign = await _campaignService.GetByIdAsync(id, GetUserId(), cancellationToken);

        if (campaign == null)
        {
            return NotFound(new ApiResponse<CampaignDto>(false, null, "Campaign not found."));
        }

        return Ok(new ApiResponse<CampaignDto>(true, campaign));
    }

    [HttpPost]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> CreateCampaign([FromBody] CreateCampaignRequest request, CancellationToken cancellationToken)
    {
        var campaign = await _campaignService.CreateAsync(request, GetUserId(), cancellationToken);
        return CreatedAtAction(nameof(GetCampaign), new { id = campaign.Id }, new ApiResponse<CampaignDto>(true, campaign, "Campaign created."));
    }

    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> UpdateCampaign(string id, [FromBody] UpdateCampaignRequest request, CancellationToken cancellationToken)
    {
        var campaign = await _campaignService.UpdateAsync(id, request, GetUserId(), cancellationToken);

        if (campaign == null)
        {
            return NotFound(new ApiResponse<CampaignDto>(false, null, "Campaign not found."));
        }

        return Ok(new ApiResponse<CampaignDto>(true, campaign, "Campaign updated."));
    }

    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteCampaign(string id, CancellationToken cancellationToken)
    {
        var result = await _campaignService.DeleteAsync(id, GetUserId(), cancellationToken);

        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Campaign not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Campaign deleted."));
    }
}
</file>

<file path="src/DnDMapBuilder.Api/Controllers/MissionsController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

/// <summary>
/// Controller for managing missions within campaigns.
/// </summary>
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class MissionsController : ControllerBase
{
    private readonly IMissionService _missionService;

    public MissionsController(IMissionService missionService)
    {
        _missionService = missionService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    /// <summary>
    /// Gets a mission by ID.
    /// </summary>
    /// <param name="id">The mission ID</param>
    /// <returns>The mission details or 404 if not found</returns>
    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<MissionDto>>> GetMission(string id, CancellationToken cancellationToken)
    {
        var mission = await _missionService.GetByIdAsync(id, GetUserId(), cancellationToken);

        if (mission == null)
        {
            return NotFound(new ApiResponse<MissionDto>(false, null, "Mission not found."));
        }

        return Ok(new ApiResponse<MissionDto>(true, mission));
    }

    /// <summary>
    /// Gets all missions for a specific campaign.
    /// </summary>
    /// <param name="campaignId">The campaign ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of missions in the campaign</returns>
    [HttpGet("campaign/{campaignId}")]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<IEnumerable<MissionDto>>>> GetMissionsByCampaign(string campaignId, CancellationToken cancellationToken)
    {
        var missions = await _missionService.GetByCampaignIdAsync(campaignId, GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<MissionDto>>(true, missions));
    }

    /// <summary>
    /// Creates a new mission in a campaign.
    /// </summary>
    /// <param name="request">Create mission request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created mission details or 403 if unauthorized</returns>
    [HttpPost]
    public async Task<ActionResult<ApiResponse<MissionDto>>> CreateMission([FromBody] CreateMissionRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var mission = await _missionService.CreateAsync(request, GetUserId(), cancellationToken);
            return CreatedAtAction(nameof(GetMission), new { id = mission.Id }, new ApiResponse<MissionDto>(true, mission, "Mission created."));
        }
        catch (UnauthorizedAccessException ex)
        {
            return Forbid(ex.Message);
        }
    }

    /// <summary>
    /// Updates an existing mission.
    /// </summary>
    /// <param name="id">The mission ID to update</param>
    /// <param name="request">Update mission request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated mission details or 404 if not found</returns>
    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<MissionDto>>> UpdateMission(string id, [FromBody] UpdateMissionRequest request, CancellationToken cancellationToken)
    {
        var mission = await _missionService.UpdateAsync(id, request, GetUserId(), cancellationToken);

        if (mission == null)
        {
            return NotFound(new ApiResponse<MissionDto>(false, null, "Mission not found."));
        }

        return Ok(new ApiResponse<MissionDto>(true, mission, "Mission updated."));
    }

    /// <summary>
    /// Deletes a mission.
    /// </summary>
    /// <param name="id">The mission ID to delete</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Success indicator or 404 if not found</returns>
    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteMission(string id, CancellationToken cancellationToken)
    {
        var result = await _missionService.DeleteAsync(id, GetUserId(), cancellationToken);

        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Mission not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Mission deleted."));
    }
}
</file>

<file path="src/DnDMapBuilder.Api/appsettings.json">
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=sqlserver;Database=dndmapbuilder;User Id=sa;Password=s_2.Z6NWn*Jj17esJD6p+E;TrustServerCertificate=True;"
  },
  "JwtSettings": {
    "SecretKey": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
    "Issuer": "DnDMapBuilderApi",
    "Audience": "DnDMapBuilderClient",
    "ExpirationMinutes": "1440"
  },
  "CorsSettings": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "https://localhost:3000"
    ]
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  },
  "AllowedHosts": "*"
}
</file>

<file path="src/DnDMapBuilder.Application/Services/AuthService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for authentication operations (user login and token generation).
/// </summary>
public class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IJwtService _jwtService;
    private readonly IPasswordService _passwordService;

    public AuthService(IUserRepository userRepository, IJwtService jwtService, IPasswordService passwordService)
    {
        _userRepository = userRepository;
        _jwtService = jwtService;
        _passwordService = passwordService;
    }

    /// <summary>
    /// Authenticates a user and returns a JWT token.
    /// </summary>
    /// <param name="request">Login request with email and password</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Authentication response with token or null if login fails</returns>
    public async Task<AuthResponse?> LoginAsync(LoginRequest request, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByEmailAsync(request.Email, cancellationToken);
        if (user == null)
        {
            return null; // User not found
        }

        if (!_passwordService.VerifyPassword(request.Password, user.PasswordHash))
        {
            return null; // Invalid password
        }

        if (user.Status != "approved" && user.Role != "admin")
        {
            return null; // User not approved yet
        }

        var token = _jwtService.GenerateToken(user.Id, user.Email, user.Role);

        return new AuthResponse(
            token,
            user.Id,
            user.Username,
            user.Email,
            user.Role,
            user.Status
        );
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/DnDMapBuilderDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    partial class DnDMapBuilderDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "10.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("OwnerId");

                    b.ToTable("Campaigns");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("Cols")
                        .HasColumnType("int");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");

                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Rows")
                        .HasColumnType("int");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("MissionId");

                    b.ToTable("GameMaps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("X")
                        .HasColumnType("int");

                    b.Property<int>("Y")
                        .HasColumnType("int");

                    b.HasKey("Id");

                    b.HasIndex("MapId");

                    b.HasIndex("TokenId");

                    b.ToTable("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.HasKey("Id");

                    b.HasIndex("CampaignId");

                    b.ToTable("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");

                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");

                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");

                    b.Property<int>("Size")
                        .HasColumnType("int");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("TokenDefinitions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");

                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");

                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");

                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.HasIndex("Username")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();

                    b.Navigation("Owner");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Mission");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Map");

                    b.Navigation("Token");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Campaign");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("User");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });

            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");

                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="DnDMapBuilder.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Api", "src\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj", "{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Contracts", "src\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj", "{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Application", "src\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj", "{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Data", "src\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj", "{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Aspire.ServiceDefaults", "src\DnDMapBuilder.Aspire.ServiceDefaults\DnDMapBuilder.Aspire.ServiceDefaults.csproj", "{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.AppHost", "src\DnDMapBuilder.AppHost\DnDMapBuilder.AppHost.csproj", "{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.Infrastructure", "src\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj", "{E7B8C9D0-E1F2-4A5B-9D2E-3F4A5B6C7D8E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.UnitTests", "src\DnDMapBuilder.UnitTests\DnDMapBuilder.UnitTests.csproj", "{F8C9D0E1-F2A3-4B5C-0E1F-2A3B4C5D6E7F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.IntegrationTests", "src\DnDMapBuilder.IntegrationTests\DnDMapBuilder.IntegrationTests.csproj", "{A9D0E1F2-3A4B-4C5D-1E2F-3A4B5C6D7E8F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DnDMapBuilder.ArchitectureTests", "src\DnDMapBuilder.ArchitectureTests\DnDMapBuilder.ArchitectureTests.csproj", "{B0E1F2A3-4B5C-4D5E-2F3A-4B5C6D7E8F9A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1B2C3D4-E5F6-4A5B-8C9D-0E1F2A3B4C5D}.Release|Any CPU.Build.0 = Release|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B2C3D4E5-F6A7-4B5C-9D0E-1F2A3B4C5D6E}.Release|Any CPU.Build.0 = Release|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C3D4E5F6-A7B8-4C5D-0E1F-2A3B4C5D6E7F}.Release|Any CPU.Build.0 = Release|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D4E5F6A7-B8C9-4D5E-1F2A-3B4C5D6E7F8A}.Release|Any CPU.Build.0 = Release|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F6A7B8C9-D0E1-4F5A-3B4C-5D6E7F8A9B0C}.Release|Any CPU.Build.0 = Release|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{89F87745-B0C5-4D3B-BEA2-CEB28F10F513}.Release|Any CPU.Build.0 = Release|Any CPU
		{E7B8C9D0-E1F2-4A5B-9D2E-3F4A5B6C7D8E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E7B8C9D0-E1F2-4A5B-9D2E-3F4A5B6C7D8E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E7B8C9D0-E1F2-4A5B-9D2E-3F4A5B6C7D8E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E7B8C9D0-E1F2-4A5B-9D2E-3F4A5B6C7D8E}.Release|Any CPU.Build.0 = Release|Any CPU
		{F8C9D0E1-F2A3-4B5C-0E1F-2A3B4C5D6E7F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F8C9D0E1-F2A3-4B5C-0E1F-2A3B4C5D6E7F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F8C9D0E1-F2A3-4B5C-0E1F-2A3B4C5D6E7F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F8C9D0E1-F2A3-4B5C-0E1F-2A3B4C5D6E7F}.Release|Any CPU.Build.0 = Release|Any CPU
		{A9D0E1F2-3A4B-4C5D-1E2F-3A4B5C6D7E8F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A9D0E1F2-3A4B-4C5D-1E2F-3A4B5C6D7E8F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A9D0E1F2-3A4B-4C5D-1E2F-3A4B5C6D7E8F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A9D0E1F2-3A4B-4C5D-1E2F-3A4B5C6D7E8F}.Release|Any CPU.Build.0 = Release|Any CPU
		{B0E1F2A3-4B5C-4D5E-2F3A-4B5C6D7E8F9A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B0E1F2A3-4B5C-4D5E-2F3A-4B5C6D7E8F9A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B0E1F2A3-4B5C-4D5E-2F3A-4B5C6D7E8F9A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B0E1F2A3-4B5C-4D5E-2F3A-4B5C6D7E8F9A}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal
</file>

<file path="src/DnDMapBuilder.Api/Controllers/AuthController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

/// <summary>
/// Controller for authentication operations (login, register).
/// </summary>
[ApiVersion("1.0")]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IAuthService _authService;
    private readonly IUserManagementService _userManagementService;

    public AuthController(IAuthService authService, IUserManagementService userManagementService)
    {
        _authService = authService;
        _userManagementService = userManagementService;
    }

    [HttpPost("register")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> Register([FromBody] RegisterRequest request, CancellationToken cancellationToken)
    {
        // Create user via user management service
        var userDto = await _userManagementService.RegisterAsync(request, cancellationToken);

        if (userDto == null)
        {
            return BadRequest(new ApiResponse<AuthResponse>(
                false,
                null,
                "Registration failed. User may already exist."
            ));
        }

        // Auto-login after successful registration
        var loginRequest = new LoginRequest(request.Email, request.Password);
        var authResponse = await _authService.LoginAsync(loginRequest, cancellationToken);

        if (authResponse == null)
        {
            return Ok(new ApiResponse<AuthResponse>(
                true,
                null,
                "Registration successful. Awaiting admin approval."
            ));
        }

        return Ok(new ApiResponse<AuthResponse>(true, authResponse, "Registration successful. Token generated."));
    }

    [HttpPost("login")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> Login([FromBody] LoginRequest request, CancellationToken cancellationToken)
    {
        var result = await _authService.LoginAsync(request, cancellationToken);

        if (result == null)
        {
            return Unauthorized(new ApiResponse<AuthResponse>(
                false,
                null,
                "Invalid credentials or account not approved."
            ));
        }

        return Ok(new ApiResponse<AuthResponse>(true, result, "Login successful."));
    }

    [Authorize(Roles = "admin")]
    [HttpGet("pending-users")]
    [ResponseCache(CacheProfileName = "Short10")]
    public async Task<ActionResult<ApiResponse<IEnumerable<UserDto>>>> GetPendingUsers(CancellationToken cancellationToken)
    {
        var users = await _userManagementService.GetPendingUsersAsync(cancellationToken);
        return Ok(new ApiResponse<IEnumerable<UserDto>>(true, users));
    }

    [Authorize(Roles = "admin")]
    [HttpPost("approve-user")]
    public async Task<ActionResult<ApiResponse<bool>>> ApproveUser([FromBody] ApproveUserRequest request, CancellationToken cancellationToken)
    {
        var result = await _userManagementService.ApproveUserAsync(request.UserId, request.Approved, cancellationToken);

        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "User not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "User status updated."));
    }
}
</file>

<file path="src/DnDMapBuilder.Api/Controllers/GameMapsController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

/// <summary>
/// Controller for managing game maps and map images.
/// </summary>
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class GameMapsController : ControllerBase
{
    private readonly IGameMapService _mapService;
    private readonly IFileStorageService _fileStorageService;

    public GameMapsController(IGameMapService mapService, IFileStorageService fileStorageService)
    {
        _mapService = mapService;
        _fileStorageService = fileStorageService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    /// <summary>
    /// Gets a game map by ID.
    /// </summary>
    /// <param name="id">The game map ID</param>
    /// <returns>The game map details or 404 if not found</returns>
    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> GetMap(string id, CancellationToken cancellationToken)
    {
        var map = await _mapService.GetByIdAsync(id, GetUserId(), cancellationToken);

        if (map == null)
        {
            return NotFound(new ApiResponse<GameMapDto>(false, null, "Map not found."));
        }

        return Ok(new ApiResponse<GameMapDto>(true, map));
    }

    /// <summary>
    /// Gets all game maps for a specific mission.
    /// </summary>
    /// <param name="missionId">The mission ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of game maps in the mission</returns>
    [HttpGet("mission/{missionId}")]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<IEnumerable<GameMapDto>>>> GetMapsByMission(string missionId, CancellationToken cancellationToken)
    {
        var maps = await _mapService.GetByMissionIdAsync(missionId, GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<GameMapDto>>(true, maps));
    }

    /// <summary>
    /// Creates a new game map in a mission.
    /// </summary>
    /// <param name="request">Create map request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created game map details or 403 if unauthorized</returns>
    [HttpPost]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> CreateMap([FromBody] CreateMapRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var map = await _mapService.CreateAsync(request, GetUserId(), cancellationToken);
            return CreatedAtAction(nameof(GetMap), new { id = map.Id }, new ApiResponse<GameMapDto>(true, map, "Map created."));
        }
        catch (UnauthorizedAccessException ex)
        {
            return Forbid(ex.Message);
        }
    }

    /// <summary>
    /// Updates an existing game map.
    /// </summary>
    /// <param name="id">The game map ID to update</param>
    /// <param name="request">Update map request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated game map details or 404 if not found</returns>
    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> UpdateMap(string id, [FromBody] UpdateMapRequest request, CancellationToken cancellationToken)
    {
        var map = await _mapService.UpdateAsync(id, request, GetUserId(), cancellationToken);

        if (map == null)
        {
            return NotFound(new ApiResponse<GameMapDto>(false, null, "Map not found."));
        }

        return Ok(new ApiResponse<GameMapDto>(true, map, "Map updated."));
    }

    /// <summary>
    /// Deletes a game map.
    /// </summary>
    /// <param name="id">The game map ID to delete</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Success indicator or 404 if not found</returns>
    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteMap(string id, CancellationToken cancellationToken)
    {
        var result = await _mapService.DeleteAsync(id, GetUserId(), cancellationToken);

        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Map not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Map deleted."));
    }

    /// <summary>
    /// Uploads an image for a game map.
    /// </summary>
    /// <param name="id">The game map ID</param>
    /// <param name="image">The image file to upload</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Upload response with file details or error status</returns>
    [EnableRateLimiting("fileUpload")]
    [HttpPost("{id}/image")]
    [Consumes("multipart/form-data")]
    public async Task<ActionResult<ApiResponse<ImageUploadResponse>>> UploadMapImage(string id, IFormFile image, CancellationToken cancellationToken)
    {
        try
        {
            // Validate file
            if (image == null || image.Length == 0)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "No file provided."));

            // Validate file size (5MB max for maps)
            const long maxFileSize = 5 * 1024 * 1024;
            if (image.Length > maxFileSize)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "File size exceeds 5MB limit."));

            // Validate MIME type
            var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
            if (!allowedMimeTypes.Contains(image.ContentType?.ToLower() ?? ""))
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "Invalid file format. Allowed: PNG, JPEG, WebP."));

            // Get map to verify ownership
            var map = await _mapService.GetByIdAsync(id, GetUserId(), cancellationToken);
            if (map == null)
                return NotFound(new ApiResponse<ImageUploadResponse>(false, null, "Map not found."));

            // Upload file
            var fileId = await _fileStorageService.UploadAsync(
                image.OpenReadStream(),
                image.FileName,
                image.ContentType,
                "maps",
                cancellationToken
            );

            // Update map with file metadata
            var updatedMap = map with
            {
                ImageFileId = fileId,
                ImageContentType = image.ContentType,
                ImageFileSize = image.Length,
                ImageUrl = _fileStorageService.GetPublicUrl(fileId, "maps")
            };

            // Update database
            var tokenRequests = updatedMap.Tokens
                .Select(t => new MapTokenInstanceRequest(t.TokenId, t.X, t.Y))
                .ToList();

            var result = await _mapService.UpdateAsync(id, new UpdateMapRequest(
                updatedMap.Name,
                updatedMap.ImageUrl,
                updatedMap.Rows,
                updatedMap.Cols,
                tokenRequests,
                updatedMap.GridColor,
                updatedMap.GridOpacity
            ), GetUserId(), cancellationToken);

            var response = new ImageUploadResponse(fileId, result.ImageUrl ?? "", image.ContentType ?? "application/octet-stream", image.Length);
            return Ok(new ApiResponse<ImageUploadResponse>(true, response, "Image uploaded successfully."));
        }
        catch (Exception ex)
        {
            return StatusCode(500, new ApiResponse<ImageUploadResponse>(false, null, $"Error uploading image: {ex.Message}"));
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Api/Controllers/TokensController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Api.Controllers;

/// <summary>
/// Controller for managing token definitions and token images.
/// </summary>
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class TokensController : ControllerBase
{
    private readonly ITokenDefinitionService _tokenService;
    private readonly IFileStorageService _fileStorageService;

    public TokensController(ITokenDefinitionService tokenService, IFileStorageService fileStorageService)
    {
        _tokenService = tokenService;
        _fileStorageService = fileStorageService;
    }

    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();

    /// <summary>
    /// Gets all token definitions for the current user.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Collection of user's token definitions</returns>
    [HttpGet]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<IEnumerable<TokenDefinitionDto>>>> GetUserTokens(CancellationToken cancellationToken)
    {
        var tokens = await _tokenService.GetUserTokensAsync(GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<TokenDefinitionDto>>(true, tokens));
    }

    /// <summary>
    /// Gets a token definition by ID.
    /// </summary>
    /// <param name="id">The token definition ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The token definition details or 404 if not found</returns>
    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> GetToken(string id, CancellationToken cancellationToken)
    {
        var token = await _tokenService.GetByIdAsync(id, GetUserId(), cancellationToken);

        if (token == null)
        {
            return NotFound(new ApiResponse<TokenDefinitionDto>(false, null, "Token not found."));
        }

        return Ok(new ApiResponse<TokenDefinitionDto>(true, token));
    }

    /// <summary>
    /// Creates a new token definition.
    /// </summary>
    /// <param name="request">Create token request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The created token definition details</returns>
    [HttpPost]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> CreateToken([FromBody] CreateTokenDefinitionRequest request, CancellationToken cancellationToken)
    {
        var token = await _tokenService.CreateAsync(request, GetUserId(), cancellationToken);
        return CreatedAtAction(nameof(GetToken), new { id = token.Id }, new ApiResponse<TokenDefinitionDto>(true, token, "Token created."));
    }

    /// <summary>
    /// Updates an existing token definition.
    /// </summary>
    /// <param name="id">The token definition ID to update</param>
    /// <param name="request">Update token request</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>The updated token definition details or 404 if not found</returns>
    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> UpdateToken(string id, [FromBody] UpdateTokenDefinitionRequest request, CancellationToken cancellationToken)
    {
        var token = await _tokenService.UpdateAsync(id, request, GetUserId(), cancellationToken);

        if (token == null)
        {
            return NotFound(new ApiResponse<TokenDefinitionDto>(false, null, "Token not found."));
        }

        return Ok(new ApiResponse<TokenDefinitionDto>(true, token, "Token updated."));
    }

    /// <summary>
    /// Deletes a token definition.
    /// </summary>
    /// <param name="id">The token definition ID to delete</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Success indicator or 404 if not found</returns>
    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteToken(string id, CancellationToken cancellationToken)
    {
        var result = await _tokenService.DeleteAsync(id, GetUserId(), cancellationToken);

        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Token not found."));
        }

        return Ok(new ApiResponse<bool>(true, true, "Token deleted."));
    }

    /// <summary>
    /// Uploads an image for a token definition.
    /// </summary>
    /// <param name="id">The token definition ID</param>
    /// <param name="image">The image file to upload</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Upload response with file details or error status</returns>
    [EnableRateLimiting("fileUpload")]
    [HttpPost("{id}/image")]
    [Consumes("multipart/form-data")]
    public async Task<ActionResult<ApiResponse<ImageUploadResponse>>> UploadTokenImage(string id, IFormFile image, CancellationToken cancellationToken)
    {
        try
        {
            // Validate file
            if (image == null || image.Length == 0)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "No file provided."));

            // Validate file size (2MB max for tokens)
            const long maxFileSize = 2 * 1024 * 1024;
            if (image.Length > maxFileSize)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "File size exceeds 2MB limit."));

            // Validate MIME type
            var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
            if (!allowedMimeTypes.Contains(image.ContentType?.ToLower() ?? ""))
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "Invalid file format. Allowed: PNG, JPEG, WebP."));

            // Get token to verify ownership
            var token = await _tokenService.GetByIdAsync(id, GetUserId(), cancellationToken);
            if (token == null)
                return NotFound(new ApiResponse<ImageUploadResponse>(false, null, "Token not found."));

            // Upload file
            var fileId = await _fileStorageService.UploadAsync(
                image.OpenReadStream(),
                image.FileName,
                image.ContentType,
                "tokens",
                cancellationToken
            );

            // Update token with file metadata
            var updatedToken = token with
            {
                ImageFileId = fileId,
                ImageContentType = image.ContentType,
                ImageFileSize = image.Length,
                ImageUrl = _fileStorageService.GetPublicUrl(fileId, "tokens")
            };

            // Update database
            var result = await _tokenService.UpdateAsync(id, new UpdateTokenDefinitionRequest(
                updatedToken.Name,
                updatedToken.ImageUrl,
                updatedToken.Size,
                updatedToken.Type
            ), GetUserId(), cancellationToken);

            var response = new ImageUploadResponse(fileId, result.ImageUrl ?? "", image.ContentType ?? "application/octet-stream", image.Length);
            return Ok(new ApiResponse<ImageUploadResponse>(true, response, "Image uploaded successfully."));
        }
        catch (Exception ex)
        {
            return StatusCode(500, new ApiResponse<ImageUploadResponse>(false, null, $"Error uploading image: {ex.Message}"));
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="10.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="10.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="10.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <!-- Prevent MSB3552 error by explicitly excluding .resx files -->
  <ItemGroup>
    <EmbeddedResource Remove="**/*.resx" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;

namespace DnDMapBuilder.Data;

public class DnDMapBuilderDbContext : DbContext
{
    public DnDMapBuilderDbContext(DbContextOptions<DnDMapBuilderDbContext> options)
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; } = null!;
    public DbSet<Campaign> Campaigns { get; set; } = null!;
    public DbSet<Mission> Missions { get; set; } = null!;
    public DbSet<GameMap> GameMaps { get; set; } = null!;
    public DbSet<TokenDefinition> TokenDefinitions { get; set; } = null!;
    public DbSet<MapTokenInstance> MapTokenInstances { get; set; } = null!;

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);

        // Detailed debugging for Development only
#if DEBUG
        optionsBuilder.EnableSensitiveDataLogging();
        optionsBuilder.EnableDetailedErrors();
#endif
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.HasIndex(e => e.Email).IsUnique();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.Property(e => e.Username).IsRequired().HasMaxLength(100);
            entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
            entity.Property(e => e.PasswordHash).IsRequired();
            entity.Property(e => e.Role).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Status).IsRequired().HasMaxLength(50);
        });

        // Campaign configuration
        modelBuilder.Entity<Campaign>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Description).HasMaxLength(2000);

            // When User deleted -> Restrict (don't cascade delete campaigns)
            entity.HasOne(e => e.Owner)
                .WithMany(u => u.Campaigns)
                .HasForeignKey(e => e.OwnerId)
                .OnDelete(DeleteBehavior.Restrict);
        });

        // Mission configuration
        modelBuilder.Entity<Mission>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Description).HasMaxLength(2000);

            // When Campaign deleted -> delete all Missions
            entity.HasOne(e => e.Campaign)
                .WithMany(c => c.Missions)
                .HasForeignKey(e => e.CampaignId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // GameMap configuration
        modelBuilder.Entity<GameMap>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.ImageUrl).HasMaxLength(1000);
            entity.Property(e => e.GridColor).IsRequired().HasMaxLength(20);

            // When Mission deleted -> delete all GameMaps
            entity.HasOne(e => e.Mission)
                .WithMany(m => m.Maps)
                .HasForeignKey(e => e.MissionId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // TokenDefinition configuration
        modelBuilder.Entity<TokenDefinition>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.ImageUrl).IsRequired().HasMaxLength(1000);
            entity.Property(e => e.Type).IsRequired().HasMaxLength(50);

            // When User deleted -> delete all TokenDefinitions
            entity.HasOne(e => e.User)
                .WithMany(u => u.TokenDefinitions)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // MapTokenInstance configuration
        modelBuilder.Entity<MapTokenInstance>(entity =>
        {
            entity.HasKey(e => e.Id);

            // When TokenDefinition deleted -> delete all MapTokenInstances
            entity.HasOne(e => e.Token)
                .WithMany(t => t.MapTokenInstances)
                .HasForeignKey(e => e.TokenId)
                .OnDelete(DeleteBehavior.Cascade);

            // When GameMap deleted -> delete all MapTokenInstances
            entity.HasOne(e => e.Map)
                .WithMany(m => m.Tokens)
                .HasForeignKey(e => e.MapId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Note: Admin user is seeded via DbInitializer at runtime, not via migrations
        // This allows the password to be read from environment variables securely
    }
}
</file>

<file path="docker-compose.yml">
version: '3.8'

# SQL Server database service
services:
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2022-latest
    container_name: dnd-sqlserver
    restart: unless-stopped
    environment:
      - ACCEPT_EULA=Y
      - MSSQL_SA_PASSWORD=${SA_PASSWORD:-s_2.Z6NWn*Jj17esJD6p+E}
      - MSSQL_PID=Developer
    ports:
      - "1433:1433"
    volumes:
      - sqlserver_data:/var/opt/mssql
    networks:
      - dnd-network
    healthcheck:
      test: ["CMD", "/opt/mssql-tools18/bin/sqlcmd", "-S", "localhost", "-U", "sa", "-P", "${SA_PASSWORD:-s_2.Z6NWn*Jj17esJD6p+E}", "-Q", "SELECT 1"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 20s

  # D&D Map Builder API service
  api:
    build:
      context: .
      dockerfile: src/DnDMapBuilder.Api/Dockerfile
    container_name: dnd-api
    restart: unless-stopped
    depends_on:
      sqlserver:
        condition: service_healthy
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:8080;https://+:8443
      - ConnectionStrings__DefaultConnection=Server=sqlserver;Database=dndmapbuilder;User Id=sa;Password=${SA_PASSWORD:-s_2.Z6NWn*Jj17esJD6p+E};TrustServerCertificate=True;
      - ASPNETCORE_Kestrel__Certificates__Default__Path=/app/certs/aspnetapp.pfx
      - ASPNETCORE_Kestrel__Certificates__Default__Password=crypticpassword
    ports:
      - "5000:8080"
      - "5001:8443"
    volumes:
      - ./certs:/app/certs:ro
      - ${UPLOADS_PATH:-./uploads}:/app/wwwroot/uploads
    networks:
      - dnd-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health/live"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s

# Volume definitions for persistent data
volumes:
  sqlserver_data:
    driver: local

# Network definition
networks:
  dnd-network:
    driver: bridge
</file>

<file path="src/DnDMapBuilder.Infrastructure/DnDMapBuilder.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <!-- Logging & ASP.NET Core -->
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
    <PackageReference Include="Serilog.AspNetCore" Version="10.0.0" />
    <PackageReference Include="Serilog.Enrichers.Environment" Version="3.0.1" />
    <PackageReference Include="Serilog.Enrichers.Thread" Version="4.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="6.1.1" />
    <PackageReference Include="Serilog.Sinks.File" Version="7.0.0" />
    <PackageReference Include="Serilog.Sinks.Seq" Version="9.0.0" />

    <!-- Telemetry/Observability -->
    <PackageReference Include="OpenTelemetry" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.SqlClient" Version="1.14.0-rc.1" />

    <!-- Health Checks -->
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" Version="9.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" Version="9.0.0" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <GenerateBindingRedirectsOutputType>true</GenerateBindingRedirectsOutputType>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Asp.Versioning.Mvc.ApiExplorer" Version="8.1.1" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="10.0.2" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="10.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.RateLimiting" Version="7.0.0-rc.2.22476.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="10.1.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Aspire.ServiceDefaults\DnDMapBuilder.Aspire.ServiceDefaults.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path=".github/workflows/main.yml">
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]  # Full pipeline only on main branch
  pull_request:
    branches: [ main, develop ]  # Build and test only for PRs
  workflow_dispatch: # Allows manual triggering

env:
  DOTNET_VERSION: '10.0.x'
  REGISTRY: ghcr.io

jobs:
  # Job 1: Build and Test
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Restore dependencies
      run: dotnet restore DnDMapBuilder.sln

    - name: Build
      run: dotnet build DnDMapBuilder.sln --configuration Release --no-restore

    - name: Test
      run: dotnet test DnDMapBuilder.sln --configuration Release --no-build --verbosity normal

  # Job 2: Build and Push Docker Image
  build-docker:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    permissions:
      contents: read
      packages: write

    outputs:
      image-name: ${{ steps.image-name.outputs.lowercase }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Convert repository name to lowercase
      id: image-name
      run: echo "lowercase=${GITHUB_REPOSITORY@L}" >> $GITHUB_OUTPUT

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata (tags, labels)
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.lowercase }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./src/DnDMapBuilder.Api/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Job 3: Deploy to Server
  deploy:
    needs: build-docker
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to server via SSH
      env:
        IMAGE_NAME: ${{ needs.build-docker.outputs.image-name }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        envs: IMAGE_NAME
        script: |
          # Login to GitHub Container Registry
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # Create Docker network if it doesn't exist
          docker network create dnd-network 2>/dev/null || true

          # Pull the latest API image
          docker pull ghcr.io/${IMAGE_NAME}:latest

          # Run database migrations before deploying new container
          echo "Running database migrations..."
          docker run --rm \
            -e ConnectionStrings__DefaultConnection="${{ secrets.DB_CONNECTION_STRING }}" \
            ghcr.io/${IMAGE_NAME}:latest \
            sh -c "dotnet ef database update --project src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj --startup-project src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj --context DnDMapBuilderDbContext || exit 1"
          echo "Database migrations completed"

          # Stop and remove old API container
          docker stop dnd-api || true
          docker rm dnd-api || true

          # Create uploads directory on host if it doesn't exist
          mkdir -p ~/dnd-api-uploads

          # Run new API container with environment variables
          docker run -d \
            --name dnd-api \
            --restart unless-stopped \
            -p 5000:8080 \
            -p 5001:8443 \
            -e ASPNETCORE_ENVIRONMENT=Production \
            -e ASPNETCORE_URLS="http://+:8080;https://+:8443" \
            -e ConnectionStrings__DefaultConnection="${{ secrets.DB_CONNECTION_STRING }}" \
            -v ~/dnd-api-uploads:/app/wwwroot/uploads \
            --network dnd-network \
            --health-cmd="curl -f http://localhost:8080/health/live || exit 1" \
            --health-interval=30s \
            --health-timeout=3s \
            --health-retries=3 \
            --health-start-period=10s \
            ghcr.io/${IMAGE_NAME}:latest

          # Optional: Configure monitoring and logging (if secrets are provided)
          # Uncomment and set secrets if using Application Insights or other monitoring
          # -e APPLICATIONINSIGHTS_CONNECTION_STRING="${{ secrets.APPLICATIONINSIGHTS_CONNECTION_STRING || '' }}" \
          # -e OTEL_EXPORTER_OTLP_ENDPOINT="${{ secrets.OTEL_EXPORTER_OTLP_ENDPOINT || '' }}" \
          # -e LOG_LEVEL="${{ secrets.LOG_LEVEL || 'Information' }}" \

          # Clean up old images
          docker image prune -f

    - name: Verify deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        script: |
          # Wait for API container to be healthy
          echo "Waiting for API container to be healthy..."
          for i in {1..30}; do
            if docker exec dnd-api curl -f http://localhost:8080/health/live > /dev/null 2>&1; then
              echo "✓ API container is healthy"
              break
            fi
            echo "Attempt $i/30: Waiting for API..."
            sleep 2
          done

          # Verify container is running
          echo ""
          echo "Checking container status..."
          docker ps --filter "name=dnd-api" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          # Verify health check endpoints
          echo ""
          echo "Testing health check endpoints..."
          echo "Testing /health/live..."
          curl -s -f http://localhost:5000/health/live > /dev/null && echo "✓ /health/live - OK" || echo "✗ /health/live - FAILED"

          echo "Testing /health..."
          curl -s -f http://localhost:5000/health > /dev/null && echo "✓ /health - OK" || echo "✗ /health - FAILED"

          # Show recent logs
          echo ""
          echo "Recent API container logs:"
          docker logs dnd-api --tail 30
</file>

<file path="src/DnDMapBuilder.Api/Program.cs">
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Http.Features;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Microsoft.IdentityModel.Tokens;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Repositories;
using DnDMapBuilder.Data.Repositories.Interfaces;
using DnDMapBuilder.Infrastructure.Configuration;
using DnDMapBuilder.Infrastructure.Middleware;

var builder = WebApplication.CreateBuilder(args);

builder.AddServiceDefaults();

// Configure file upload limits
builder.Services.Configure<FormOptions>(options =>
{
    options.MultipartBodyLengthLimit = 10 * 1024 * 1024; // 10MB
});

// Configure graceful shutdown
builder.Services.Configure<HostOptions>(options =>
{
    options.ShutdownTimeout = TimeSpan.FromSeconds(30);
});

// Add services to the container
var controllerBuilder = builder.Services.AddControllers();
controllerBuilder.ConfigureCacheProfiles();
builder.Services.AddEndpointsApiExplorer();

// Response Caching
builder.Services.AddResponseCachingConfiguration();

// API Versioning
builder.Services.AddApiVersioning(options =>
{
    options.DefaultApiVersion = new Asp.Versioning.ApiVersion(1, 0);
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.ReportApiVersions = true;
})
.AddMvc()
.AddApiExplorer(options =>
{
    options.GroupNameFormat = "'v'VVV";
    options.SubstituteApiVersionInUrl = true;
});

builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new() { Title = "DnD Map Builder API", Version = "v1" });
});

// Database
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<DnDMapBuilderDbContext>(options =>
    options.UseSqlServer(connectionString));

// JWT Configuration
var jwtSettings = builder.Configuration.GetSection("JwtSettings");
var secretKey = jwtSettings["SecretKey"] ?? throw new InvalidOperationException("JWT SecretKey not configured");

builder.Services.AddSingleton<IJwtService>(sp => 
    new JwtService(
        secretKey,
        jwtSettings["Issuer"] ?? "DnDMapBuilderApi",
        jwtSettings["Audience"] ?? "DnDMapBuilderClient",
        int.Parse(jwtSettings["ExpirationMinutes"] ?? "1440")
    ));

builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)),
        ValidateIssuer = true,
        ValidIssuer = jwtSettings["Issuer"],
        ValidateAudience = true,
        ValidAudience = jwtSettings["Audience"],
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero
    };
});

builder.Services.AddAuthorization();

// Configuration - Use Options pattern
builder.Services.Configure<JwtSettings>(builder.Configuration.GetSection(JwtSettings.SectionName));
builder.Services.Configure<CorsSettings>(builder.Configuration.GetSection(CorsSettings.SectionName));

// Rate Limiting
builder.Services.AddRateLimitingConfiguration();

// CORS - Use configured origins
var corsSettings = builder.Configuration.GetSection(CorsSettings.SectionName).Get<CorsSettings>();
builder.Services.AddCors(options =>
{
    options.AddPolicy(CorsSettings.SectionName, policy =>
    {
        if (corsSettings?.AllowedOrigins?.Length > 0)
        {
            policy.WithOrigins(corsSettings.AllowedOrigins)
                  .AllowAnyMethod()
                  .AllowAnyHeader()
                  .AllowCredentials();
        }
        else
        {
            // Fallback to AllowAll if no origins configured
            policy.AllowAnyOrigin()
                  .AllowAnyMethod()
                  .AllowAnyHeader();
        }
    });
});

// Register Repositories
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<ICampaignRepository, CampaignRepository>();
builder.Services.AddScoped<IMissionRepository, MissionRepository>();
builder.Services.AddScoped<IGameMapRepository, GameMapRepository>();
builder.Services.AddScoped<ITokenDefinitionRepository, TokenDefinitionRepository>();
builder.Services.AddScoped<IMapTokenInstanceRepository, MapTokenInstanceRepository>();

// Register Services
builder.Services.AddSingleton<IPasswordService, PasswordService>();
builder.Services.AddScoped<IUserManagementService, UserManagementService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<ICampaignService, CampaignService>();
builder.Services.AddScoped<IMissionService, MissionService>();
builder.Services.AddScoped<IGameMapService, GameMapService>();
builder.Services.AddScoped<ITokenDefinitionService, TokenDefinitionService>();
builder.Services.AddSingleton<IFileValidationService, FileValidationService>();

// File Storage Service
var baseStoragePath = Path.Combine(builder.Environment.ContentRootPath, "wwwroot", "uploads");
var basePublicUrl = "/uploads";
builder.Services.AddSingleton<IFileStorageService>(sp =>
    new LocalFileStorageService(baseStoragePath, basePublicUrl, sp.GetRequiredService<ILogger<LocalFileStorageService>>()));

var app = builder.Build();

app.MapDefaultEndpoints();

// Apply migrations and seed admin user on startup
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<DnDMapBuilderDbContext>();
    await DbInitializer.InitializeAsync(db);
}

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/swagger/v1/swagger.json", "DnD Map Builder API v1");
    });
}

app.UseHttpsRedirection();

// Add response caching middleware (should be early in pipeline)
app.UseResponseCachingConfiguration();

// Add cache control headers
app.UseCacheControlHeaders();

// Add security headers middleware
app.UseSecurityHeaders();

// Add request/response logging middleware
app.UseRequestResponseLogging();

// Add rate limiting middleware
app.UseRateLimitingConfiguration();

// Ensure wwwroot directory exists for static file serving
var wwwrootPath = Path.Combine(app.Environment.ContentRootPath, "wwwroot");
if (!Directory.Exists(wwwrootPath))
{
    Directory.CreateDirectory(wwwrootPath);
}

// Serve static files from wwwroot at /api path
// This matches the frontend's URL construction: BASE_URL + imageUrl = /api + /uploads/...
app.UseStaticFiles(new StaticFileOptions
{
    FileProvider = new Microsoft.Extensions.FileProviders.PhysicalFileProvider(wwwrootPath),
    RequestPath = "/api"
});

app.UseCors(CorsSettings.SectionName);
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();
</file>

</files>
