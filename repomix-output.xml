This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.cs, **/*.csproj, **/*.json, **/*.yml, **/*.yaml, **/*.md, **/*.vue, **/*.js, **/*.ts, **/*.html, **/*.css, **/*.scss
- Files matching these patterns are excluded: **/bin/**, **/obj/**, **/.vs/**, **/packages/**, **/.nuget/**, **/node_modules/**, **/dist/**, **/.vite/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  commands/
    create_repomix.md
    execute_prompt_plan.md
  settings.local.json
.github/
  workflows/
    main.yml
  FIX_DOCKER_PERMISSIONS.md
  GITHUB_ACTIONS_GUIDE.md
  GITLAB_VS_GITHUB_COMPARISON.md
  MULTI_PLATFORM_BUILD.md
src/
  DnDMapBuilder.Api/
    Controllers/
      AuthController.cs
      CampaignsController.cs
      GameMapsController.cs
      MissionsController.cs
      TokensController.cs
    appsettings.json
    DnDMapBuilder.Api.csproj
    GlobalSuppressions.cs
    Program.cs
  DnDMapBuilder.AppHost/
    AppHost.cs
    appsettings.json
    DnDMapBuilder.AppHost.csproj
  DnDMapBuilder.Application/
    Common/
      Result.cs
    Interfaces/
      IAuthService.cs
      ICampaignService.cs
      IFileStorageService.cs
      IFileValidationService.cs
      IGameMapService.cs
      IJwtService.cs
      IMissionService.cs
      IOAuthService.cs
      IPasswordService.cs
      ITokenDefinitionService.cs
      IUserManagementService.cs
    Mappings/
      MappingExtensions.cs
    Services/
      AppleOAuthService.cs
      AuthService.cs
      CampaignService.cs
      FileStorageService.cs
      FileValidationService.cs
      GameMapService.cs
      GoogleOAuthService.cs
      JwtService.cs
      MissionService.cs
      OAuthService.cs
      PasswordService.cs
      TokenDefinitionService.cs
      UserManagementService.cs
    DnDMapBuilder.Application.csproj
  DnDMapBuilder.ArchitectureTests/
    ArchitectureTests.cs
    DnDMapBuilder.ArchitectureTests.csproj
  DnDMapBuilder.Aspire.ServiceDefaults/
    DnDMapBuilder.Aspire.ServiceDefaults.csproj
    Extensions.cs
  DnDMapBuilder.Contracts/
    Configuration/
      OAuthSettings.cs
    DTOs/
      CampaignDto.cs
      GameMapDto.cs
      MapTokenInstanceDto.cs
      MissionDto.cs
      TokenDefinitionDto.cs
      UserDto.cs
    Pagination/
      PaginatedRequest.cs
      PaginatedResponse.cs
    Requests/
      ApproveUserRequest.cs
      CreateCampaignRequest.cs
      CreateMapRequest.cs
      CreateMissionRequest.cs
      CreateTokenDefinitionRequest.cs
      ImageUploadResponse.cs
      LoginRequest.cs
      MapTokenInstanceRequest.cs
      OAuthLoginRequest.cs
      OAuthTokenRequest.cs
      RegisterRequest.cs
      UpdateCampaignRequest.cs
      UpdateMapRequest.cs
      UpdateMissionRequest.cs
      UpdateTokenDefinitionRequest.cs
    Responses/
      ApiResponse.cs
      AuthResponse.cs
      OAuthUrlResponse.cs
      PaginatedResponse.cs
    DnDMapBuilder.Contracts.csproj
  DnDMapBuilder.Data/
    Entities/
      Campaign.cs
      GameMap.cs
      MapTokenInstance.cs
      Mission.cs
      TokenDefinition.cs
      User.cs
    Migrations/
      20260114100522_InitialCreate.cs
      20260114100522_InitialCreate.Designer.cs
      20260115221337_PendingModelChanges.cs
      20260115221337_PendingModelChanges.Designer.cs
      20260116231211_UpdateAdminPasswordHash.cs
      20260116231211_UpdateAdminPasswordHash.Designer.cs
      20260116232059_RemoveSeedData.cs
      20260116232059_RemoveSeedData.Designer.cs
      20260117102707_AddImageFileStorageMetadata.cs
      20260117102707_AddImageFileStorageMetadata.Designer.cs
      20260117104633_SaveImageFiles.cs
      20260117104633_SaveImageFiles.Designer.cs
      20260117221839_ConfigureCascadeDeletes.cs
      20260117221839_ConfigureCascadeDeletes.Designer.cs
      20260117222805_FixCascadeDeleteTokenDefinition.cs
      20260117222805_FixCascadeDeleteTokenDefinition.Designer.cs
      20260121201152_AddOAuthUserFields.cs
      20260121201152_AddOAuthUserFields.Designer.cs
      DnDMapBuilderDbContextModelSnapshot.cs
    Repositories/
      Interfaces/
        ICampaignRepository.cs
        IGameMapRepository.cs
        IGenericRepository.cs
        IMapTokenInstanceRepository.cs
        IMissionRepository.cs
        ITokenDefinitionRepository.cs
        IUserRepository.cs
      CampaignRepository.cs
      GameMapRepository.cs
      GenericRepository.cs
      MapTokenInstanceRepository.cs
      MissionRepository.cs
      TokenDefinitionRepository.cs
      UserRepository.cs
    DbInitializer.cs
    DnDMapBuilder.Data.csproj
    DnDMapBuilderDbContext.cs
    DnDMapBuilderDbContextFactory.cs
    MigrationRunner.cs
  DnDMapBuilder.Infrastructure/
    Configuration/
      CachingConfiguration.cs
      CorsSettings.cs
      JwtSettings.cs
      RateLimitConfiguration.cs
    HealthChecks/
      HealthCheckConfiguration.cs
    Logging/
      LoggingConfiguration.cs
    Middleware/
      RequestResponseLoggingMiddleware.cs
      SecurityHeadersMiddleware.cs
    Telemetry/
      ITelemetryService.cs
      TelemetryConfiguration.cs
      TelemetryService.cs
    DnDMapBuilder.Infrastructure.csproj
  DnDMapBuilder.IntegrationTests/
    Controllers/
      HealthCheckIntegrationTests.cs
    Data/
      CascadeDeleteTests.cs
    DnDMapBuilder.IntegrationTests.csproj
  DnDMapBuilder.UnitTests/
    Controllers/
      AuthControllerOAuthTests.cs
    Entities/
      EntityTests.cs
    Infrastructure/
      HealthChecks/
        HealthCheckTests.cs
      Telemetry/
        TelemetryServiceTests.cs
      CachingConfigurationTests.cs
    Repositories/
      GenericRepositoryTests.cs
    Services/
      AuthServiceTests.cs
      FileValidationServiceTests.cs
      OAuthServiceTests.cs
      PasswordServiceTests.cs
      UserManagementServiceTests.cs
    DnDMapBuilder.UnitTests.csproj
API_DOCUMENTATION.md
backend-main-example.yml
DEPLOYMENT.md
docker-compose.yml
dotnet-tools.json
FILE_STRUCTURE.md
LOAD_TESTING.md
PROJECT_SUMMARY.md
prompt_plan.md
QUICKSTART.md
README.md
SECURITY.md
SMOKE_TESTS.md
STRUCTURE_DIAGRAM.md
WORKFLOW_SETUP.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/commands/create_repomix.md">
- Run the following command on the repo top level: ```powershell   repomix --output repomix-output.xml --include "**/*.cs,**/*.csproj,**/*.json,**/*.yml,**/*.yaml,**/*.md,**/*.vue,**/*.js,**/*.ts,**/*.html,**/*.css,**/*.scss" --ignore "**/bin/**,**/obj/**,**/.vs/**,**/packages/**,**/.nuget/**,**/node_modules/**,**/dist/**,**/.vite/**" --style xml ` --remove-comments --remove-empty-lines ```
</file>

<file path=".github/FIX_DOCKER_PERMISSIONS.md">
# Fixing Docker Permission Issues on Your Server

## The Problem

You're seeing this error:
```
permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock
```

This happens because your SSH user doesn't have permission to run Docker commands.

## Solution: Add User to Docker Group

SSH into your server and run these commands:

### Step 1: Add your user to the docker group
```bash
sudo usermod -aG docker $USER
```

If you're deploying with a specific user (e.g., `ubuntu`), replace `$USER`:
```bash
sudo usermod -aG docker ubuntu
```

### Step 2: Apply the group changes

You have two options:

**Option A: Log out and log back in** (Recommended)
```bash
exit
# Then SSH back in
```

**Option B: Activate the group without logging out**
```bash
newgrp docker
```

### Step 3: Verify it works
```bash
docker ps
```

If this runs without `sudo` and without errors, you're all set!

### Step 4: Test the full workflow
```bash
# Test login to GitHub Container Registry
echo "YOUR_GITHUB_PAT" | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin

# Test pulling an image
docker pull hello-world

# Test running a container
docker run hello-world
```

## Alternative Solution: Use Sudo (Not Recommended)

If you can't add the user to the docker group, you can modify the workflow to use `sudo`. However, this requires configuring passwordless sudo for Docker commands.

### Configure passwordless sudo for Docker

1. SSH into your server
2. Edit the sudoers file:
```bash
sudo visudo
```

3. Add this line at the end (replace `ubuntu` with your username):
```bash
ubuntu ALL=(ALL) NOPASSWD: /usr/bin/docker
```

4. Save and exit (Ctrl+X, then Y, then Enter)

5. Update the workflow to use `sudo`:

In `.github/workflows/ci-cd.yml`, replace all `docker` commands with `sudo docker`:
```bash
sudo docker login ...
sudo docker pull ...
sudo docker stop ...
sudo docker rm ...
sudo docker run ...
```

## Checking Current Docker Group Membership

To see if your user is already in the docker group:
```bash
groups $USER
```

Or for a specific user:
```bash
groups ubuntu
```

You should see `docker` in the output.

## Understanding Docker Socket Permissions

The Docker daemon runs as root and listens on `/var/run/docker.sock`. By default, only root and members of the `docker` group can access this socket.

To check socket permissions:
```bash
ls -l /var/run/docker.sock
```

Output should look like:
```
srw-rw---- 1 root docker 0 Jan 15 21:00 /var/run/docker.sock
```

The `docker` in the group column means users in the docker group can access it.

## Security Note

Adding a user to the docker group gives them root-equivalent privileges because Docker containers can be run with root access. Only add trusted users to the docker group.

For production environments, consider:
- Using a dedicated deployment user with minimal privileges
- Implementing proper secret rotation
- Using Docker's user namespaces for additional isolation
- Auditing Docker commands via logging

## Testing Your Fix

After adding your user to the docker group and logging back in, run:

```bash
# Should work without sudo
docker ps

# Should work without sudo
docker images

# Should work without sudo
docker pull alpine
```

If all three commands work without errors, your permissions are fixed!

## Still Having Issues?

### Issue: "Cannot connect to the Docker daemon"
**Solution**: Make sure Docker is running
```bash
sudo systemctl status docker
sudo systemctl start docker
sudo systemctl enable docker  # Enable on boot
```

### Issue: "credential helper" warning
This warning is harmless but can be fixed by installing a credential helper:
```bash
# For Ubuntu/Debian
sudo apt-get install pass gnupg2

# Configure Docker to use it
docker-credential-pass
```

Or ignore it - it won't affect deployment.

### Issue: "network dnd-network not found"
Create the Docker network first:
```bash
docker network create dnd-network
```

Or update the workflow to create it automatically:
```bash
docker network create dnd-network || true
```
</file>

<file path=".github/GITHUB_ACTIONS_GUIDE.md">
# GitHub Actions CI/CD Guide

## Overview

This guide explains how to use the GitHub Actions workflow for your DnD MapBuilder API, and how to configure secrets (similar to GitLab CI/CD variables).

## GitLab vs GitHub Actions: Key Differences

| Feature | GitLab CI/CD | GitHub Actions |
|---------|--------------|----------------|
| **Config File** | `.gitlab-ci.yml` (root) | `.github/workflows/*.yml` |
| **Variables/Secrets** | Settings > CI/CD > Variables | Settings > Secrets and variables > Actions |
| **Jobs** | Defined in stages | Defined in jobs (can run in parallel or sequence) |
| **Runners** | GitLab Runners | GitHub-hosted or self-hosted runners |
| **Docker Registry** | GitLab Container Registry | GitHub Container Registry (ghcr.io) |
| **Manual Trigger** | `when: manual` | `workflow_dispatch` |

## How the Workflow Works

The workflow has 3 jobs that run sequentially:

### 1. Build and Test (`build-and-test`)
- Triggers on: Push to `main`/`develop` or Pull Requests
- Checks out code
- Sets up .NET 10.0
- Restores dependencies
- Builds the solution
- Runs tests

### 2. Build Docker Image (`build-docker`)
- Runs only on push to `main` branch (after tests pass)
- Builds Docker image using your Dockerfile
- Pushes to GitHub Container Registry (ghcr.io)
- Tags images with branch name, commit SHA, and 'latest'

### 3. Deploy to Server (`deploy`)
- Runs only on push to `main` branch (after Docker build)
- Connects to your server via SSH
- Pulls the latest Docker image
- Stops old container
- Starts new container with environment variables
- Verifies deployment

## Setting Up Secrets (GitLab Variables Equivalent)

In GitHub, secrets are stored in: **Repository Settings > Secrets and variables > Actions**

### Required Secrets

#### Server Connection Secrets
```
SECRET NAME: SERVER_HOST
VALUE: your-server-ip-or-domain.com
DESCRIPTION: IP address or domain of your deployment server
```

```
SECRET NAME: SERVER_USERNAME
VALUE: ubuntu (or your SSH username)
DESCRIPTION: SSH username for server access
```

```
SECRET NAME: SSH_PRIVATE_KEY
VALUE: -----BEGIN OPENSSH PRIVATE KEY-----
...your private key content...
-----END OPENSSH PRIVATE KEY-----
DESCRIPTION: SSH private key for server authentication
```

```
SECRET NAME: SERVER_PORT
VALUE: 22 (optional, defaults to 22)
DESCRIPTION: SSH port if different from 22
```

#### Application Secrets
```
SECRET NAME: DB_CONNECTION_STRING
VALUE: Host=your-db-host;Database=dndmapbuilder;Username=dbuser;Password=dbpass
DESCRIPTION: PostgreSQL/SQL Server connection string
```

```
SECRET NAME: JWT_SECRET
VALUE: your-super-secret-jwt-key-at-least-32-characters-long
DESCRIPTION: Secret key for JWT token signing
```

```
SECRET NAME: JWT_ISSUER
VALUE: https://your-api-domain.com
DESCRIPTION: JWT token issuer
```

```
SECRET NAME: JWT_AUDIENCE
VALUE: https://your-api-domain.com
DESCRIPTION: JWT token audience
```

### How to Add Secrets

1. Go to your GitHub repository
2. Click **Settings** tab
3. In the left sidebar, click **Secrets and variables** > **Actions**
4. Click **New repository secret**
5. Enter the secret name and value
6. Click **Add secret**

### Secret Scopes

- **Repository secrets**: Available to all workflows in the repository (default)
- **Environment secrets**: Scoped to specific environments (production, staging)
- **Organization secrets**: Shared across multiple repositories

## Generating SSH Key Pair

If you don't have SSH keys set up:

```bash
# On your local machine
ssh-keygen -t ed25519 -C "github-actions-deploy" -f ~/.ssh/github_actions_deploy

# Copy public key to your server
ssh-copy-id -i ~/.ssh/github_actions_deploy.pub user@your-server.com

# Copy private key content to GitHub secret
cat ~/.ssh/github_actions_deploy
# Copy the entire output including BEGIN and END lines
```

## GitHub Container Registry Setup

GitHub Container Registry (ghcr.io) is free and automatically available. No extra setup needed!

The workflow uses `GITHUB_TOKEN` which is automatically provided by GitHub Actions.

### Making Your Image Public (Optional)

1. Go to your package: https://github.com/users/YOUR_USERNAME/packages/container/YOUR_REPO
2. Click **Package settings**
3. Change visibility to Public if desired

## Triggering the Workflow

### Automatic Triggers
- **Push to `main` or `develop`**: Runs build, test, Docker build (only on main), and deploy (only on main)
- **Pull Request to `main` or `develop`**: Runs build and test only

### Manual Trigger
1. Go to **Actions** tab in your repository
2. Select **CI/CD Pipeline** workflow
3. Click **Run workflow** button
4. Select branch and click **Run workflow**

## Monitoring Workflow Runs

1. Go to **Actions** tab in your repository
2. Click on a workflow run to see details
3. Click on individual jobs to see logs
4. Failed steps will be highlighted in red

## Environment Variables in Workflow

There are two types of variables:

### 1. Secrets (Sensitive Data)
```yaml
${{ secrets.DB_CONNECTION_STRING }}
```
- Encrypted and hidden in logs
- Used for passwords, keys, tokens

### 2. Environment Variables (Non-Sensitive)
```yaml
env:
  DOTNET_VERSION: '10.0.x'
```
- Visible in workflow file
- Used for versions, public URLs

### 3. GitHub Context Variables
```yaml
${{ github.repository }}  # owner/repo-name
${{ github.actor }}       # username who triggered
${{ github.ref }}         # branch reference
```

## Customizing the Workflow

### Change Deployment Branch
To deploy from `develop` instead of `main`:
```yaml
if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
```

### Add Staging Environment
```yaml
deploy-staging:
  if: github.ref == 'refs/heads/develop'
  environment: staging
  # ... steps
```

### Add Database Migrations
Add before deployment:
```yaml
- name: Run migrations
  uses: appleboy/ssh-action@v1.0.0
  with:
    host: ${{ secrets.SERVER_HOST }}
    username: ${{ secrets.SERVER_USERNAME }}
    key: ${{ secrets.SSH_PRIVATE_KEY }}
    script: |
      docker exec dnd-api dotnet ef database update
```

## Caching for Faster Builds

The workflow already includes Docker layer caching:
```yaml
cache-from: type=gha
cache-to: type=gha,mode=max
```

To add .NET dependency caching:
```yaml
- uses: actions/cache@v3
  with:
    path: ~/.nuget/packages
    key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
```

## Notifications

### Slack Notifications
Add to the end of deploy job:
```yaml
- name: Notify Slack
  uses: slackapi/slack-github-action@v1
  with:
    webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
    payload: |
      {
        "text": "Deployment completed: ${{ job.status }}"
      }
```

### Email Notifications
GitHub sends email notifications for failed workflows automatically.

## Troubleshooting

### SSH Connection Fails
- Verify `SERVER_HOST`, `SERVER_USERNAME`, and `SSH_PRIVATE_KEY` secrets
- Ensure server allows SSH from GitHub's IP ranges
- Check that public key is in `~/.ssh/authorized_keys` on server

### Docker Pull Fails
- Ensure GitHub token has package read permissions
- Make package public or use Personal Access Token with `read:packages` scope

### Container Won't Start
- Check secrets are correctly set
- Review container logs: `docker logs dnd-api`
- Verify environment variables format

## Security Best Practices

1. **Never commit secrets to code**
2. **Use environment-specific secrets** for production vs staging
3. **Rotate secrets regularly**
4. **Use least-privilege service accounts** for SSH access
5. **Enable branch protection** on `main` to require PR reviews
6. **Use environment protection rules** to require manual approval for production deploys

## Next Steps

1. Add secrets to your GitHub repository
2. Push this workflow to your `main` branch
3. Monitor the Actions tab for the first run
4. Adjust the workflow based on your specific needs
</file>

<file path=".github/GITLAB_VS_GITHUB_COMPARISON.md">
# GitLab CI/CD vs GitHub Actions: Side-by-Side Comparison

## Configuration File Structure

### GitLab CI/CD (.gitlab-ci.yml)
```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOTNET_VERSION: "10.0"

build_job:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:10.0
  script:
    - dotnet restore
    - dotnet build
  only:
    - main
    - develop

deploy_job:
  stage: deploy
  script:
    - ssh user@server "docker pull image"
  only:
    - main
  when: manual
```

### GitHub Actions (.github/workflows/ci-cd.yml)
```yaml
on:
  push:
    branches: [ main, develop ]

env:
  DOTNET_VERSION: '10.0.x'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build
        run: |
          dotnet restore
          dotnet build

  deploy:
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: ssh user@server "docker pull image"
    # workflow_dispatch enables manual trigger
```

## Variables and Secrets

### GitLab: CI/CD Variables
**Location**: Settings > CI/CD > Variables

```yaml
# In .gitlab-ci.yml
script:
  - echo $DB_CONNECTION_STRING
  - echo $CI_COMMIT_SHA  # GitLab predefined variable
```

**Variable Types**:
- Regular variables
- Protected variables (only for protected branches)
- Masked variables (hidden in logs)
- File variables (content saved to temp file)

### GitHub: Secrets and Variables
**Location**: Settings > Secrets and variables > Actions

```yaml
# In workflow file
run: |
  echo ${{ secrets.DB_CONNECTION_STRING }}
  echo ${{ github.sha }}  # GitHub context variable
```

**Types**:
- Secrets (encrypted, hidden in logs)
- Variables (plain text, visible)
- Environment secrets (scoped to environments)

## Key Concept Mapping

| GitLab Concept | GitHub Actions Equivalent | Notes |
|----------------|---------------------------|-------|
| `.gitlab-ci.yml` | `.github/workflows/*.yml` | GitHub allows multiple workflow files |
| `stages:` | `jobs:` with `needs:` | GitHub jobs run in parallel by default |
| `stage: build` | `jobs: build:` | Define job dependencies with `needs:` |
| `script:` | `steps:` with `run:` | GitHub uses steps within jobs |
| `image:` | `runs-on:` or `container:` | GitHub has hosted runners |
| `only:` / `except:` | `if:` conditions | GitHub uses expressions |
| `when: manual` | `workflow_dispatch` event | Different trigger mechanism |
| `artifacts:` | `actions/upload-artifact` | GitHub uses actions |
| `cache:` | `actions/cache` | GitHub uses actions |
| `before_script:` | Common step at start | No built-in concept |
| `after_script:` | Add step with `if: always()` | No built-in concept |
| `variables:` | `env:` | GitHub also has `secrets` |
| `$CI_*` variables | `${{ github.* }}` context | Different syntax and names |
| `extends:` | Reusable workflows | Different mechanism |
| `rules:` | `if:` conditions | GitHub uses expressions |
| `environment:` | `environment:` | Similar concept |
| `services:` | `services:` in job | Similar concept |
| `retry:` | `uses: nick-invision/retry@v2` | Needs action |

## Common Variables/Context Mapping

| GitLab Variable | GitHub Context | Value |
|-----------------|----------------|-------|
| `$CI_COMMIT_SHA` | `${{ github.sha }}` | Commit SHA |
| `$CI_COMMIT_REF_NAME` | `${{ github.ref_name }}` | Branch name |
| `$CI_PIPELINE_ID` | `${{ github.run_id }}` | Pipeline/Run ID |
| `$CI_JOB_ID` | `${{ github.job }}` | Job ID |
| `$CI_PROJECT_NAME` | `${{ github.repository }}` | Project name |
| `$CI_COMMIT_MESSAGE` | `${{ github.event.head_commit.message }}` | Commit message |
| `$CI_COMMIT_BRANCH` | `${{ github.ref_name }}` | Branch name |
| `$GITLAB_USER_LOGIN` | `${{ github.actor }}` | Username |
| `$CI_REGISTRY` | `ghcr.io` | Container registry |
| `$CI_REGISTRY_USER` | `${{ github.actor }}` | Registry username |
| `$CI_REGISTRY_PASSWORD` | `${{ secrets.GITHUB_TOKEN }}` | Registry password |

## SSH Deployment Comparison

### GitLab CI/CD
```yaml
deploy:
  stage: deploy
  before_script:
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVER_HOST >> ~/.ssh/known_hosts
  script:
    - ssh $SERVER_USER@$SERVER_HOST "
        docker pull $CI_REGISTRY_IMAGE:latest &&
        docker stop app || true &&
        docker run -d --name app $CI_REGISTRY_IMAGE:latest
      "
  only:
    - main
```

**GitLab Variables to Set**:
- `SSH_PRIVATE_KEY` (Type: File, Protected, Masked)
- `SERVER_HOST`
- `SERVER_USER`

### GitHub Actions
```yaml
deploy:
  runs-on: ubuntu-latest
  if: github.ref == 'refs/heads/main'
  steps:
    - uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          docker pull ghcr.io/${{ github.repository }}:latest
          docker stop app || true
          docker run -d --name app ghcr.io/${{ github.repository }}:latest
```

**GitHub Secrets to Set**:
- `SSH_PRIVATE_KEY`
- `SERVER_HOST`
- `SERVER_USERNAME`

## Docker Build & Push Comparison

### GitLab CI/CD
```yaml
docker-build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
```

**No extra variables needed** - GitLab provides `$CI_REGISTRY_*` automatically

### GitHub Actions
```yaml
docker-build:
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4

    - uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ghcr.io/${{ github.repository }}:${{ github.sha }}
          ghcr.io/${{ github.repository }}:latest
```

**No extra secrets needed** - GitHub provides `GITHUB_TOKEN` automatically

## Environment-Specific Deployment

### GitLab CI/CD
```yaml
deploy_staging:
  stage: deploy
  script:
    - echo "Deploying to staging"
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - develop

deploy_production:
  stage: deploy
  script:
    - echo "Deploying to production"
  environment:
    name: production
    url: https://example.com
  only:
    - main
  when: manual
```

### GitHub Actions
```yaml
deploy-staging:
  if: github.ref == 'refs/heads/develop'
  environment:
    name: staging
    url: https://staging.example.com
  runs-on: ubuntu-latest
  steps:
    - run: echo "Deploying to staging"

deploy-production:
  if: github.ref == 'refs/heads/main'
  environment:
    name: production
    url: https://example.com
  runs-on: ubuntu-latest
  steps:
    - run: echo "Deploying to production"
```

**Environment Protection Rules** (Settings > Environments):
- Required reviewers (similar to `when: manual`)
- Wait timer
- Deployment branches

## Conditional Execution

### GitLab CI/CD
```yaml
job:
  script:
    - echo "Running"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - changes:
        - src/**/*
  # OR using legacy syntax
  only:
    - main
    - merge_requests
  except:
    - tags
```

### GitHub Actions
```yaml
job:
  if: |
    github.ref == 'refs/heads/main' ||
    github.event_name == 'pull_request'
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4
    - run: echo "Running"
```

For path filtering:
```yaml
on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
```

## Matrix Builds

### GitLab CI/CD
```yaml
test:
  parallel:
    matrix:
      - DOTNET_VERSION: ['8.0', '9.0', '10.0']
  script:
    - dotnet test --framework net$DOTNET_VERSION
```

### GitHub Actions
```yaml
test:
  strategy:
    matrix:
      dotnet-version: ['8.0', '9.0', '10.0']
  runs-on: ubuntu-latest
  steps:
    - uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
    - run: dotnet test
```

## Migration Checklist

- [ ] Move `.gitlab-ci.yml` logic to `.github/workflows/`
- [ ] Convert GitLab variables to GitHub secrets
- [ ] Update `$CI_*` variables to `${{ github.* }}`
- [ ] Change `script:` to `steps:` with `run:`
- [ ] Convert `only:`/`except:` to `if:` conditions
- [ ] Replace `extends:` with reusable workflows if needed
- [ ] Update Docker registry from GitLab to GitHub (`ghcr.io`)
- [ ] Configure environment protection rules
- [ ] Set up branch protection rules
- [ ] Test SSH access from GitHub Actions runners
- [ ] Update documentation with new workflow triggers

## Quick Reference Card

```
# Access secrets
GitLab:  $MY_SECRET  or  ${{ env.MY_SECRET }}
GitHub:  ${{ secrets.MY_SECRET }}

# Access commit SHA
GitLab:  $CI_COMMIT_SHA
GitHub:  ${{ github.sha }}

# Access branch name
GitLab:  $CI_COMMIT_REF_NAME
GitHub:  ${{ github.ref_name }}

# Run on specific branch
GitLab:  only: [ main ]
GitHub:  if: github.ref == 'refs/heads/main'

# Manual trigger
GitLab:  when: manual
GitHub:  workflow_dispatch (in 'on:' section)

# Job dependencies
GitLab:  stage: deploy (stages run in order)
GitHub:  needs: [build, test]

# Docker registry
GitLab:  $CI_REGISTRY/group/project
GitHub:  ghcr.io/username/repository
```
</file>

<file path=".github/MULTI_PLATFORM_BUILD.md">
# Multi-Platform Docker Builds

## The Problem

You encountered this error:
```
no matching manifest for linux/arm64/v8 in the manifest list entries
```

This means your Docker image was built for **AMD64 (x86_64)** architecture, but your server runs on **ARM64** architecture.

## Architecture Types

- **AMD64 (x86_64)**: Standard Intel/AMD processors (most cloud servers, desktops, laptops)
- **ARM64 (aarch64)**: ARM-based processors (Raspberry Pi, Apple Silicon M1/M2, AWS Graviton, Oracle ARM instances)

## How to Check Your Server Architecture

SSH into your server and run:
```bash
uname -m
```

Output examples:
- `x86_64` = AMD64 architecture
- `aarch64` or `arm64` = ARM64 architecture

Or check with:
```bash
dpkg --print-architecture
```

## The Solution

Build Docker images for **multiple platforms** so they work on any server type.

### What Changed in the Workflow

In `.github/workflows/main.yml`, I added the `platforms` parameter:

```yaml
- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    context: .
    file: ./src/DnDMapBuilder.Api/Dockerfile
    platforms: linux/amd64,linux/arm64  # ← Added this line
    push: true
    tags: ${{ steps.meta.outputs.tags }}
    labels: ${{ steps.meta.outputs.labels }}
```

This tells Docker to build images for both:
- `linux/amd64` - Standard x86_64 servers
- `linux/arm64` - ARM-based servers

## How Multi-Platform Images Work

1. **Build Time**: GitHub Actions builds the image twice (once for each architecture)
2. **Push Time**: Both images are pushed to the registry with the same tag
3. **Pull Time**: Docker automatically selects the correct architecture for your server

When you run `docker pull ghcr.io/mikedeik/dndmapbuilder-api:latest`, Docker will:
- Pull the ARM64 version on ARM servers
- Pull the AMD64 version on x86_64 servers

## Verifying Multi-Platform Support

After the next build, check your image on GitHub Container Registry:

1. Go to: https://github.com/users/mikedeik/packages/container/dndmapbuilder-api
2. Click on a tag (e.g., `latest`)
3. Look for "OS/Arch" - you should see both:
   - `linux/amd64`
   - `linux/arm64`

Or check via CLI:
```bash
docker manifest inspect ghcr.io/mikedeik/dndmapbuilder-api:latest
```

You should see two manifests listed.

## Build Time Impact

Multi-platform builds take longer because:
- Each platform is built separately
- ARM builds on AMD64 runners use QEMU emulation (slower)

Typical build times:
- Single platform (amd64): 2-5 minutes
- Multi-platform (amd64 + arm64): 5-15 minutes

## Optimizations

### Option 1: Build Only for Your Server Architecture

If you only deploy to ARM64 servers, change to:
```yaml
platforms: linux/arm64
```

If you only deploy to AMD64 servers, change to:
```yaml
platforms: linux/amd64
```

Or remove the `platforms` line entirely (defaults to AMD64).

### Option 2: Use Native Runners

For faster ARM64 builds, use native ARM64 runners:
```yaml
build-docker:
  strategy:
    matrix:
      include:
        - platform: linux/amd64
          runner: ubuntu-latest
        - platform: linux/arm64
          runner: ubuntu-24.04-arm  # GitHub's ARM runners
```

Note: GitHub's ARM runners are currently in beta and may require a paid plan.

### Option 3: Conditional Builds

Build for multiple platforms only on releases:
```yaml
- name: Set platforms
  id: platforms
  run: |
    if [[ "${{ github.ref }}" == "refs/tags/v"* ]]; then
      echo "platforms=linux/amd64,linux/arm64" >> $GITHUB_OUTPUT
    else
      echo "platforms=linux/amd64" >> $GITHUB_OUTPUT
    fi

- name: Build and push Docker image
  uses: docker/build-push-action@v5
  with:
    platforms: ${{ steps.platforms.outputs.platforms }}
    # ... rest of config
```

## Troubleshooting

### Build fails with "exec format error"

This means you're trying to run an image built for a different architecture. Solution:
- Ensure multi-platform build is enabled
- Pull the latest image after the new build completes

### "Cannot connect to Docker daemon during build"

QEMU might not be set up properly. The workflow already includes `docker/setup-buildx-action@v3` which handles this automatically.

### Slow builds

ARM64 builds on AMD64 runners are slow due to QEMU emulation. This is normal. Consider:
- Building only for your target architecture
- Using native ARM runners (if available)
- Caching layers aggressively

## Common Server Types

| Provider | Service | Architecture |
|----------|---------|--------------|
| AWS | EC2 (t3, m5, c5) | AMD64 |
| AWS | EC2 (t4g, m6g, c6g) Graviton | ARM64 |
| DigitalOcean | Standard Droplets | AMD64 |
| Oracle Cloud | VM.Standard.E2.1.Micro (Free Tier) | AMD64 |
| Oracle Cloud | VM.Standard.A1.Flex (Free Tier) | ARM64 |
| Raspberry Pi | All models | ARM64 |
| Apple Silicon | M1/M2 Macs | ARM64 |
| Google Cloud | N1, N2, E2 | AMD64 |
| Google Cloud | T2A (Tau) | ARM64 |

## Next Steps

1. Commit and push the updated workflow
2. Let the build complete (will take longer this time)
3. Retry deployment - it should now work on your ARM64 server
</file>

<file path="src/DnDMapBuilder.Api/GlobalSuppressions.cs">
using System.Diagnostics.CodeAnalysis;
[assembly: SuppressMessage("Style", "NU1510:PackageReference will not be pruned",
    Justification = "Microsoft.AspNetCore.RateLimiting is used in Program.cs for rate limiting configuration")]
</file>

<file path="src/DnDMapBuilder.AppHost/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Aspire.Hosting.Dcp": "Warning"
    }
  }
}
</file>

<file path="src/DnDMapBuilder.AppHost/DnDMapBuilder.AppHost.csproj">
<Project Sdk="Aspire.AppHost.Sdk/13.1.0">

    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net10.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <UserSecretsId>341d30cb-17ac-469c-8407-79b6afe8eb3b</UserSecretsId>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Aspire.Hosting.SqlServer" Version="13.1.0" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Application/Common/Result.cs">
namespace DnDMapBuilder.Application.Common;
public class Result
{
    public bool IsSuccess { get; }
    public string? Error { get; }
    public IReadOnlyList<string> Errors { get; }
    private Result(bool isSuccess, string? error, IReadOnlyList<string>? errors)
    {
        IsSuccess = isSuccess;
        Error = error;
        Errors = errors ?? new List<string>();
    }
    public static Result Success()
    {
        return new Result(true, null, null);
    }
    public static Result Failure(string error)
    {
        return new Result(false, error, new[] { error });
    }
    public static Result Failure(IEnumerable<string> errors)
    {
        var errorList = errors.ToList();
        return new Result(false, errorList.FirstOrDefault(), errorList);
    }
}
public class Result<T>
{
    public bool IsSuccess { get; }
    public T? Data { get; }
    public string? Error { get; }
    public IReadOnlyList<string> Errors { get; }
    private Result(bool isSuccess, T? data, string? error, IReadOnlyList<string>? errors)
    {
        IsSuccess = isSuccess;
        Data = data;
        Error = error;
        Errors = errors ?? new List<string>();
    }
    public static Result<T> Success(T data)
    {
        return new Result<T>(true, data, null, null);
    }
    public static Result<T> Failure(string error)
    {
        return new Result<T>(false, default, error, new[] { error });
    }
    public static Result<T> Failure(IEnumerable<string> errors)
    {
        var errorList = errors.ToList();
        return new Result<T>(false, default, errorList.FirstOrDefault(), errorList);
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/ICampaignService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
namespace DnDMapBuilder.Application.Interfaces;
public interface ICampaignService
{
    Task<CampaignDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);
    Task<IEnumerable<CampaignDto>> GetUserCampaignsAsync(string userId, CancellationToken cancellationToken = default);
    Task<CampaignDto> CreateAsync(CreateCampaignRequest request, string userId, CancellationToken cancellationToken = default);
    Task<CampaignDto?> UpdateAsync(string id, UpdateCampaignRequest request, string userId, CancellationToken cancellationToken = default);
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IFileStorageService.cs">
namespace DnDMapBuilder.Application.Interfaces;
public interface IFileStorageService
{
    Task<string> UploadAsync(Stream file, string fileName, string contentType, string storageCategory, CancellationToken cancellationToken = default);
    string GetPublicUrl(string fileId, string storageCategory);
    Task<bool> DeleteAsync(string fileId, string storageCategory, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IFileValidationService.cs">
namespace DnDMapBuilder.Application.Interfaces;
public interface IFileValidationService
{
    FileValidationResult ValidateFile(string fileName, long fileSize, string contentType, string storageCategory);
    long GetMaxFileSizeForCategory(string storageCategory);
    string[] GetAllowedMimeTypesForCategory(string storageCategory);
}
public class FileValidationResult
{
    public FileValidationResult()
    {
        IsValid = true;
        Errors = new List<string>();
    }
    public FileValidationResult(string error) : this(new[] { error })
    {
    }
    public FileValidationResult(string[] errors)
    {
        IsValid = false;
        Errors = new List<string>(errors);
    }
    public bool IsValid { get; }
    public List<string> Errors { get; }
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IGameMapService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
namespace DnDMapBuilder.Application.Interfaces;
public interface IGameMapService
{
    Task<GameMapDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);
    Task<IEnumerable<GameMapDto>> GetByMissionIdAsync(string missionId, string userId, CancellationToken cancellationToken = default);
    Task<GameMapDto> CreateAsync(CreateMapRequest request, string userId, CancellationToken cancellationToken = default);
    Task<GameMapDto?> UpdateAsync(string id, UpdateMapRequest request, string userId, CancellationToken cancellationToken = default);
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IJwtService.cs">
namespace DnDMapBuilder.Application.Interfaces;
public interface IJwtService
{
    string GenerateToken(string userId, string email, string role);
    string? ValidateToken(string token);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IMissionService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
namespace DnDMapBuilder.Application.Interfaces;
public interface IMissionService
{
    Task<MissionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);
    Task<IEnumerable<MissionDto>> GetByCampaignIdAsync(string campaignId, string userId, CancellationToken cancellationToken = default);
    Task<MissionDto> CreateAsync(CreateMissionRequest request, string userId, CancellationToken cancellationToken = default);
    Task<MissionDto?> UpdateAsync(string id, UpdateMissionRequest request, string userId, CancellationToken cancellationToken = default);
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IOAuthService.cs">
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
namespace DnDMapBuilder.Application.Interfaces;
public interface IOAuthService
{
    Task<OAuthUrlResponse> GetAuthorizationUrlAsync(string provider, string redirectUri);
    Task<AuthResponse?> HandleOAuthCallbackAsync(OAuthLoginRequest request, CancellationToken cancellationToken = default);
    Task<AuthResponse?> ValidateIdTokenAsync(OAuthTokenRequest request, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IPasswordService.cs">
namespace DnDMapBuilder.Application.Interfaces;
public interface IPasswordService
{
    string HashPassword(string password);
    bool VerifyPassword(string password, string hash);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/ITokenDefinitionService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
namespace DnDMapBuilder.Application.Interfaces;
public interface ITokenDefinitionService
{
    Task<TokenDefinitionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default);
    Task<IEnumerable<TokenDefinitionDto>> GetUserTokensAsync(string userId, CancellationToken cancellationToken = default);
    Task<TokenDefinitionDto> CreateAsync(CreateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default);
    Task<TokenDefinitionDto?> UpdateAsync(string id, UpdateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default);
    Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Services/AppleOAuthService.cs">
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text.Json;
using DnDMapBuilder.Contracts.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;
namespace DnDMapBuilder.Application.Services;
public class AppleOAuthService
{
    private readonly HttpClient _httpClient;
    private readonly OAuthSettings _settings;
    private readonly ILogger<AppleOAuthService> _logger;
    private const string AuthEndpoint = "https://appleid.apple.com/auth/authorize";
    private const string TokenEndpoint = "https://appleid.apple.com/auth/token";
    private const string KeysEndpoint = "https://appleid.apple.com/auth/keys";
    public AppleOAuthService(
        HttpClient httpClient,
        IOptions<OAuthSettings> settings,
        ILogger<AppleOAuthService> logger)
    {
        _httpClient = httpClient;
        _settings = settings.Value;
        _logger = logger;
    }
    public string GetAuthorizationUrl(string redirectUri, string state)
    {
        var scopes = Uri.EscapeDataString("name email");
        return $"{AuthEndpoint}?client_id={_settings.Apple.ClientId}&redirect_uri={Uri.EscapeDataString(redirectUri)}&response_type=code&scope={scopes}&state={state}&response_mode=form_post";
    }
    public async Task<AppleTokenResponse?> ExchangeCodeForTokensAsync(string code, string redirectUri)
    {
        var clientSecret = GenerateClientSecret();
        var content = new FormUrlEncodedContent(new Dictionary<string, string>
        {
            ["code"] = code,
            ["client_id"] = _settings.Apple.ClientId,
            ["client_secret"] = clientSecret,
            ["redirect_uri"] = redirectUri,
            ["grant_type"] = "authorization_code"
        });
        var response = await _httpClient.PostAsync(TokenEndpoint, content);
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to exchange Apple auth code: {Status}", response.StatusCode);
            return null;
        }
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<AppleTokenResponse>(json);
    }
    public async Task<AppleUserInfo?> ValidateIdTokenAsync(string idToken)
    {
        try
        {
            var keysResponse = await _httpClient.GetStringAsync(KeysEndpoint);
            var keys = JsonSerializer.Deserialize<AppleKeysResponse>(keysResponse);
            if (keys?.Keys == null || keys.Keys.Count == 0)
            {
                _logger.LogError("Failed to get Apple public keys");
                return null;
            }
            var handler = new JwtSecurityTokenHandler();
            var jwtToken = handler.ReadJwtToken(idToken);
            var kid = jwtToken.Header.Kid;
            var key = keys.Keys.FirstOrDefault(k => k.Kid == kid);
            if (key == null)
            {
                _logger.LogError("No matching Apple key found for kid: {Kid}", kid);
                return null;
            }
            var rsa = new RSACryptoServiceProvider();
            rsa.ImportParameters(new RSAParameters
            {
                Modulus = Base64UrlEncoder.DecodeBytes(key.N),
                Exponent = Base64UrlEncoder.DecodeBytes(key.E)
            });
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidIssuer = "https://appleid.apple.com",
                ValidateAudience = true,
                ValidAudience = _settings.Apple.ClientId,
                ValidateLifetime = true,
                IssuerSigningKey = new RsaSecurityKey(rsa)
            };
            var principal = handler.ValidateToken(idToken, validationParameters, out _);
            return new AppleUserInfo
            {
                Id = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? string.Empty,
                Email = principal.FindFirst(ClaimTypes.Email)?.Value ?? string.Empty,
                EmailVerified = true
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to validate Apple ID token");
            return null;
        }
    }
    private string GenerateClientSecret()
    {
        var now = DateTime.UtcNow;
        var ecdsa = ECDsa.Create();
        ecdsa.ImportPkcs8PrivateKey(Convert.FromBase64String(_settings.Apple.PrivateKey), out _);
        var signingCredentials = new SigningCredentials(
            new ECDsaSecurityKey(ecdsa) { KeyId = _settings.Apple.KeyId },
            SecurityAlgorithms.EcdsaSha256);
        var claims = new[]
        {
            new Claim("iss", _settings.Apple.TeamId),
            new Claim("iat", ((long)(now - DateTime.UnixEpoch).TotalSeconds).ToString()),
            new Claim("exp", ((long)(now.AddMonths(6) - DateTime.UnixEpoch).TotalSeconds).ToString()),
            new Claim("aud", "https://appleid.apple.com"),
            new Claim("sub", _settings.Apple.ClientId)
        };
        var token = new JwtSecurityToken(
            claims: claims,
            signingCredentials: signingCredentials);
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
public class AppleTokenResponse
{
    [System.Text.Json.Serialization.JsonPropertyName("access_token")]
    public string AccessToken { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("id_token")]
    public string IdToken { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("refresh_token")]
    public string? RefreshToken { get; set; }
    [System.Text.Json.Serialization.JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }
}
public class AppleUserInfo
{
    public string Id { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public bool EmailVerified { get; set; }
    public string? Name { get; set; }
}
public class AppleKeysResponse
{
    [System.Text.Json.Serialization.JsonPropertyName("keys")]
    public List<AppleKey> Keys { get; set; } = new();
}
public class AppleKey
{
    [System.Text.Json.Serialization.JsonPropertyName("kid")]
    public string Kid { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("n")]
    public string N { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("e")]
    public string E { get; set; } = string.Empty;
}
</file>

<file path="src/DnDMapBuilder.Application/Services/FileValidationService.cs">
using DnDMapBuilder.Application.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class FileValidationService : IFileValidationService
{
    private static readonly Dictionary<string, (long MaxSize, string[] AllowedMimeTypes)> CategoryConfig =
        new()
        {
            {
                "maps",
                (
                    MaxSize: 5 * 1024 * 1024,
                    AllowedMimeTypes: new[] { "image/png", "image/jpeg", "image/webp" }
                )
            },
            {
                "tokens",
                (
                    MaxSize: 2 * 1024 * 1024,
                    AllowedMimeTypes: new[] { "image/png", "image/jpeg", "image/webp" }
                )
            },
            {
                "default",
                (
                    MaxSize: 10 * 1024 * 1024,
                    AllowedMimeTypes: new[] { "application/octet-stream" }
                )
            }
        };
    public FileValidationResult ValidateFile(string fileName, long fileSize, string contentType, string storageCategory)
    {
        var errors = new List<string>();
        if (string.IsNullOrWhiteSpace(fileName))
        {
            errors.Add("File name cannot be empty.");
            return new FileValidationResult(errors.ToArray());
        }
        var maxSize = GetMaxFileSizeForCategory(storageCategory);
        if (fileSize == 0)
        {
            errors.Add("File cannot be empty.");
        }
        else if (fileSize > maxSize)
        {
            errors.Add($"File size exceeds the maximum limit of {maxSize / (1024 * 1024)}MB for {storageCategory}.");
        }
        var allowedMimeTypes = GetAllowedMimeTypesForCategory(storageCategory);
        var normalizedContentType = (contentType ?? "").ToLowerInvariant();
        if (!allowedMimeTypes.Contains(normalizedContentType))
        {
            var supportedTypes = string.Join(", ", allowedMimeTypes);
            errors.Add($"File type '{normalizedContentType}' is not allowed. Supported types: {supportedTypes}");
        }
        return errors.Count > 0 ? new FileValidationResult(errors.ToArray()) : new FileValidationResult();
    }
    /// <summary>
    /// Gets the maximum allowed file size for a storage category.
    /// </summary>
    public long GetMaxFileSizeForCategory(string storageCategory)
    {
        var category = (storageCategory ?? "default").ToLowerInvariant();
        return CategoryConfig.ContainsKey(category) ? CategoryConfig[category].MaxSize : CategoryConfig["default"].MaxSize;
    }
    public string[] GetAllowedMimeTypesForCategory(string storageCategory)
    {
        var category = (storageCategory ?? "default").ToLowerInvariant();
        return CategoryConfig.ContainsKey(category) ? CategoryConfig[category].AllowedMimeTypes : CategoryConfig["default"].AllowedMimeTypes;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/GameMapService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class GameMapService : IGameMapService
{
    private readonly IGameMapRepository _mapRepository;
    private readonly IMissionRepository _missionRepository;
    private readonly ICampaignRepository _campaignRepository;
    private readonly IMapTokenInstanceRepository _tokenInstanceRepository;
    public GameMapService(
        IGameMapRepository mapRepository,
        IMissionRepository missionRepository,
        ICampaignRepository campaignRepository,
        IMapTokenInstanceRepository tokenInstanceRepository)
    {
        _mapRepository = mapRepository;
        _missionRepository = missionRepository;
        _campaignRepository = campaignRepository;
        _tokenInstanceRepository = tokenInstanceRepository;
    }
    public async Task<GameMapDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var map = await _mapRepository.GetWithTokensAsync(id, cancellationToken);
        if (map == null)
        {
            return null;
        }
        if (!await HasAccessToMapAsync(map.MissionId, userId, cancellationToken))
        {
            return null;
        }
        return map.ToDto();
    }
    public async Task<IEnumerable<GameMapDto>> GetByMissionIdAsync(string missionId, string userId, CancellationToken cancellationToken = default)
    {
        if (!await HasAccessToMapAsync(missionId, userId, cancellationToken))
        {
            return Enumerable.Empty<GameMapDto>();
        }
        var maps = await _mapRepository.GetByMissionIdAsync(missionId, cancellationToken);
        return maps.Select(m => m.ToDto());
    }
    public async Task<GameMapDto> CreateAsync(CreateMapRequest request, string userId, CancellationToken cancellationToken = default)
    {
        if (!await HasAccessToMapAsync(request.MissionId, userId, cancellationToken))
        {
            throw new UnauthorizedAccessException("You don't have permission to add maps to this mission.");
        }
        var map = new GameMap
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            ImageUrl = request.ImageUrl,
            Rows = request.Rows,
            Cols = request.Cols,
            GridColor = request.GridColor,
            GridOpacity = request.GridOpacity,
            MissionId = request.MissionId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        await _mapRepository.AddAsync(map, cancellationToken);
        return map.ToDto();
    }
    public async Task<GameMapDto?> UpdateAsync(string id, UpdateMapRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var map = await _mapRepository.GetByIdAsync(id, cancellationToken);
        if (map == null)
        {
            return null;
        }
        if (!await HasAccessToMapAsync(map.MissionId, userId, cancellationToken))
        {
            return null;
        }
        map.Name = request.Name;
        map.ImageUrl = request.ImageUrl;
        map.Rows = request.Rows;
        map.Cols = request.Cols;
        map.GridColor = request.GridColor;
        map.GridOpacity = request.GridOpacity;
        map.UpdatedAt = DateTime.UtcNow;
        await _tokenInstanceRepository.DeleteByMapIdAsync(map.Id, cancellationToken);
        foreach (var tokenReq in request.Tokens)
        {
            var tokenInstance = new MapTokenInstance
            {
                Id = Guid.NewGuid().ToString(),
                TokenId = tokenReq.TokenId,
                MapId = map.Id,
                X = tokenReq.X,
                Y = tokenReq.Y,
                CreatedAt = DateTime.UtcNow
            };
            await _tokenInstanceRepository.AddAsync(tokenInstance, cancellationToken);
        }
        await _mapRepository.UpdateAsync(map, cancellationToken);
        var updatedMap = await _mapRepository.GetWithTokensAsync(id, cancellationToken);
        return updatedMap?.ToDto();
    }
    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var map = await _mapRepository.GetByIdAsync(id, cancellationToken);
        if (map == null)
        {
            return false;
        }
        if (!await HasAccessToMapAsync(map.MissionId, userId, cancellationToken))
        {
            return false;
        }
        await _mapRepository.DeleteAsync(id, cancellationToken);
        return true;
    }
    private async Task<bool> HasAccessToMapAsync(string missionId, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetByIdAsync(missionId, cancellationToken);
        if (mission == null)
        {
            return false;
        }
        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        return campaign != null && campaign.OwnerId == userId;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/JwtService.cs">
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Microsoft.IdentityModel.Tokens;
using DnDMapBuilder.Application.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class JwtService : IJwtService
{
    private readonly string _secret;
    private readonly string _issuer;
    private readonly string _audience;
    private readonly int _expirationMinutes;
    public JwtService(string secret, string issuer, string audience, int expirationMinutes = 1440)
    {
        _secret = secret;
        _issuer = issuer;
        _audience = audience;
        _expirationMinutes = expirationMinutes;
    }
    public string GenerateToken(string userId, string email, string role)
    {
        var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_secret));
        var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);
        var claims = new[]
        {
            new Claim(JwtRegisteredClaimNames.Sub, userId),
            new Claim(JwtRegisteredClaimNames.Email, email),
            new Claim(ClaimTypes.Role, role),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };
        var token = new JwtSecurityToken(
            issuer: _issuer,
            audience: _audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_expirationMinutes),
            signingCredentials: credentials
        );
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
    public string? ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_secret);
        try
        {
            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = _issuer,
                ValidateAudience = true,
                ValidAudience = _audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            };
            var principal = tokenHandler.ValidateToken(token, validationParameters, out var validatedToken);
            var jwtToken = (JwtSecurityToken)validatedToken;
            var userId = jwtToken.Claims.First(x => x.Type == JwtRegisteredClaimNames.Sub).Value;
            return userId;
        }
        catch
        {
            return null;
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/OAuthService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.Configuration;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
namespace DnDMapBuilder.Application.Services;
public class OAuthService : IOAuthService
{
    private readonly GoogleOAuthService _googleService;
    private readonly AppleOAuthService _appleService;
    private readonly IUserRepository _userRepository;
    private readonly IJwtService _jwtService;
    private readonly OAuthSettings _settings;
    private readonly ILogger<OAuthService> _logger;
    public OAuthService(
        GoogleOAuthService googleService,
        AppleOAuthService appleService,
        IUserRepository userRepository,
        IJwtService jwtService,
        IOptions<OAuthSettings> settings,
        ILogger<OAuthService> logger)
    {
        _googleService = googleService;
        _appleService = appleService;
        _userRepository = userRepository;
        _jwtService = jwtService;
        _settings = settings.Value;
        _logger = logger;
    }
    public Task<OAuthUrlResponse> GetAuthorizationUrlAsync(string provider, string redirectUri)
    {
        var state = GenerateState();
        var authUrl = provider.ToLowerInvariant() switch
        {
            "google" => _googleService.GetAuthorizationUrl(redirectUri, state),
            "apple" => _appleService.GetAuthorizationUrl(redirectUri, state),
            _ => throw new ArgumentException($"Unsupported OAuth provider: {provider}")
        };
        return Task.FromResult(new OAuthUrlResponse(authUrl, state));
    }
    public async Task<AuthResponse?> HandleOAuthCallbackAsync(OAuthLoginRequest request, CancellationToken cancellationToken = default)
    {
        return request.Provider.ToLowerInvariant() switch
        {
            "google" => await HandleGoogleCallbackAsync(request.Code, request.RedirectUri, cancellationToken),
            "apple" => await HandleAppleCallbackAsync(request.Code, request.RedirectUri, cancellationToken),
            _ => throw new ArgumentException($"Unsupported OAuth provider: {request.Provider}")
        };
    }
    public async Task<AuthResponse?> ValidateIdTokenAsync(OAuthTokenRequest request, CancellationToken cancellationToken = default)
    {
        return request.Provider.ToLowerInvariant() switch
        {
            "google" => await ValidateGoogleIdTokenAsync(request.IdToken, cancellationToken),
            "apple" => await ValidateAppleIdTokenAsync(request.IdToken, cancellationToken),
            _ => throw new ArgumentException($"Unsupported OAuth provider: {request.Provider}")
        };
    }
    private async Task<AuthResponse?> HandleGoogleCallbackAsync(string code, string redirectUri, CancellationToken cancellationToken)
    {
        var tokens = await _googleService.ExchangeCodeForTokensAsync(code, redirectUri);
        if (tokens == null) return null;
        var userInfo = await _googleService.ValidateIdTokenAsync(tokens.IdToken);
        if (userInfo == null) return null;
        return await CreateOrUpdateUserAndGenerateTokenAsync("google", userInfo.Id, userInfo.Email, userInfo.Name, userInfo.Picture, userInfo.EmailVerified, cancellationToken);
    }
    private async Task<AuthResponse?> HandleAppleCallbackAsync(string code, string redirectUri, CancellationToken cancellationToken)
    {
        var tokens = await _appleService.ExchangeCodeForTokensAsync(code, redirectUri);
        if (tokens == null) return null;
        var userInfo = await _appleService.ValidateIdTokenAsync(tokens.IdToken);
        if (userInfo == null) return null;
        return await CreateOrUpdateUserAndGenerateTokenAsync("apple", userInfo.Id, userInfo.Email, userInfo.Name, null, userInfo.EmailVerified, cancellationToken);
    }
    private async Task<AuthResponse?> ValidateGoogleIdTokenAsync(string idToken, CancellationToken cancellationToken)
    {
        var userInfo = await _googleService.ValidateIdTokenAsync(idToken);
        if (userInfo == null) return null;
        return await CreateOrUpdateUserAndGenerateTokenAsync("google", userInfo.Id, userInfo.Email, userInfo.Name, userInfo.Picture, userInfo.EmailVerified, cancellationToken);
    }
    private async Task<AuthResponse?> ValidateAppleIdTokenAsync(string idToken, CancellationToken cancellationToken)
    {
        var userInfo = await _appleService.ValidateIdTokenAsync(idToken);
        if (userInfo == null) return null;
        return await CreateOrUpdateUserAndGenerateTokenAsync("apple", userInfo.Id, userInfo.Email, userInfo.Name, null, userInfo.EmailVerified, cancellationToken);
    }
    private async Task<AuthResponse?> CreateOrUpdateUserAndGenerateTokenAsync(
        string provider,
        string providerId,
        string email,
        string? name,
        string? picture,
        bool emailVerified,
        CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByOAuthProviderAsync(provider, providerId, cancellationToken);
        if (user == null)
        {
            user = await _userRepository.GetByEmailAsync(email, cancellationToken);
            if (user != null)
            {
                user.OAuthProvider = provider;
                user.OAuthProviderId = providerId;
                user.ProfilePictureUrl = picture;
                user.EmailVerified = emailVerified;
                user.UpdatedAt = DateTime.UtcNow;
                await _userRepository.UpdateAsync(user, cancellationToken);
            }
        }
        if (user == null)
        {
            user = new User
            {
                Id = Guid.NewGuid().ToString(),
                Username = name ?? email.Split('@')[0],
                Email = email,
                PasswordHash = string.Empty,
                Role = "user",
                Status = "approved",
                OAuthProvider = provider,
                OAuthProviderId = providerId,
                ProfilePictureUrl = picture,
                EmailVerified = emailVerified,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            await _userRepository.AddAsync(user, cancellationToken);
        }
        if (user.Status != "approved")
        {
            _logger.LogWarning("OAuth user {Email} attempted login but status is {Status}", email, user.Status);
            return null;
        }
        var token = _jwtService.GenerateToken(user.Id, user.Email, user.Role);
        var userDto = user.ToDto();
        return new AuthResponse(token, userDto.Id, userDto.Username, userDto.Email, userDto.Role, userDto.Status);
    }
    private static string GenerateState()
    {
        var bytes = new byte[32];
        using var rng = System.Security.Cryptography.RandomNumberGenerator.Create();
        rng.GetBytes(bytes);
        return Convert.ToBase64String(bytes).Replace("+", "-").Replace("/", "_").TrimEnd('=');
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/PasswordService.cs">
using DnDMapBuilder.Application.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class PasswordService : IPasswordService
{
    public string HashPassword(string password)
    {
        return BCrypt.Net.BCrypt.HashPassword(password);
    }
    public bool VerifyPassword(string password, string hash)
    {
        return BCrypt.Net.BCrypt.Verify(password, hash);
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/TokenDefinitionService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class TokenDefinitionService : ITokenDefinitionService
{
    private readonly ITokenDefinitionRepository _tokenRepository;
    public TokenDefinitionService(ITokenDefinitionRepository tokenRepository)
    {
        _tokenRepository = tokenRepository;
    }
    public async Task<TokenDefinitionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var token = await _tokenRepository.GetByIdAsync(id, cancellationToken);
        if (token == null || token.UserId != userId)
        {
            return null;
        }
        return token.ToDto();
    }
    public async Task<IEnumerable<TokenDefinitionDto>> GetUserTokensAsync(string userId, CancellationToken cancellationToken = default)
    {
        var tokens = await _tokenRepository.GetByUserIdAsync(userId, cancellationToken);
        return tokens.Select(t => t.ToDto());
    }
    public async Task<TokenDefinitionDto> CreateAsync(CreateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var token = new TokenDefinition
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            ImageUrl = request.ImageUrl,
            Size = request.Size,
            Type = request.Type,
            UserId = userId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        await _tokenRepository.AddAsync(token, cancellationToken);
        return token.ToDto();
    }
    public async Task<TokenDefinitionDto?> UpdateAsync(string id, UpdateTokenDefinitionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var token = await _tokenRepository.GetByIdAsync(id, cancellationToken);
        if (token == null || token.UserId != userId)
        {
            return null;
        }
        token.Name = request.Name;
        token.ImageUrl = request.ImageUrl;
        token.Size = request.Size;
        token.Type = request.Type;
        token.UpdatedAt = DateTime.UtcNow;
        await _tokenRepository.UpdateAsync(token, cancellationToken);
        return token.ToDto();
    }
    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var token = await _tokenRepository.GetByIdAsync(id, cancellationToken);
        if (token == null || token.UserId != userId)
        {
            return false;
        }
        await _tokenRepository.DeleteAsync(id, cancellationToken);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.ArchitectureTests/ArchitectureTests.cs">
using System.Reflection;
using Xunit;
using DnDMapBuilder.Api.Controllers;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Repositories;
namespace DnDMapBuilder.ArchitectureTests;
public class ArchitectureTests
{
    private static readonly Assembly ApiAssembly = typeof(AuthController).Assembly;
    private static readonly Assembly ApplicationAssembly = typeof(IAuthService).Assembly;
    private static readonly Assembly DataAssembly = typeof(DnDMapBuilderDbContext).Assembly;
    [Fact]
    public void All_Controllers_ShouldInheritFrom_ControllerBase()
    {
        var controllerTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Api.Controllers") == true &&
                        t.IsClass &&
                        !t.IsAbstract &&
                        !t.IsCompilerGenerated())
            .ToList();
        var invalidControllers = controllerTypes
            .Where(t => !typeof(Microsoft.AspNetCore.Mvc.ControllerBase).IsAssignableFrom(t))
            .ToList();
        Assert.Empty(invalidControllers);
    }
    [Fact]
    public void All_Controllers_ShouldHaveName_EndingWith_Controller()
    {
        var controllerTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Api.Controllers") == true &&
                        t.IsClass &&
                        !t.IsAbstract &&
                        !t.IsCompilerGenerated())
            .ToList();
        var invalidControllers = controllerTypes.Where(c => !c.Name.EndsWith("Controller")).ToList();
        Assert.Empty(invalidControllers);
    }
    [Fact]
    public void ApplicationLayer_ShouldNotReference_ApiLayer()
    {
        var appTypes = ApplicationAssembly.GetTypes();
        var apiNamespace = "DnDMapBuilder.Api";
        var appWithApiDeps = appTypes
            .Where(t => t.GetProperties()
                .Any(p => p.PropertyType.Namespace?.StartsWith(apiNamespace) == true) ||
                   t.GetFields()
                .Any(f => f.FieldType.Namespace?.StartsWith(apiNamespace) == true))
            .ToList();
        Assert.Empty(appWithApiDeps);
    }
    [Fact]
    public void DataLayer_ShouldNotReference_ApplicationLayer()
    {
        var dataTypes = DataAssembly.GetTypes();
        var appNamespace = "DnDMapBuilder.Application";
        var dataWithAppDeps = dataTypes
            .Where(t => t.GetProperties()
                .Any(p => p.PropertyType.Namespace?.StartsWith(appNamespace) == true) ||
                   t.GetFields()
                .Any(f => f.FieldType.Namespace?.StartsWith(appNamespace) == true))
            .ToList();
        Assert.Empty(dataWithAppDeps);
    }
    [Fact]
    public void All_ServiceInterfaces_ShouldHaveImplementation()
    {
        var interfaceTypes = ApplicationAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Application.Interfaces") == true &&
                        t.IsInterface)
            .ToList();
        var serviceTypes = ApplicationAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Application.Services") == true &&
                        t.IsClass &&
                        !t.IsAbstract)
            .ToList();
        foreach (var interfaceType in interfaceTypes)
        {
            var implementingService = serviceTypes.FirstOrDefault(s => interfaceType.IsAssignableFrom(s));
            Assert.NotNull(implementingService);
        }
    }
    [Fact]
    public void All_Repositories_ShouldHaveName_EndingWith_Repository()
    {
        var repositoryTypes = DataAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Data.Repositories") == true &&
                        t.IsClass &&
                        !t.IsAbstract &&
                        !t.Name.EndsWith("Tests") &&
                        !t.IsCompilerGenerated())
            .ToList();
        var invalidRepos = repositoryTypes.Where(r =>
        {
            var cleanName = r.Name.Split('`')[0];
            return !cleanName.EndsWith("Repository");
        }).ToList();
        Assert.Empty(invalidRepos);
    }
    [Fact]
    public void Services_ShouldNotHaveDirect_DbContextDependency()
    {
        var servicesWithDbContext = ApplicationAssembly.GetTypes()
            .Where(t => t.Namespace?.StartsWith("DnDMapBuilder.Application.Services") == true &&
                        t.IsClass &&
                        !t.IsAbstract)
            .Where(t => t.GetConstructors()
                .SelectMany(c => c.GetParameters())
                .Any(p => p.ParameterType.Name == "DnDMapBuilderDbContext"))
            .ToList();
        Assert.Empty(servicesWithDbContext);
    }
    [Fact]
    public void DataLayer_ShouldNotReference_ApiLayer()
    {
        var dataTypes = DataAssembly.GetTypes();
        var apiNamespace = "DnDMapBuilder.Api";
        var dataWithApiDeps = dataTypes
            .Where(t => t.GetProperties()
                .Any(p => p.PropertyType.Namespace?.StartsWith(apiNamespace) == true) ||
                   t.GetFields()
                .Any(f => f.FieldType.Namespace?.StartsWith(apiNamespace) == true))
            .ToList();
        Assert.Empty(dataWithApiDeps);
    }
}
internal static class ArchitectureTestExtensions
{
    public static bool IsCompilerGenerated(this Type type)
    {
        return type.GetCustomAttribute<System.Runtime.CompilerServices.CompilerGeneratedAttribute>() != null;
    }
}
</file>

<file path="src/DnDMapBuilder.Aspire.ServiceDefaults/Extensions.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;
namespace Microsoft.Extensions.Hosting;
public static class Extensions
{
    public static IHostApplicationBuilder AddServiceDefaults(this IHostApplicationBuilder builder)
    {
        builder.ConfigureOpenTelemetry();
        builder.AddDefaultHealthChecks();
        builder.Services.AddServiceDiscovery();
        builder.Services.ConfigureHttpClientDefaults(http =>
        {
            http.AddStandardResilienceHandler();
            http.AddServiceDiscovery();
        });
        return builder;
    }
    public static IHostApplicationBuilder ConfigureOpenTelemetry(this IHostApplicationBuilder builder)
    {
        builder.Logging.AddOpenTelemetry(logging =>
        {
            logging.IncludeFormattedMessage = true;
            logging.IncludeScopes = true;
        });
        builder.Services.AddOpenTelemetry()
            .WithMetrics(metrics =>
            {
                metrics.AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation()
                    .AddRuntimeInstrumentation();
            })
            .WithTracing(tracing =>
            {
                tracing.AddAspNetCoreInstrumentation()
                    .AddHttpClientInstrumentation();
            });
        builder.AddOpenTelemetryExporters();
        return builder;
    }
    private static IHostApplicationBuilder AddOpenTelemetryExporters(this IHostApplicationBuilder builder)
    {
        var useOtlpExporter = !string.IsNullOrWhiteSpace(builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"]);
        if (useOtlpExporter)
        {
            builder.Services.AddOpenTelemetry().UseOtlpExporter();
        }
        return builder;
    }
    public static IHostApplicationBuilder AddDefaultHealthChecks(this IHostApplicationBuilder builder)
    {
        builder.Services.AddHealthChecks()
            .AddCheck("self", () => HealthCheckResult.Healthy(), ["live"]);
        return builder;
    }
    public static WebApplication MapDefaultEndpoints(this WebApplication app)
    {
        app.MapHealthChecks("/health");
        app.MapHealthChecks("/alive", new HealthCheckOptions
        {
            Predicate = r => r.Tags.Contains("live")
        });
        return app;
    }
}
</file>

<file path="src/DnDMapBuilder.Contracts/Configuration/OAuthSettings.cs">
namespace DnDMapBuilder.Contracts.Configuration;
public class OAuthSettings
{
    public GoogleSettings Google { get; set; } = new();
    public AppleSettings Apple { get; set; } = new();
    public string RedirectUri { get; set; } = string.Empty;
    public string FrontendRedirectUri { get; set; } = string.Empty;
}
public class GoogleSettings
{
    public string ClientId { get; set; } = string.Empty;
    public string ClientSecret { get; set; } = string.Empty;
}
public class AppleSettings
{
    public string ClientId { get; set; } = string.Empty;
    public string TeamId { get; set; } = string.Empty;
    public string KeyId { get; set; } = string.Empty;
    public string PrivateKey { get; set; } = string.Empty;
}
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/CampaignDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;
public record CampaignDto(
    string Id,
    string Name,
    string Description,
    List<MissionDto> Missions,
    string OwnerId,
    DateTime CreatedAt,
    DateTime UpdatedAt
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/GameMapDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;
public record GameMapDto(
    string Id,
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    List<MapTokenInstanceDto> Tokens,
    string GridColor,
    double GridOpacity,
    string MissionId,
    string? ImageFileId = null,
    string? ImageContentType = null,
    long ImageFileSize = 0
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/MapTokenInstanceDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;
public record MapTokenInstanceDto(
    string InstanceId,
    string TokenId,
    int X,
    int Y
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/MissionDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;
public record MissionDto(
    string Id,
    string Name,
    string Description,
    List<GameMapDto> Maps,
    string CampaignId
);
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/TokenDefinitionDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;
public record TokenDefinitionDto(
    string Id,
    string Name,
    string ImageUrl,
    int Size,
    string Type,
    string UserId,
    string? ImageFileId = null,
    string? ImageContentType = null,
    long ImageFileSize = 0
);
</file>

<file path="src/DnDMapBuilder.Contracts/Pagination/PaginatedRequest.cs">
namespace DnDMapBuilder.Contracts.Pagination;
public class PaginatedRequest
{
    public int PageNumber { get; set; } = 1;
    public int PageSize { get; set; } = 20;
    public void Validate()
    {
        if (PageNumber < 1)
            PageNumber = 1;
        if (PageSize < 1)
            PageSize = 20;
        else if (PageSize > 100)
            PageSize = 100;
    }
    public int GetSkipCount() => (PageNumber - 1) * PageSize;
}
</file>

<file path="src/DnDMapBuilder.Contracts/Pagination/PaginatedResponse.cs">
namespace DnDMapBuilder.Contracts.Pagination;
public class PaginatedResponse<T>
{
    public PaginatedResponse(IEnumerable<T> items, int pageNumber, int pageSize, int totalCount)
    {
        Items = items.ToList();
        PageNumber = pageNumber;
        PageSize = pageSize;
        TotalCount = totalCount;
    }
    public List<T> Items { get; }
    public int PageNumber { get; }
    public int PageSize { get; }
    public int TotalCount { get; }
    public int TotalPages => (TotalCount + PageSize - 1) / PageSize;
    public bool HasNextPage => PageNumber < TotalPages;
    public bool HasPreviousPage => PageNumber > 1;
}
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/ApproveUserRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record ApproveUserRequest(
    string UserId,
    bool Approved
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateCampaignRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record CreateCampaignRequest(
    string Name,
    string Description
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateMapRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record CreateMapRequest(
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    string GridColor,
    double GridOpacity,
    string MissionId
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateMissionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record CreateMissionRequest(
    string Name,
    string Description,
    string CampaignId
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/CreateTokenDefinitionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record CreateTokenDefinitionRequest(
    string Name,
    string ImageUrl,
    int Size,
    string Type
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/ImageUploadResponse.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record ImageUploadResponse(
    string FileId,
    string Url,
    string ContentType,
    long FileSize
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/LoginRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record LoginRequest(
    string Email,
    string Password
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/MapTokenInstanceRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record MapTokenInstanceRequest(
    string TokenId,
    int X,
    int Y
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/OAuthLoginRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record OAuthLoginRequest(
    string Provider,
    string Code,
    string RedirectUri
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/OAuthTokenRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record OAuthTokenRequest(
    string Provider,
    string IdToken
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/RegisterRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record RegisterRequest(
    string Username,
    string Email,
    string Password
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateCampaignRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record UpdateCampaignRequest(
    string Name,
    string Description
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateMapRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record UpdateMapRequest(
    string Name,
    string? ImageUrl,
    int Rows,
    int Cols,
    List<MapTokenInstanceRequest> Tokens,
    string GridColor,
    double GridOpacity
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateMissionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record UpdateMissionRequest(
    string Name,
    string Description
);
</file>

<file path="src/DnDMapBuilder.Contracts/Requests/UpdateTokenDefinitionRequest.cs">
namespace DnDMapBuilder.Contracts.Requests;
public record UpdateTokenDefinitionRequest(
    string Name,
    string ImageUrl,
    int Size,
    string Type
);
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/ApiResponse.cs">
namespace DnDMapBuilder.Contracts.Responses;
public record ApiResponse<T>(
    bool Success,
    T? Data,
    string? Message = null,
    List<string>? Errors = null
);
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/AuthResponse.cs">
namespace DnDMapBuilder.Contracts.Responses;
public record AuthResponse(
    string Token,
    string UserId,
    string Username,
    string Email,
    string Role,
    string Status
);
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/OAuthUrlResponse.cs">
namespace DnDMapBuilder.Contracts.Responses;
public record OAuthUrlResponse(
    string AuthorizationUrl,
    string State
);
</file>

<file path="src/DnDMapBuilder.Contracts/Responses/PaginatedResponse.cs">
namespace DnDMapBuilder.Contracts.Responses;
public record PaginatedResponse<T>(
    List<T> Items,
    int Page,
    int PageSize,
    int TotalCount,
    int TotalPages
);
</file>

<file path="src/DnDMapBuilder.Data/Entities/Campaign.cs">
namespace DnDMapBuilder.Data.Entities;
public class Campaign
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string OwnerId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public User Owner { get; set; } = null!;
    public ICollection<Mission> Missions { get; set; } = new List<Mission>();
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/GameMap.cs">
namespace DnDMapBuilder.Data.Entities;
public class GameMap
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string? ImageUrl { get; set; }
    public string? ImageFileId { get; set; }
    public string? ImageContentType { get; set; }
    public long ImageFileSize { get; set; } = 0;
    public int Rows { get; set; }
    public int Cols { get; set; }
    public string GridColor { get; set; } = "#000000";
    public double GridOpacity { get; set; } = 0.3;
    public string MissionId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public Mission Mission { get; set; } = null!;
    public ICollection<MapTokenInstance> Tokens { get; set; } = new List<MapTokenInstance>();
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/MapTokenInstance.cs">
namespace DnDMapBuilder.Data.Entities;
public class MapTokenInstance
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string TokenId { get; set; } = string.Empty;
    public string MapId { get; set; } = string.Empty;
    public int X { get; set; }
    public int Y { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public TokenDefinition Token { get; set; } = null!;
    public GameMap Map { get; set; } = null!;
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/Mission.cs">
namespace DnDMapBuilder.Data.Entities;
public class Mission
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string CampaignId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public Campaign Campaign { get; set; } = null!;
    public ICollection<GameMap> Maps { get; set; } = new List<GameMap>();
}
</file>

<file path="src/DnDMapBuilder.Data/Entities/TokenDefinition.cs">
namespace DnDMapBuilder.Data.Entities;
public class TokenDefinition
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string ImageUrl { get; set; } = string.Empty;
    public string? ImageFileId { get; set; }
    public string? ImageContentType { get; set; }
    public long ImageFileSize { get; set; } = 0;
    public int Size { get; set; } = 1;
    public string Type { get; set; } = "player";
    public string UserId { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public User User { get; set; } = null!;
    public ICollection<MapTokenInstance> MapTokenInstances { get; set; } = new List<MapTokenInstance>();
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260114100522_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class InitialCreate : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Username = table.Column<string>(type: "nvarchar(100)", maxLength: 100, nullable: false),
                    Email = table.Column<string>(type: "nvarchar(255)", maxLength: 255, nullable: false),
                    PasswordHash = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Role = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    Status = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });
            migrationBuilder.CreateTable(
                name: "Campaigns",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    Description = table.Column<string>(type: "nvarchar(2000)", maxLength: 2000, nullable: false),
                    OwnerId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Campaigns", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Campaigns_Users_OwnerId",
                        column: x => x.OwnerId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "TokenDefinitions",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    ImageUrl = table.Column<string>(type: "nvarchar(1000)", maxLength: 1000, nullable: false),
                    Size = table.Column<int>(type: "int", nullable: false),
                    Type = table.Column<string>(type: "nvarchar(50)", maxLength: 50, nullable: false),
                    UserId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_TokenDefinitions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_TokenDefinitions_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "Missions",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    Description = table.Column<string>(type: "nvarchar(2000)", maxLength: 2000, nullable: false),
                    CampaignId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Missions", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Missions_Campaigns_CampaignId",
                        column: x => x.CampaignId,
                        principalTable: "Campaigns",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "GameMaps",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(200)", maxLength: 200, nullable: false),
                    ImageUrl = table.Column<string>(type: "nvarchar(1000)", maxLength: 1000, nullable: true),
                    Rows = table.Column<int>(type: "int", nullable: false),
                    Cols = table.Column<int>(type: "int", nullable: false),
                    GridColor = table.Column<string>(type: "nvarchar(20)", maxLength: 20, nullable: false),
                    GridOpacity = table.Column<double>(type: "float", nullable: false),
                    MissionId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_GameMaps", x => x.Id);
                    table.ForeignKey(
                        name: "FK_GameMaps_Missions_MissionId",
                        column: x => x.MissionId,
                        principalTable: "Missions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "MapTokenInstances",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    TokenId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    MapId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    X = table.Column<int>(type: "int", nullable: false),
                    Y = table.Column<int>(type: "int", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "datetime2", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_MapTokenInstances", x => x.Id);
                    table.ForeignKey(
                        name: "FK_MapTokenInstances_GameMaps_MapId",
                        column: x => x.MapId,
                        principalTable: "GameMaps",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                        column: x => x.TokenId,
                        principalTable: "TokenDefinitions",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });
            migrationBuilder.InsertData(
                table: "Users",
                columns: new[] { "Id", "CreatedAt", "Email", "PasswordHash", "Role", "Status", "UpdatedAt", "Username" },
                values: new object[] { "admin-seed-id", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin@dndmapbuilder.com", "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S", "admin", "approved", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin" });
            migrationBuilder.CreateIndex(
                name: "IX_Campaigns_OwnerId",
                table: "Campaigns",
                column: "OwnerId");
            migrationBuilder.CreateIndex(
                name: "IX_GameMaps_MissionId",
                table: "GameMaps",
                column: "MissionId");
            migrationBuilder.CreateIndex(
                name: "IX_MapTokenInstances_MapId",
                table: "MapTokenInstances",
                column: "MapId");
            migrationBuilder.CreateIndex(
                name: "IX_MapTokenInstances_TokenId",
                table: "MapTokenInstances",
                column: "TokenId");
            migrationBuilder.CreateIndex(
                name: "IX_Missions_CampaignId",
                table: "Missions",
                column: "CampaignId");
            migrationBuilder.CreateIndex(
                name: "IX_TokenDefinitions_UserId",
                table: "TokenDefinitions",
                column: "UserId");
            migrationBuilder.CreateIndex(
                name: "IX_Users_Email",
                table: "Users",
                column: "Email",
                unique: true);
            migrationBuilder.CreateIndex(
                name: "IX_Users_Username",
                table: "Users",
                column: "Username",
                unique: true);
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "MapTokenInstances");
            migrationBuilder.DropTable(
                name: "GameMaps");
            migrationBuilder.DropTable(
                name: "TokenDefinitions");
            migrationBuilder.DropTable(
                name: "Missions");
            migrationBuilder.DropTable(
                name: "Campaigns");
            migrationBuilder.DropTable(
                name: "Users");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260114100522_InitialCreate.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260114100522_InitialCreate")]
    partial class InitialCreate
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260115221337_PendingModelChanges.cs">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class PendingModelChanges : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260115221337_PendingModelChanges.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260115221337_PendingModelChanges")]
    partial class PendingModelChanges
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116231211_UpdateAdminPasswordHash.cs">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class UpdateAdminPasswordHash : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.UpdateData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id",
                column: "PasswordHash",
                value: "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq");
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.UpdateData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id",
                column: "PasswordHash",
                value: "$2a$11$XxvU8qZ5yP.yxKxQ8zHW7O8qKFdN1LQkGxKvYxGZ.hQvZNzVZY3.S");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116231211_UpdateAdminPasswordHash.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260116231211_UpdateAdminPasswordHash")]
    partial class UpdateAdminPasswordHash
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                    b.HasData(
                        new
                        {
                            Id = "admin-seed-id",
                            CreatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Email = "admin@dndmapbuilder.com",
                            PasswordHash = "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq",
                            Role = "admin",
                            Status = "approved",
                            UpdatedAt = new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc),
                            Username = "admin"
                        });
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116232059_RemoveSeedData.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class RemoveSeedData : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DeleteData(
                table: "Users",
                keyColumn: "Id",
                keyValue: "admin-seed-id");
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.InsertData(
                table: "Users",
                columns: new[] { "Id", "CreatedAt", "Email", "PasswordHash", "Role", "Status", "UpdatedAt", "Username" },
                values: new object[] { "admin-seed-id", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin@dndmapbuilder.com", "$2a$11$X4v3HBSSmstzKiv2vzPypu2WcKMh/e8Wttppq67PBM/5jalYdz2Kq", "admin", "approved", new DateTime(2024, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc), "admin" });
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260116232059_RemoveSeedData.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260116232059_RemoveSeedData")]
    partial class RemoveSeedData
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117102707_AddImageFileStorageMetadata.cs">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class AddImageFileStorageMetadata : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "ImageContentType",
                table: "TokenDefinitions",
                type: "nvarchar(max)",
                nullable: true);
            migrationBuilder.AddColumn<string>(
                name: "ImageFileId",
                table: "TokenDefinitions",
                type: "nvarchar(max)",
                nullable: true);
            migrationBuilder.AddColumn<long>(
                name: "ImageFileSize",
                table: "TokenDefinitions",
                type: "bigint",
                nullable: false,
                defaultValue: 0L);
            migrationBuilder.AddColumn<string>(
                name: "ImageContentType",
                table: "GameMaps",
                type: "nvarchar(max)",
                nullable: true);
            migrationBuilder.AddColumn<string>(
                name: "ImageFileId",
                table: "GameMaps",
                type: "nvarchar(max)",
                nullable: true);
            migrationBuilder.AddColumn<long>(
                name: "ImageFileSize",
                table: "GameMaps",
                type: "bigint",
                nullable: false,
                defaultValue: 0L);
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "ImageContentType",
                table: "TokenDefinitions");
            migrationBuilder.DropColumn(
                name: "ImageFileId",
                table: "TokenDefinitions");
            migrationBuilder.DropColumn(
                name: "ImageFileSize",
                table: "TokenDefinitions");
            migrationBuilder.DropColumn(
                name: "ImageContentType",
                table: "GameMaps");
            migrationBuilder.DropColumn(
                name: "ImageFileId",
                table: "GameMaps");
            migrationBuilder.DropColumn(
                name: "ImageFileSize",
                table: "GameMaps");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117102707_AddImageFileStorageMetadata.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117102707_AddImageFileStorageMetadata")]
    partial class AddImageFileStorageMetadata
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117104633_SaveImageFiles.cs">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class SaveImageFiles : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117104633_SaveImageFiles.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117104633_SaveImageFiles")]
    partial class SaveImageFiles
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117221839_ConfigureCascadeDeletes.cs">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class ConfigureCascadeDeletes : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns");
            migrationBuilder.DropForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances");
            migrationBuilder.AddForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns",
                column: "OwnerId",
                principalTable: "Users",
                principalColumn: "Id",
                onDelete: ReferentialAction.Restrict);
            migrationBuilder.AddForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances",
                column: "TokenId",
                principalTable: "TokenDefinitions",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns");
            migrationBuilder.DropForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances");
            migrationBuilder.AddForeignKey(
                name: "FK_Campaigns_Users_OwnerId",
                table: "Campaigns",
                column: "OwnerId",
                principalTable: "Users",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
            migrationBuilder.AddForeignKey(
                name: "FK_MapTokenInstances_TokenDefinitions_TokenId",
                table: "MapTokenInstances",
                column: "TokenId",
                principalTable: "TokenDefinitions",
                principalColumn: "Id",
                onDelete: ReferentialAction.Restrict);
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117221839_ConfigureCascadeDeletes.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117221839_ConfigureCascadeDeletes")]
    partial class ConfigureCascadeDeletes
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "10.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117222805_FixCascadeDeleteTokenDefinition.cs">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class FixCascadeDeleteTokenDefinition : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260117222805_FixCascadeDeleteTokenDefinition.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260117222805_FixCascadeDeleteTokenDefinition")]
    partial class FixCascadeDeleteTokenDefinition
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "10.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260121201152_AddOAuthUserFields.cs">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    public partial class AddOAuthUserFields : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<bool>(
                name: "EmailVerified",
                table: "Users",
                type: "bit",
                nullable: false,
                defaultValue: false);
            migrationBuilder.AddColumn<string>(
                name: "OAuthProvider",
                table: "Users",
                type: "nvarchar(max)",
                nullable: true);
            migrationBuilder.AddColumn<string>(
                name: "OAuthProviderId",
                table: "Users",
                type: "nvarchar(max)",
                nullable: true);
            migrationBuilder.AddColumn<string>(
                name: "ProfilePictureUrl",
                table: "Users",
                type: "nvarchar(max)",
                nullable: true);
        }
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "EmailVerified",
                table: "Users");
            migrationBuilder.DropColumn(
                name: "OAuthProvider",
                table: "Users");
            migrationBuilder.DropColumn(
                name: "OAuthProviderId",
                table: "Users");
            migrationBuilder.DropColumn(
                name: "ProfilePictureUrl",
                table: "Users");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/20260121201152_AddOAuthUserFields.Designer.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    [Migration("20260121201152_AddOAuthUserFields")]
    partial class AddOAuthUserFields
    {
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "10.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<bool>("EmailVerified")
                        .HasColumnType("bit");
                    b.Property<string>("OAuthProvider")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("OAuthProviderId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ProfilePictureUrl")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IGenericRepository.cs">
namespace DnDMapBuilder.Data.Repositories;
public interface IGenericRepository<T> where T : class
{
    Task<T?> GetByIdAsync(string id, CancellationToken cancellationToken = default);
    Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default);
    Task<T> AddAsync(T entity, CancellationToken cancellationToken = default);
    Task UpdateAsync(T entity, CancellationToken cancellationToken = default);
    Task DeleteAsync(string id, CancellationToken cancellationToken = default);
    Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilderDbContextFactory.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
namespace DnDMapBuilder.Data;
public class DnDMapBuilderDbContextFactory : IDesignTimeDbContextFactory<DnDMapBuilderDbContext>
{
    public DnDMapBuilderDbContext CreateDbContext(string[] args)
    {
        var optionsBuilder = new DbContextOptionsBuilder<DnDMapBuilderDbContext>();
        var connectionString = Environment.GetEnvironmentVariable("DefaultConnection")
            ?? "Server=localhost;Database=DnDMapBuilder;User Id=sa;Password=YourPassword123!;TrustServerCertificate=true;";
        optionsBuilder.UseSqlServer(connectionString);
        return new DnDMapBuilderDbContext(optionsBuilder.Options);
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/CachingConfiguration.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
namespace DnDMapBuilder.Infrastructure.Configuration;
public static class CachingConfiguration
{
    public static IServiceCollection AddResponseCachingConfiguration(this IServiceCollection services)
    {
        services.AddResponseCaching();
        return services;
    }
    public static IMvcBuilder ConfigureCacheProfiles(this IMvcBuilder mvcBuilder)
    {
        mvcBuilder.AddMvcOptions(options =>
        {
            options.CacheProfiles.Add("Default60", new()
            {
                Duration = 60,
                Location = ResponseCacheLocation.Any,
                NoStore = false
            });
            options.CacheProfiles.Add("Long300", new()
            {
                Duration = 300,
                Location = ResponseCacheLocation.Any,
                NoStore = false
            });
            options.CacheProfiles.Add("Short10", new()
            {
                Duration = 10,
                Location = ResponseCacheLocation.Any,
                NoStore = false
            });
            options.CacheProfiles.Add("NoCache", new()
            {
                NoStore = true,
                Location = ResponseCacheLocation.None,
                Duration = 0
            });
        });
        return mvcBuilder;
    }
    public static IApplicationBuilder UseResponseCachingConfiguration(this IApplicationBuilder app)
    {
        return app.UseResponseCaching();
    }
    public static IApplicationBuilder UseCacheControlHeaders(this IApplicationBuilder app)
    {
        return app.Use(async (context, next) =>
        {
            if (context.Request.Method == HttpMethods.Get)
            {
                if (!context.Response.Headers.ContainsKey("Cache-Control"))
                {
                    context.Response.Headers["Cache-Control"] = "public, max-age=60";
                }
            }
            else
            {
                context.Response.Headers["Cache-Control"] = "no-cache, no-store, must-revalidate";
                context.Response.Headers["Pragma"] = "no-cache";
                context.Response.Headers["Expires"] = "0";
            }
            await next();
        });
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/CorsSettings.cs">
namespace DnDMapBuilder.Infrastructure.Configuration;
public class CorsSettings
{
    public const string SectionName = "CorsSettings";
    public string[] AllowedOrigins { get; set; } = Array.Empty<string>();
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/JwtSettings.cs">
namespace DnDMapBuilder.Infrastructure.Configuration;
public class JwtSettings
{
    public const string SectionName = "JwtSettings";
    public string SecretKey { get; set; } = string.Empty;
    public string Issuer { get; set; } = string.Empty;
    public string Audience { get; set; } = string.Empty;
    public int ExpirationMinutes { get; set; } = 1440;
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Configuration/RateLimitConfiguration.cs">
using System.Security.Claims;
using System.Threading.RateLimiting;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.RateLimiting;
using Microsoft.Extensions.DependencyInjection;
namespace DnDMapBuilder.Infrastructure.Configuration;
public static class RateLimitConfiguration
{
    public static IServiceCollection AddRateLimitingConfiguration(this IServiceCollection services)
    {
        services.AddRateLimiter(options =>
        {
            options.AddPolicy("anonymous", httpContext =>
                RateLimitPartition.GetFixedWindowLimiter(
                    partitionKey: httpContext.Connection.RemoteIpAddress?.ToString() ?? "anonymous",
                    factory: _ => new FixedWindowRateLimiterOptions
                    {
                        AutoReplenishment = true,
                        PermitLimit = 100,
                        Window = TimeSpan.FromMinutes(1)
                    }));
            options.AddPolicy("authenticated", httpContext =>
            {
                var userId = httpContext.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "anonymous";
                return RateLimitPartition.GetFixedWindowLimiter(
                    partitionKey: userId,
                    factory: _ => new FixedWindowRateLimiterOptions
                    {
                        AutoReplenishment = true,
                        PermitLimit = 300,
                        Window = TimeSpan.FromMinutes(1)
                    });
            });
            options.AddPolicy("fileUpload", httpContext =>
            {
                var userId = httpContext.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? "anonymous";
                return RateLimitPartition.GetFixedWindowLimiter(
                    partitionKey: $"{userId}-upload",
                    factory: _ => new FixedWindowRateLimiterOptions
                    {
                        AutoReplenishment = true,
                        PermitLimit = 10,
                        Window = TimeSpan.FromMinutes(1)
                    });
            });
            options.OnRejected = async (context, _) =>
            {
                context.HttpContext.Response.StatusCode = StatusCodes.Status429TooManyRequests;
                context.HttpContext.Response.Headers.RetryAfter = "60";
                context.HttpContext.Response.ContentType = "application/json";
                var response = new { success = false, message = "Rate limit exceeded. Please try again later.", retryAfter = 60 };
                await context.HttpContext.Response.WriteAsJsonAsync(response);
            };
        });
        return services;
    }
    public static IApplicationBuilder UseRateLimitingConfiguration(this IApplicationBuilder app)
    {
        return app.UseRateLimiter();
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/HealthChecks/HealthCheckConfiguration.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using System.Text.Json;
namespace DnDMapBuilder.Infrastructure.HealthChecks;
public static class HealthCheckConfiguration
{
    public static IServiceCollection AddHealthChecksConfiguration(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        var builder = services
            .AddHealthChecks()
            .AddSqlServer(
                connectionString ?? throw new InvalidOperationException("DefaultConnection not configured"),
                name: "database",
                failureStatus: HealthStatus.Unhealthy,
                timeout: TimeSpan.FromSeconds(5),
                tags: new[] { "ready", "live" })
            .AddCheck("memory_check", new MemoryHealthCheck(), HealthStatus.Degraded, tags: new[] { "ready" });
        return services;
    }
    public static void MapHealthCheckEndpoints(this WebApplication app)
    {
        app.MapHealthChecks("/health", new HealthCheckOptions
        {
            AllowCachingResponses = false,
            ResponseWriter = WriteHealthCheckResponse
        });
        app.MapHealthChecks("/health/ready", new HealthCheckOptions
        {
            AllowCachingResponses = false,
            ResponseWriter = WriteHealthCheckResponse,
            Predicate = registration => registration.Tags.Contains("ready")
        });
        app.MapHealthChecks("/health/live", new HealthCheckOptions
        {
            AllowCachingResponses = false,
            ResponseWriter = WriteHealthCheckResponse,
            Predicate = registration => registration.Tags.Contains("live")
        });
    }
    private static async Task WriteHealthCheckResponse(
        HttpContext context,
        HealthReport report)
    {
        context.Response.ContentType = "application/json";
        var response = new
        {
            status = report.Status.ToString(),
            timestamp = DateTime.UtcNow,
            duration = report.TotalDuration.TotalMilliseconds,
            checks = report.Entries.Select(kvp => new
            {
                name = kvp.Key,
                status = kvp.Value.Status.ToString(),
                duration = kvp.Value.Duration.TotalMilliseconds,
                description = kvp.Value.Description ?? string.Empty,
                data = kvp.Value.Data.Count > 0 ? kvp.Value.Data : null
            })
        };
        var options = new JsonSerializerOptions { WriteIndented = true };
        await context.Response.WriteAsJsonAsync(response, options);
    }
}
public class MemoryHealthCheck : IHealthCheck
{
    private const long MaxMemoryUsageMb = 512;
    public Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default)
    {
        var totalMemory = GC.GetTotalMemory(false);
        var memoryUsageMb = totalMemory / 1024 / 1024;
        var data = new Dictionary<string, object>
        {
            { "TotalMemoryMB", memoryUsageMb },
            { "MaxMemoryMB", MaxMemoryUsageMb }
        };
        if (memoryUsageMb > MaxMemoryUsageMb)
        {
            return Task.FromResult(
                HealthCheckResult.Degraded(
                    $"Memory usage is {memoryUsageMb}MB which exceeds the threshold of {MaxMemoryUsageMb}MB",
                    data: data));
        }
        return Task.FromResult(
            HealthCheckResult.Healthy(
                $"Memory usage is {memoryUsageMb}MB",
                data: data));
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Logging/LoggingConfiguration.cs">
using Serilog;
using Serilog.Core;
using Serilog.Events;
namespace DnDMapBuilder.Infrastructure.Logging;
public static class LoggingConfiguration
{
    public static Serilog.ILogger ConfigureLogging(string? environment, bool isDevelopment)
    {
        var logLevel = isDevelopment ? LogEventLevel.Debug : LogEventLevel.Information;
        var loggerConfig = new LoggerConfiguration()
            .MinimumLevel.Is(logLevel)
            .Enrich.FromLogContext()
            .Enrich.WithMachineName()
            .Enrich.WithEnvironmentUserName()
            .Enrich.WithThreadId();
        loggerConfig
            .MinimumLevel.Override("Microsoft.EntityFrameworkCore", LogEventLevel.Warning)
            .MinimumLevel.Override("Microsoft.EntityFrameworkCore.Database.Command", LogEventLevel.Warning)
            .MinimumLevel.Override("System", LogEventLevel.Warning)
            .MinimumLevel.Override("Microsoft", LogEventLevel.Warning);
        loggerConfig.WriteTo.Console(
            outputTemplate: "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz}] [{Level:u3}] {Message:lj}{NewLine}{Exception}");
        loggerConfig.WriteTo.File(
            path: "logs/app-.txt",
            rollingInterval: RollingInterval.Day,
            fileSizeLimitBytes: 100 * 1024 * 1024,
            retainedFileCountLimit: 30,
            outputTemplate: "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz}] [{Level:u3}] [{SourceContext}] {Message:lj}{NewLine}{Exception}");
        var seqUrl = Environment.GetEnvironmentVariable("SEQ_SERVER_URL");
        if (!string.IsNullOrEmpty(seqUrl))
        {
            loggerConfig.WriteTo.Seq(seqUrl);
        }
        return loggerConfig.CreateLogger();
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Middleware/RequestResponseLoggingMiddleware.cs">
using System.Diagnostics;
using System.Text;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
namespace DnDMapBuilder.Infrastructure.Middleware;
public class RequestResponseLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestResponseLoggingMiddleware> _logger;
    private readonly HashSet<string> _excludedPaths;
    private const int MaxBodySizeToLog = 4096;
    public RequestResponseLoggingMiddleware(RequestDelegate next, ILogger<RequestResponseLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
        _excludedPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "/health",
            "/health/live",
            "/health/ready"
        };
    }
    public async Task InvokeAsync(HttpContext context)
    {
        if (_excludedPaths.Any(path => context.Request.Path.StartsWithSegments(path)))
        {
            await _next(context);
            return;
        }
        var stopwatch = Stopwatch.StartNew();
        var correlationId = GetOrCreateCorrelationId(context);
        await LogRequestAsync(context, correlationId);
        var originalBodyStream = context.Response.Body;
        using (var responseBody = new MemoryStream())
        {
            context.Response.Body = responseBody;
            try
            {
                await _next(context);
                stopwatch.Stop();
                await LogResponseAsync(context, correlationId, stopwatch.ElapsedMilliseconds);
                await responseBody.CopyToAsync(originalBodyStream);
            }
            finally
            {
                context.Response.Body = originalBodyStream;
            }
        }
    }
    private async Task LogRequestAsync(HttpContext context, string correlationId)
    {
        var request = context.Request;
        var userIdentity = context.User?.Identity?.Name ?? "Anonymous";
        _logger.LogInformation(
            "HTTP Request | CorrelationId: {CorrelationId} | Method: {Method} | Path: {Path} | Query: {Query} | User: {User}",
            correlationId,
            request.Method,
            request.Path,
            request.QueryString.Value,
            userIdentity
        );
        var sensitiveHeaders = new[] { "authorization", "cookie", "x-api-key", "x-token" };
        var headers = request.Headers
            .Where(h => !sensitiveHeaders.Contains(h.Key.ToLower()))
            .ToDictionary(h => h.Key, h => h.Value.ToString());
        if (headers.Any())
        {
            _logger.LogDebug(
                "HTTP Request Headers | CorrelationId: {CorrelationId} | Headers: {@Headers}",
                correlationId,
                headers
            );
        }
        if (context.Request.ContentLength > 0 &&
            (request.Method == HttpMethods.Post ||
             request.Method == HttpMethods.Put ||
             request.Method == HttpMethods.Patch))
        {
            request.EnableBuffering();
            var body = await new StreamReader(request.Body).ReadToEndAsync();
            request.Body.Position = 0;
            if (!string.IsNullOrWhiteSpace(body) && body.Length <= MaxBodySizeToLog)
            {
                _logger.LogDebug(
                    "HTTP Request Body | CorrelationId: {CorrelationId} | Body: {Body}",
                    correlationId,
                    body
                );
            }
            else if (body.Length > MaxBodySizeToLog)
            {
                _logger.LogDebug(
                    "HTTP Request Body | CorrelationId: {CorrelationId} | Body: [Truncated - Size: {Size} bytes]",
                    correlationId,
                    body.Length
                );
            }
        }
    }
    private async Task LogResponseAsync(HttpContext context, string correlationId, long elapsedMilliseconds)
    {
        var response = context.Response;
        _logger.LogInformation(
            "HTTP Response | CorrelationId: {CorrelationId} | StatusCode: {StatusCode} | Duration: {DurationMs}ms",
            correlationId,
            response.StatusCode,
            elapsedMilliseconds
        );
        var responseHeaders = response.Headers
            .ToDictionary(h => h.Key, h => h.Value.ToString());
        if (responseHeaders.Any())
        {
            _logger.LogDebug(
                "HTTP Response Headers | CorrelationId: {CorrelationId} | Headers: {@Headers}",
                correlationId,
                responseHeaders
            );
        }
        if (response.Body.CanSeek)
        {
            response.Body.Seek(0, SeekOrigin.Begin);
            var responseBody = await new StreamReader(response.Body).ReadToEndAsync();
            response.Body.Seek(0, SeekOrigin.Begin);
            if (!string.IsNullOrWhiteSpace(responseBody) && responseBody.Length <= MaxBodySizeToLog)
            {
                if (response.StatusCode >= 400 || response.StatusCode == 201)
                {
                    _logger.LogDebug(
                        "HTTP Response Body | CorrelationId: {CorrelationId} | Body: {Body}",
                        correlationId,
                        responseBody
                    );
                }
            }
        }
    }
    private string GetOrCreateCorrelationId(HttpContext context)
    {
        const string correlationIdHeader = "X-Correlation-ID";
        if (context.Request.Headers.TryGetValue(correlationIdHeader, out var correlationId))
        {
            return correlationId.ToString();
        }
        var newCorrelationId = Guid.NewGuid().ToString();
        context.Request.Headers.Add(correlationIdHeader, newCorrelationId);
        context.Response.Headers.Add(correlationIdHeader, newCorrelationId);
        return newCorrelationId;
    }
}
public static class RequestResponseLoggingMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestResponseLogging(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<RequestResponseLoggingMiddleware>();
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Middleware/SecurityHeadersMiddleware.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
namespace DnDMapBuilder.Infrastructure.Middleware;
public class SecurityHeadersMiddleware
{
    private readonly RequestDelegate _next;
    public SecurityHeadersMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        context.Response.Headers["X-Content-Type-Options"] = "nosniff";
        context.Response.Headers["X-Frame-Options"] = "DENY";
        context.Response.Headers["X-XSS-Protection"] = "1; mode=block";
        context.Response.Headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains; preload";
        context.Response.Headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'";
        context.Response.Headers["Referrer-Policy"] = "strict-origin-when-cross-origin";
        context.Response.Headers["Permissions-Policy"] = "geolocation=(), microphone=(), camera=()";
        await _next(context);
    }
}
public static class SecurityHeadersMiddlewareExtensions
{
    public static IApplicationBuilder UseSecurityHeaders(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<SecurityHeadersMiddleware>();
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Telemetry/ITelemetryService.cs">
using System.Diagnostics;
namespace DnDMapBuilder.Infrastructure.Telemetry;
public interface ITelemetryService
{
    void RecordAuthenticationAttempt(int? userId, bool success, long durationMs);
    void RecordTokenOperation(string operationType, bool success);
    void RecordCampaignOperation(string operationType, int campaignId, long durationMs);
    void RecordMissionOperation(string operationType, int missionId, long durationMs);
    void RecordMapOperation(string operationType, int mapId, long durationMs);
    void RecordTokenInstanceOperation(string operationType, int tokenId, long durationMs);
    void RecordFileUpload(string fileName, long fileSizeBytes, bool success, long durationMs);
    Activity? StartActivity(string activityName);
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Telemetry/TelemetryConfiguration.cs">
using System.Diagnostics;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Instrumentation.AspNetCore;
using OpenTelemetry.Instrumentation.Http;
using OpenTelemetry.Instrumentation.SqlClient;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
namespace DnDMapBuilder.Infrastructure.Telemetry;
public static class TelemetryConfiguration
{
    public static IServiceCollection AddOpenTelemetryTracing(
        this IServiceCollection services,
        IConfiguration configuration,
        bool isDevelopment)
    {
        var otlpEndpoint = configuration["Telemetry:OtlpEndpoint"];
        services.ConfigureOpenTelemetryTracerProvider((sp, builder) =>
        {
            builder
                .AddAspNetCoreInstrumentation(options =>
                {
                    options.RecordException = true;
                    options.EnrichWithHttpRequest = EnrichWithHttpRequest;
                    options.EnrichWithHttpResponse = EnrichWithHttpResponse;
                })
                .AddHttpClientInstrumentation(options =>
                {
                    options.RecordException = true;
                })
                .AddSqlClientInstrumentation(options =>
                {
                    options.RecordException = true;
                })
                .AddSource("DnDMapBuilder.Services")
                .AddSource("DnDMapBuilder.Repositories");
            if (!string.IsNullOrEmpty(otlpEndpoint))
            {
                builder.AddOtlpExporter(options =>
                {
                    options.Endpoint = new Uri(otlpEndpoint);
                    options.Protocol = OtlpExportProtocol.Grpc;
                });
            }
        });
        services.AddSingleton<ITelemetryService, TelemetryService>();
        return services;
    }
    private static void EnrichWithHttpRequest(Activity activity, HttpRequest request)
    {
        activity.SetTag("http.request_content_type", request.ContentType);
        activity.SetTag("http.client_ip", request.HttpContext?.Connection?.RemoteIpAddress?.ToString());
    }
    private static void EnrichWithHttpResponse(Activity activity, HttpResponse response)
    {
        activity.SetTag("http.response_content_type", response.ContentType);
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/Telemetry/TelemetryService.cs">
using System.Diagnostics;
using System.Diagnostics.Metrics;
namespace DnDMapBuilder.Infrastructure.Telemetry;
public class TelemetryService : ITelemetryService
{
    private readonly ActivitySource _activitySource;
    private readonly Meter _authenticationMeter;
    private readonly Meter _campaignMeter;
    private readonly Meter _missionMeter;
    private readonly Meter _mapMeter;
    private readonly Meter _tokenMeter;
    private readonly Meter _fileMeter;
    private readonly Counter<int> _authenticationAttempts;
    private readonly Counter<int> _authenticationSuccesses;
    private readonly Counter<int> _authenticationFailures;
    private readonly Counter<int> _tokenIssued;
    private readonly Counter<int> _tokenRefreshed;
    private readonly Counter<int> _tokenRevoked;
    private readonly Counter<int> _campaignCreated;
    private readonly Counter<int> _campaignUpdated;
    private readonly Counter<int> _campaignDeleted;
    private readonly Histogram<long> _campaignOperationDuration;
    private readonly Counter<int> _missionCreated;
    private readonly Counter<int> _missionUpdated;
    private readonly Counter<int> _missionDeleted;
    private readonly Histogram<long> _missionOperationDuration;
    private readonly Counter<int> _mapCreated;
    private readonly Counter<int> _mapUpdated;
    private readonly Counter<int> _mapDeleted;
    private readonly Histogram<long> _mapOperationDuration;
    private readonly Counter<int> _tokenInstanceCreated;
    private readonly Counter<int> _tokenInstanceUpdated;
    private readonly Counter<int> _tokenInstanceDeleted;
    private readonly Histogram<long> _tokenInstanceOperationDuration;
    private readonly Counter<int> _fileUploadsSuccessful;
    private readonly Counter<int> _fileUploadsFailed;
    private readonly Histogram<long> _fileUploadDuration;
    private readonly Histogram<long> _fileUploadSize;
    public TelemetryService()
    {
        _activitySource = new ActivitySource("DnDMapBuilder.Services");
        _authenticationMeter = new Meter("DnDMapBuilder.Authentication", "1.0.0");
        _campaignMeter = new Meter("DnDMapBuilder.CampaignOperations", "1.0.0");
        _missionMeter = new Meter("DnDMapBuilder.MissionOperations", "1.0.0");
        _mapMeter = new Meter("DnDMapBuilder.MapOperations", "1.0.0");
        _tokenMeter = new Meter("DnDMapBuilder.TokenOperations", "1.0.0");
        _fileMeter = new Meter("DnDMapBuilder.FileOperations", "1.0.0");
        _authenticationAttempts = _authenticationMeter.CreateCounter<int>(
            "authentication.attempts.total",
            description: "Total authentication attempts");
        _authenticationSuccesses = _authenticationMeter.CreateCounter<int>(
            "authentication.successes.total",
            description: "Total successful authentications");
        _authenticationFailures = _authenticationMeter.CreateCounter<int>(
            "authentication.failures.total",
            description: "Total failed authentications");
        _tokenIssued = _tokenMeter.CreateCounter<int>(
            "token.issued.total",
            description: "Total tokens issued");
        _tokenRefreshed = _tokenMeter.CreateCounter<int>(
            "token.refreshed.total",
            description: "Total tokens refreshed");
        _tokenRevoked = _tokenMeter.CreateCounter<int>(
            "token.revoked.total",
            description: "Total tokens revoked");
        _campaignCreated = _campaignMeter.CreateCounter<int>(
            "campaign.created.total",
            description: "Total campaigns created");
        _campaignUpdated = _campaignMeter.CreateCounter<int>(
            "campaign.updated.total",
            description: "Total campaigns updated");
        _campaignDeleted = _campaignMeter.CreateCounter<int>(
            "campaign.deleted.total",
            description: "Total campaigns deleted");
        _campaignOperationDuration = _campaignMeter.CreateHistogram<long>(
            "campaign.operation.duration_ms",
            unit: "ms",
            description: "Duration of campaign operations in milliseconds");
        _missionCreated = _missionMeter.CreateCounter<int>(
            "mission.created.total",
            description: "Total missions created");
        _missionUpdated = _missionMeter.CreateCounter<int>(
            "mission.updated.total",
            description: "Total missions updated");
        _missionDeleted = _missionMeter.CreateCounter<int>(
            "mission.deleted.total",
            description: "Total missions deleted");
        _missionOperationDuration = _missionMeter.CreateHistogram<long>(
            "mission.operation.duration_ms",
            unit: "ms",
            description: "Duration of mission operations in milliseconds");
        _mapCreated = _mapMeter.CreateCounter<int>(
            "map.created.total",
            description: "Total maps created");
        _mapUpdated = _mapMeter.CreateCounter<int>(
            "map.updated.total",
            description: "Total maps updated");
        _mapDeleted = _mapMeter.CreateCounter<int>(
            "map.deleted.total",
            description: "Total maps deleted");
        _mapOperationDuration = _mapMeter.CreateHistogram<long>(
            "map.operation.duration_ms",
            unit: "ms",
            description: "Duration of map operations in milliseconds");
        _tokenInstanceCreated = _tokenMeter.CreateCounter<int>(
            "token_instance.created.total",
            description: "Total token instances created");
        _tokenInstanceUpdated = _tokenMeter.CreateCounter<int>(
            "token_instance.updated.total",
            description: "Total token instances updated");
        _tokenInstanceDeleted = _tokenMeter.CreateCounter<int>(
            "token_instance.deleted.total",
            description: "Total token instances deleted");
        _tokenInstanceOperationDuration = _tokenMeter.CreateHistogram<long>(
            "token_instance.operation.duration_ms",
            unit: "ms",
            description: "Duration of token instance operations in milliseconds");
        _fileUploadsSuccessful = _fileMeter.CreateCounter<int>(
            "file.uploads.successful.total",
            description: "Total successful file uploads");
        _fileUploadsFailed = _fileMeter.CreateCounter<int>(
            "file.uploads.failed.total",
            description: "Total failed file uploads");
        _fileUploadDuration = _fileMeter.CreateHistogram<long>(
            "file.upload.duration_ms",
            unit: "ms",
            description: "Duration of file uploads in milliseconds");
        _fileUploadSize = _fileMeter.CreateHistogram<long>(
            "file.upload.size_bytes",
            unit: "bytes",
            description: "Size of uploaded files in bytes");
    }
    public void RecordAuthenticationAttempt(int? userId, bool success, long durationMs)
    {
        _authenticationAttempts.Add(1);
        if (success && userId.HasValue)
        {
            _authenticationSuccesses.Add(1);
        }
        else
        {
            _authenticationFailures.Add(1);
        }
    }
    public void RecordTokenOperation(string operationType, bool success)
    {
        var countLabel = operationType.ToLowerInvariant() switch
        {
            "issue" => _tokenIssued,
            "refresh" => _tokenRefreshed,
            "revoke" => _tokenRevoked,
            _ => _tokenIssued
        };
        countLabel.Add(1);
    }
    public void RecordCampaignOperation(string operationType, int campaignId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _campaignCreated.Add(1);
                break;
            case "update":
                _campaignUpdated.Add(1);
                break;
            case "delete":
                _campaignDeleted.Add(1);
                break;
        }
        _campaignOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }
    public void RecordMissionOperation(string operationType, int missionId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _missionCreated.Add(1);
                break;
            case "update":
                _missionUpdated.Add(1);
                break;
            case "delete":
                _missionDeleted.Add(1);
                break;
        }
        _missionOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }
    public void RecordMapOperation(string operationType, int mapId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _mapCreated.Add(1);
                break;
            case "update":
                _mapUpdated.Add(1);
                break;
            case "delete":
                _mapDeleted.Add(1);
                break;
        }
        _mapOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }
    public void RecordTokenInstanceOperation(string operationType, int tokenId, long durationMs)
    {
        switch (operationType.ToLowerInvariant())
        {
            case "create":
                _tokenInstanceCreated.Add(1);
                break;
            case "update":
                _tokenInstanceUpdated.Add(1);
                break;
            case "delete":
                _tokenInstanceDeleted.Add(1);
                break;
        }
        _tokenInstanceOperationDuration.Record(durationMs, new KeyValuePair<string, object?>("operation", operationType));
    }
    public void RecordFileUpload(string fileName, long fileSizeBytes, bool success, long durationMs)
    {
        if (success)
        {
            _fileUploadsSuccessful.Add(1);
        }
        else
        {
            _fileUploadsFailed.Add(1);
        }
        _fileUploadDuration.Record(durationMs, new KeyValuePair<string, object?>("file_name", fileName));
        _fileUploadSize.Record(fileSizeBytes, new KeyValuePair<string, object?>("file_name", fileName));
    }
    public Activity? StartActivity(string activityName)
    {
        return _activitySource.StartActivity(activityName);
    }
}
</file>

<file path="src/DnDMapBuilder.IntegrationTests/Controllers/HealthCheckIntegrationTests.cs">
using Xunit;
namespace DnDMapBuilder.IntegrationTests.Controllers;
[Trait("Category", "Integration")]
public class HealthCheckIntegrationTests
{
    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthLive_ShouldReturn200OK()
    {
        await Task.CompletedTask;
    }
    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthReady_ShouldReturn200OK()
    {
        await Task.CompletedTask;
    }
    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task Health_ShouldReturn200OK()
    {
        await Task.CompletedTask;
    }
    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthLive_ShouldReturnContentType_ApplicationJson()
    {
        await Task.CompletedTask;
    }
    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthEndpoint_ShouldIncludeSecurityHeaders()
    {
        await Task.CompletedTask;
    }
    [Fact(Skip = "Requires database connection - run in full integration environment")]
    public async Task HealthEndpoint_ShouldNotRequireAuthentication()
    {
        await Task.CompletedTask;
    }
}
</file>

<file path="src/DnDMapBuilder.IntegrationTests/Data/CascadeDeleteTests.cs">
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Entities;
using FluentAssertions;
using Microsoft.EntityFrameworkCore;
using Xunit;
namespace DnDMapBuilder.IntegrationTests.Data;
public class CascadeDeleteTests : IAsyncLifetime
{
    private DbContextOptions<DnDMapBuilderDbContext> _options = null!;
    private DnDMapBuilderDbContext _dbContext = null!;
    public async Task InitializeAsync()
    {
        _options = new DbContextOptionsBuilder<DnDMapBuilderDbContext>()
            .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
            .Options;
        _dbContext = new DnDMapBuilderDbContext(_options);
        await _dbContext.Database.EnsureCreatedAsync();
    }
    public async Task DisposeAsync()
    {
        await _dbContext.Database.EnsureDeletedAsync();
        await _dbContext.DisposeAsync();
    }
    [Fact]
    public async Task WhenCampaignDeleted_ThenAllMissionsShouldBeDeleted()
    {
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        await _dbContext.SaveChangesAsync();
        var campaignToDelete = await _dbContext.Campaigns.FirstAsync();
        _dbContext.Campaigns.Remove(campaignToDelete);
        await _dbContext.SaveChangesAsync();
        var missionsCount = await _dbContext.Missions.CountAsync();
        missionsCount.Should().Be(0, "All missions should be deleted when campaign is deleted");
    }
    [Fact]
    public async Task WhenMissionDeleted_ThenAllGameMapsShouldBeDeleted()
    {
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };
        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        await _dbContext.SaveChangesAsync();
        var missionToDelete = await _dbContext.Missions.FirstAsync();
        _dbContext.Missions.Remove(missionToDelete);
        await _dbContext.SaveChangesAsync();
        var mapsCount = await _dbContext.GameMaps.CountAsync();
        mapsCount.Should().Be(0, "All game maps should be deleted when mission is deleted");
    }
    [Fact]
    public async Task WhenGameMapDeleted_ThenAllMapTokenInstancesShouldBeDeleted()
    {
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };
        var instance = new MapTokenInstance { TokenId = token.Id, Token = token, MapId = gameMap.Id, Map = gameMap };
        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        _dbContext.TokenDefinitions.Add(token);
        _dbContext.MapTokenInstances.Add(instance);
        await _dbContext.SaveChangesAsync();
        var mapToDelete = await _dbContext.GameMaps.FirstAsync();
        _dbContext.GameMaps.Remove(mapToDelete);
        await _dbContext.SaveChangesAsync();
        var instancesCount = await _dbContext.MapTokenInstances.CountAsync();
        instancesCount.Should().Be(0, "All token instances should be deleted when game map is deleted");
    }
    [Fact]
    public async Task WhenTokenDefinitionDeleted_ThenAllMapTokenInstancesShouldBeDeleted()
    {
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };
        var instance = new MapTokenInstance { TokenId = token.Id, Token = token, MapId = gameMap.Id, Map = gameMap };
        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        _dbContext.TokenDefinitions.Add(token);
        _dbContext.MapTokenInstances.Add(instance);
        await _dbContext.SaveChangesAsync();
        var tokenToDelete = await _dbContext.TokenDefinitions.FirstAsync();
        _dbContext.TokenDefinitions.Remove(tokenToDelete);
        await _dbContext.SaveChangesAsync();
        var instancesCount = await _dbContext.MapTokenInstances.CountAsync();
        instancesCount.Should().Be(0, "All token instances should be deleted when token definition is deleted");
    }
    [Fact]
    public async Task WhenUserDeleted_ThenCampaignsShouldNotBeDeletedByDelete()
    {
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        await _dbContext.SaveChangesAsync();
        var userToDelete = await _dbContext.Users.FirstAsync();
        _dbContext.Users.Remove(userToDelete);
        await _dbContext.SaveChangesAsync();
        var campaignsCount = await _dbContext.Campaigns.CountAsync();
        campaignsCount.Should().Be(1, "Campaign should still exist even though user is deleted (Restrict behavior)");
    }
    [Fact]
    public async Task WhenUserDeleted_ThenTokenDefinitionsShouldBeDeleted()
    {
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };
        _dbContext.Users.Add(user);
        _dbContext.TokenDefinitions.Add(token);
        await _dbContext.SaveChangesAsync();
        var userToDelete = await _dbContext.Users.FirstAsync();
        _dbContext.Users.Remove(userToDelete);
        await _dbContext.SaveChangesAsync();
        var tokensCount = await _dbContext.TokenDefinitions.CountAsync();
        tokensCount.Should().Be(0, "All token definitions should be deleted when user is deleted");
    }
    [Fact]
    public async Task CascadeDelete_MultiLevelHierarchy_ShouldDeleteAll()
    {
        var user = new User { Username = "testuser", Email = "test@example.com" };
        var campaign = new Campaign { Name = "Test Campaign", OwnerId = user.Id, Owner = user };
        var mission = new Mission { Name = "Test Mission", CampaignId = campaign.Id, Campaign = campaign };
        var gameMap = new GameMap { Name = "Test Map", MissionId = mission.Id, Mission = mission };
        var token = new TokenDefinition { Name = "Test Token", UserId = user.Id, User = user };
        var instance = new MapTokenInstance { TokenId = token.Id, Token = token, MapId = gameMap.Id, Map = gameMap };
        _dbContext.Users.Add(user);
        _dbContext.Campaigns.Add(campaign);
        _dbContext.Missions.Add(mission);
        _dbContext.GameMaps.Add(gameMap);
        _dbContext.TokenDefinitions.Add(token);
        _dbContext.MapTokenInstances.Add(instance);
        await _dbContext.SaveChangesAsync();
        var campaignToDelete = await _dbContext.Campaigns.FirstAsync();
        _dbContext.Campaigns.Remove(campaignToDelete);
        await _dbContext.SaveChangesAsync();
        var missionsCount = await _dbContext.Missions.CountAsync();
        var mapsCount = await _dbContext.GameMaps.CountAsync();
        var instancesCount = await _dbContext.MapTokenInstances.CountAsync();
        missionsCount.Should().Be(0, "Missions should be deleted in cascade");
        mapsCount.Should().Be(0, "GameMaps should be deleted in cascade");
        instancesCount.Should().Be(0, "MapTokenInstances should be deleted in cascade");
        var tokensCount = await _dbContext.TokenDefinitions.CountAsync();
        var usersCount = await _dbContext.Users.CountAsync();
        tokensCount.Should().Be(1, "Token definitions should not be affected by campaign deletion");
        usersCount.Should().Be(1, "Users should not be affected by campaign deletion");
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Controllers/AuthControllerOAuthTests.cs">
using Asp.Versioning;
using DnDMapBuilder.Api.Controllers;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
using FluentAssertions;
using Microsoft.AspNetCore.Mvc;
using NSubstitute;
using Xunit;
namespace DnDMapBuilder.UnitTests.Controllers;
public class AuthControllerOAuthTests
{
    private readonly IAuthService _authService;
    private readonly IUserManagementService _userManagementService;
    private readonly IOAuthService _oAuthService;
    private readonly AuthController _sut;
    public AuthControllerOAuthTests()
    {
        _authService = Substitute.For<IAuthService>();
        _userManagementService = Substitute.For<IUserManagementService>();
        _oAuthService = Substitute.For<IOAuthService>();
        _sut = new AuthController(_authService, _userManagementService, _oAuthService);
    }
    #region GetOAuthUrl Tests
    [Fact]
    public async Task GetOAuthUrl_WithValidGoogleProvider_ReturnsOkWithAuthorizationUrl()
    {
        const string provider = "google";
        const string redirectUri = "https://localhost:3000/callback";
        var expectedResponse = new OAuthUrlResponse(
            "https://accounts.google.com/o/oauth2/v2/auth?...",
            "test-state-123"
        );
        _oAuthService.GetAuthorizationUrlAsync(provider, redirectUri)
            .Returns(expectedResponse);
        var result = await _sut.GetOAuthUrl(provider, redirectUri);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        okResult!.StatusCode.Should().Be(200);
        var apiResponse = okResult.Value as ApiResponse<OAuthUrlResponse>;
        apiResponse.Should().NotBeNull();
        apiResponse!.Success.Should().BeTrue();
        apiResponse.Data.Should().NotBeNull();
        apiResponse.Data!.AuthorizationUrl.Should().Contain("accounts.google.com");
    }
    [Fact]
    public async Task GetOAuthUrl_WithInvalidProvider_ReturnsBadRequest()
    {
        const string provider = "github";
        const string redirectUri = "https://localhost:3000/callback";
        var exceptionMessage = "Unsupported OAuth provider: github";
        _oAuthService.GetAuthorizationUrlAsync(provider, redirectUri)
            .Returns(Task.FromException<OAuthUrlResponse>(new ArgumentException(exceptionMessage)));
        var result = await _sut.GetOAuthUrl(provider, redirectUri);
        var badRequestResult = result.Result as BadRequestObjectResult;
        badRequestResult.Should().NotBeNull();
        badRequestResult!.StatusCode.Should().Be(400);
        var apiResponse = badRequestResult.Value as ApiResponse<OAuthUrlResponse>;
        apiResponse.Should().NotBeNull();
        apiResponse!.Success.Should().BeFalse();
        apiResponse.Message.Should().Contain("Unsupported OAuth provider");
    }
    [Fact]
    public async Task GetOAuthUrl_WithOAuthServiceException_ReturnsBadRequest()
    {
        const string provider = "invalid";
        const string redirectUri = "https://localhost:3000/callback";
        _oAuthService.GetAuthorizationUrlAsync(provider, redirectUri)
            .Returns(Task.FromException<OAuthUrlResponse>(new ArgumentException("Invalid provider")));
        var result = await _sut.GetOAuthUrl(provider, redirectUri);
        var badRequestResult = result.Result as BadRequestObjectResult;
        badRequestResult.Should().NotBeNull();
        badRequestResult!.StatusCode.Should().Be(400);
    }
    #endregion
    #region OAuthCallback Tests
    [Fact]
    public async Task OAuthCallback_WithValidGoogleCode_ReturnsOkWithAuthResponse()
    {
        var request = new OAuthLoginRequest("google", "auth_code_123", "https://localhost:3000/callback");
        var expectedAuthResponse = new AuthResponse(
            "jwt_token_123",
            "user_id_123",
            "testuser",
            "user@example.com",
            "user",
            "approved"
        );
        _oAuthService.HandleOAuthCallbackAsync(request, Arg.Any<CancellationToken>())
            .Returns(expectedAuthResponse);
        var result = await _sut.OAuthCallback(request, CancellationToken.None);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        okResult!.StatusCode.Should().Be(200);
        var apiResponse = okResult.Value as ApiResponse<AuthResponse>;
        apiResponse.Should().NotBeNull();
        apiResponse!.Success.Should().BeTrue();
        apiResponse.Data.Should().NotBeNull();
        apiResponse.Data!.Token.Should().Be("jwt_token_123");
        apiResponse.Data.Email.Should().Be("user@example.com");
    }
    [Fact]
    public async Task OAuthCallback_WithValidAppleCode_ReturnsOkWithAuthResponse()
    {
        var request = new OAuthLoginRequest("apple", "auth_code_456", "https://localhost:3000/callback");
        var expectedAuthResponse = new AuthResponse(
            "jwt_token_456",
            "user_id_456",
            "appleuser",
            "apple@example.com",
            "user",
            "approved"
        );
        _oAuthService.HandleOAuthCallbackAsync(request, Arg.Any<CancellationToken>())
            .Returns(expectedAuthResponse);
        var result = await _sut.OAuthCallback(request, CancellationToken.None);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        okResult!.StatusCode.Should().Be(200);
        var apiResponse = okResult.Value as ApiResponse<AuthResponse>;
        apiResponse!.Success.Should().BeTrue();
        apiResponse.Data!.Email.Should().Be("apple@example.com");
    }
    [Fact]
    public async Task OAuthCallback_WithInvalidCode_ReturnsUnauthorized()
    {
        var request = new OAuthLoginRequest("google", "invalid_code", "https://localhost:3000/callback");
        _oAuthService.HandleOAuthCallbackAsync(request, Arg.Any<CancellationToken>())
            .Returns((AuthResponse?)null);
        var result = await _sut.OAuthCallback(request, CancellationToken.None);
        var unauthorizedResult = result.Result as UnauthorizedObjectResult;
        unauthorizedResult.Should().NotBeNull();
        unauthorizedResult!.StatusCode.Should().Be(401);
        var apiResponse = unauthorizedResult.Value as ApiResponse<AuthResponse>;
        apiResponse.Should().NotBeNull();
        apiResponse!.Success.Should().BeFalse();
        apiResponse.Message.Should().Contain("OAuth authentication failed");
    }
    [Fact]
    public async Task OAuthCallback_WithUnsupportedProvider_ReturnsBadRequest()
    {
        var request = new OAuthLoginRequest("facebook", "code", "https://localhost:3000/callback");
        _oAuthService.HandleOAuthCallbackAsync(request, Arg.Any<CancellationToken>())
            .Returns(Task.FromException<AuthResponse?>(new ArgumentException("Unsupported OAuth provider: facebook")));
        var result = await _sut.OAuthCallback(request, CancellationToken.None);
        var badRequestResult = result.Result as BadRequestObjectResult;
        badRequestResult.Should().NotBeNull();
        badRequestResult!.StatusCode.Should().Be(400);
        var apiResponse = badRequestResult.Value as ApiResponse<AuthResponse>;
        apiResponse!.Success.Should().BeFalse();
    }
    [Fact]
    public async Task OAuthCallback_WithOAuthServiceException_ReturnsBadRequest()
    {
        var request = new OAuthLoginRequest("google", "code", "https://localhost:3000/callback");
        _oAuthService.HandleOAuthCallbackAsync(request, Arg.Any<CancellationToken>())
            .Returns(Task.FromException<AuthResponse?>(new ArgumentException("OAuth service error")));
        var result = await _sut.OAuthCallback(request, CancellationToken.None);
        var badRequestResult = result.Result as BadRequestObjectResult;
        badRequestResult.Should().NotBeNull();
        badRequestResult!.StatusCode.Should().Be(400);
    }
    #endregion
    #region OAuthToken Tests
    [Fact]
    public async Task OAuthToken_WithValidGoogleIdToken_ReturnsOkWithAuthResponse()
    {
        var request = new OAuthTokenRequest("google", "id_token_123");
        var expectedAuthResponse = new AuthResponse(
            "jwt_token_123",
            "user_id_123",
            "testuser",
            "user@example.com",
            "user",
            "approved"
        );
        _oAuthService.ValidateIdTokenAsync(request, Arg.Any<CancellationToken>())
            .Returns(expectedAuthResponse);
        var result = await _sut.OAuthToken(request, CancellationToken.None);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        okResult!.StatusCode.Should().Be(200);
        var apiResponse = okResult.Value as ApiResponse<AuthResponse>;
        apiResponse.Should().NotBeNull();
        apiResponse!.Success.Should().BeTrue();
        apiResponse.Data.Should().NotBeNull();
        apiResponse.Data!.Token.Should().Be("jwt_token_123");
        apiResponse.Message.Should().Contain("OAuth authentication successful");
    }
    [Fact]
    public async Task OAuthToken_WithValidAppleIdToken_ReturnsOkWithAuthResponse()
    {
        var request = new OAuthTokenRequest("apple", "id_token_456");
        var expectedAuthResponse = new AuthResponse(
            "jwt_token_456",
            "user_id_456",
            "appleuser",
            "apple@example.com",
            "user",
            "approved"
        );
        _oAuthService.ValidateIdTokenAsync(request, Arg.Any<CancellationToken>())
            .Returns(expectedAuthResponse);
        var result = await _sut.OAuthToken(request, CancellationToken.None);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        okResult!.StatusCode.Should().Be(200);
        var apiResponse = okResult.Value as ApiResponse<AuthResponse>;
        apiResponse!.Success.Should().BeTrue();
        apiResponse.Data!.Email.Should().Be("apple@example.com");
    }
    [Fact]
    public async Task OAuthToken_WithInvalidToken_ReturnsUnauthorized()
    {
        var request = new OAuthTokenRequest("google", "invalid_token");
        _oAuthService.ValidateIdTokenAsync(request, Arg.Any<CancellationToken>())
            .Returns((AuthResponse?)null);
        var result = await _sut.OAuthToken(request, CancellationToken.None);
        var unauthorizedResult = result.Result as UnauthorizedObjectResult;
        unauthorizedResult.Should().NotBeNull();
        unauthorizedResult!.StatusCode.Should().Be(401);
        var apiResponse = unauthorizedResult.Value as ApiResponse<AuthResponse>;
        apiResponse.Should().NotBeNull();
        apiResponse!.Success.Should().BeFalse();
        apiResponse.Message.Should().Contain("OAuth token validation failed");
    }
    [Fact]
    public async Task OAuthToken_WithExpiredToken_ReturnsUnauthorized()
    {
        var request = new OAuthTokenRequest("google", "expired_token");
        _oAuthService.ValidateIdTokenAsync(request, Arg.Any<CancellationToken>())
            .Returns((AuthResponse?)null);
        var result = await _sut.OAuthToken(request, CancellationToken.None);
        var unauthorizedResult = result.Result as UnauthorizedObjectResult;
        unauthorizedResult.Should().NotBeNull();
    }
    [Fact]
    public async Task OAuthToken_WithUnsupportedProvider_ReturnsBadRequest()
    {
        var request = new OAuthTokenRequest("linkedin", "token");
        _oAuthService.ValidateIdTokenAsync(request, Arg.Any<CancellationToken>())
            .Returns(Task.FromException<AuthResponse?>(new ArgumentException("Unsupported OAuth provider: linkedin")));
        var result = await _sut.OAuthToken(request, CancellationToken.None);
        var badRequestResult = result.Result as BadRequestObjectResult;
        badRequestResult.Should().NotBeNull();
        badRequestResult!.StatusCode.Should().Be(400);
    }
    [Fact]
    public async Task OAuthToken_WithOAuthServiceException_ReturnsBadRequest()
    {
        var request = new OAuthTokenRequest("google", "token");
        _oAuthService.ValidateIdTokenAsync(request, Arg.Any<CancellationToken>())
            .Returns(Task.FromException<AuthResponse?>(new ArgumentException("Token validation error")));
        var result = await _sut.OAuthToken(request, CancellationToken.None);
        var badRequestResult = result.Result as BadRequestObjectResult;
        badRequestResult.Should().NotBeNull();
    }
    #endregion
    #region Edge Cases
    [Fact]
    public async Task OAuthCallback_CancellationTokenIsPassedCorrectly()
    {
        var request = new OAuthLoginRequest("google", "code", "https://localhost:3000/callback");
        var cancellationToken = new CancellationToken();
        var expectedAuthResponse = new AuthResponse(
            "jwt_token_123",
            "user_id_123",
            "testuser",
            "user@example.com",
            "user",
            "approved"
        );
        _oAuthService.HandleOAuthCallbackAsync(request, cancellationToken)
            .Returns(expectedAuthResponse);
        var result = await _sut.OAuthCallback(request, cancellationToken);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        await _oAuthService.Received(1).HandleOAuthCallbackAsync(request, cancellationToken);
    }
    [Fact]
    public async Task OAuthToken_CancellationTokenIsPassedCorrectly()
    {
        var request = new OAuthTokenRequest("google", "token");
        var cancellationToken = new CancellationToken();
        var expectedAuthResponse = new AuthResponse(
            "jwt_token_123",
            "user_id_123",
            "testuser",
            "user@example.com",
            "user",
            "approved"
        );
        _oAuthService.ValidateIdTokenAsync(request, cancellationToken)
            .Returns(expectedAuthResponse);
        var result = await _sut.OAuthToken(request, cancellationToken);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        await _oAuthService.Received(1).ValidateIdTokenAsync(request, cancellationToken);
    }
    [Fact]
    public async Task GetOAuthUrl_ProviderNormalizationWorks()
    {
        const string provider = "GOOGLE";
        const string redirectUri = "https://localhost:3000/callback";
        var expectedResponse = new OAuthUrlResponse(
            "https://accounts.google.com/o/oauth2/v2/auth?...",
            "test-state-123"
        );
        _oAuthService.GetAuthorizationUrlAsync(Arg.Any<string>(), redirectUri)
            .Returns(expectedResponse);
        var result = await _sut.GetOAuthUrl(provider, redirectUri);
        var okResult = result.Result as OkObjectResult;
        okResult.Should().NotBeNull();
        await _oAuthService.Received(1).GetAuthorizationUrlAsync(Arg.Any<string>(), redirectUri);
    }
    #endregion
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Entities/EntityTests.cs">
using DnDMapBuilder.Data.Entities;
using FluentAssertions;
using Xunit;
namespace DnDMapBuilder.UnitTests.Entities;
public class UserEntityTests
{
    [Fact]
    public void User_Initialization_ShouldSetDefaults()
    {
        var user = new User();
        user.Id.Should().NotBeNullOrEmpty();
        user.Username.Should().Be(string.Empty);
        user.Email.Should().Be(string.Empty);
        user.PasswordHash.Should().Be(string.Empty);
        user.Role.Should().Be("user");
        user.Status.Should().Be("pending");
        user.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        user.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        user.Campaigns.Should().BeEmpty();
        user.TokenDefinitions.Should().BeEmpty();
    }
    [Fact]
    public void User_ShouldHaveUniqueIds()
    {
        var user1 = new User();
        var user2 = new User();
        user1.Id.Should().NotBe(user2.Id);
    }
}
public class CampaignEntityTests
{
    [Fact]
    public void Campaign_Initialization_ShouldSetDefaults()
    {
        var campaign = new Campaign();
        campaign.Id.Should().NotBeNullOrEmpty();
        campaign.Name.Should().Be(string.Empty);
        campaign.Description.Should().Be(string.Empty);
        campaign.OwnerId.Should().Be(string.Empty);
        campaign.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        campaign.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        campaign.Missions.Should().BeEmpty();
    }
    [Fact]
    public void Campaign_WithProperties_ShouldHoldValues()
    {
        var ownerId = "user123";
        var name = "Dragon Quest";
        var description = "A grand adventure";
        var campaign = new Campaign
        {
            OwnerId = ownerId,
            Name = name,
            Description = description
        };
        campaign.OwnerId.Should().Be(ownerId);
        campaign.Name.Should().Be(name);
        campaign.Description.Should().Be(description);
    }
}
public class MissionEntityTests
{
    [Fact]
    public void Mission_Initialization_ShouldSetDefaults()
    {
        var mission = new Mission();
        mission.Id.Should().NotBeNullOrEmpty();
        mission.Name.Should().Be(string.Empty);
        mission.Description.Should().Be(string.Empty);
        mission.CampaignId.Should().Be(string.Empty);
        mission.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        mission.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        mission.Maps.Should().BeEmpty();
    }
}
public class GameMapEntityTests
{
    [Fact]
    public void GameMap_Initialization_ShouldSetDefaults()
    {
        var map = new GameMap();
        map.Id.Should().NotBeNullOrEmpty();
        map.Name.Should().Be(string.Empty);
        map.ImageUrl.Should().BeNull();
        map.GridColor.Should().Be("#000000");
        map.GridOpacity.Should().Be(0.3);
        map.ImageFileSize.Should().Be(0);
        map.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        map.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        map.Tokens.Should().BeEmpty();
    }
    [Fact]
    public void GameMap_WithProperties_ShouldHoldValues()
    {
        var name = "Tavern";
        var rows = 10;
        var cols = 15;
        var map = new GameMap
        {
            Name = name,
            Rows = rows,
            Cols = cols
        };
        map.Name.Should().Be(name);
        map.Rows.Should().Be(rows);
        map.Cols.Should().Be(cols);
    }
}
public class TokenDefinitionEntityTests
{
    [Fact]
    public void TokenDefinition_Initialization_ShouldSetDefaults()
    {
        var token = new TokenDefinition();
        token.Id.Should().NotBeNullOrEmpty();
        token.Name.Should().Be(string.Empty);
        token.ImageUrl.Should().Be(string.Empty);
        token.Size.Should().Be(1);
        token.Type.Should().Be("player");
        token.UserId.Should().Be(string.Empty);
        token.ImageFileSize.Should().Be(0);
        token.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        token.UpdatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
        token.MapTokenInstances.Should().BeEmpty();
    }
    [Fact]
    public void TokenDefinition_WithProperties_ShouldHoldValues()
    {
        var name = "Knight";
        var type = "player";
        var size = 2;
        var token = new TokenDefinition
        {
            Name = name,
            Type = type,
            Size = size
        };
        token.Name.Should().Be(name);
        token.Type.Should().Be(type);
        token.Size.Should().Be(size);
    }
}
public class MapTokenInstanceEntityTests
{
    [Fact]
    public void MapTokenInstance_Initialization_ShouldSetDefaults()
    {
        var instance = new MapTokenInstance();
        instance.Id.Should().NotBeNullOrEmpty();
        instance.TokenId.Should().Be(string.Empty);
        instance.MapId.Should().Be(string.Empty);
        instance.X.Should().Be(0);
        instance.Y.Should().Be(0);
        instance.CreatedAt.Should().BeCloseTo(DateTime.UtcNow, precision: TimeSpan.FromSeconds(1));
    }
    [Fact]
    public void MapTokenInstance_WithPosition_ShouldHoldValues()
    {
        const int x = 5;
        const int y = 10;
        var tokenId = "token123";
        var mapId = "map123";
        var instance = new MapTokenInstance
        {
            X = x,
            Y = y,
            TokenId = tokenId,
            MapId = mapId
        };
        instance.X.Should().Be(x);
        instance.Y.Should().Be(y);
        instance.TokenId.Should().Be(tokenId);
        instance.MapId.Should().Be(mapId);
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Infrastructure/HealthChecks/HealthCheckTests.cs">
using DnDMapBuilder.Infrastructure.HealthChecks;
using FluentAssertions;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Xunit;
namespace DnDMapBuilder.UnitTests.Infrastructure.HealthChecks;
public class MemoryHealthCheckTests
{
    private readonly MemoryHealthCheck _healthCheck;
    public MemoryHealthCheckTests()
    {
        _healthCheck = new MemoryHealthCheck();
    }
    [Fact]
    public async Task CheckHealthAsync_WithValidMemory_ReturnsHealthy()
    {
        var result = await _healthCheck.CheckHealthAsync(new HealthCheckContext());
        result.Status.Should().Be(HealthStatus.Healthy);
        result.Description.Should().Contain("Memory usage is");
        result.Data.Should().ContainKey("TotalMemoryMB");
        result.Data.Should().ContainKey("MaxMemoryMB");
    }
    [Fact]
    public async Task CheckHealthAsync_WithValidMemory_IncludesMemoryData()
    {
        var result = await _healthCheck.CheckHealthAsync(new HealthCheckContext());
        result.Data.Should().NotBeEmpty();
        result.Data["TotalMemoryMB"].Should().NotBeNull();
        result.Data["MaxMemoryMB"].Should().Be(512);
    }
    [Fact]
    public async Task CheckHealthAsync_WithCancellationToken_Completes()
    {
        using var cts = new CancellationTokenSource();
        var result = await _healthCheck.CheckHealthAsync(
            new HealthCheckContext(),
            cts.Token);
        result.Should().NotBeNull();
        result.Status.Should().BeOneOf(HealthStatus.Healthy, HealthStatus.Degraded);
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Infrastructure/Telemetry/TelemetryServiceTests.cs">
using DnDMapBuilder.Infrastructure.Telemetry;
using FluentAssertions;
using Xunit;
namespace DnDMapBuilder.UnitTests.Infrastructure.Telemetry;
public class TelemetryServiceTests
{
    private readonly TelemetryService _telemetryService;
    public TelemetryServiceTests()
    {
        _telemetryService = new TelemetryService();
    }
    [Fact]
    public void RecordAuthenticationAttempt_WithSuccessfulAuth_ShouldRecord()
    {
        var userId = 123;
        var success = true;
        var durationMs = 150L;
        _telemetryService.RecordAuthenticationAttempt(userId, success, durationMs);
    }
    [Fact]
    public void RecordAuthenticationAttempt_WithFailedAuth_ShouldRecord()
    {
        const long durationMs = 100L;
        _telemetryService.RecordAuthenticationAttempt(null, false, durationMs);
    }
    [Theory]
    [InlineData("issue")]
    [InlineData("refresh")]
    [InlineData("revoke")]
    public void RecordTokenOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        _telemetryService.RecordTokenOperation(operationType, true);
    }
    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordCampaignOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        const int campaignId = 1;
        const long durationMs = 200L;
        _telemetryService.RecordCampaignOperation(operationType, campaignId, durationMs);
    }
    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordMissionOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        const int missionId = 1;
        const long durationMs = 200L;
        _telemetryService.RecordMissionOperation(operationType, missionId, durationMs);
    }
    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordMapOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        const int mapId = 1;
        const long durationMs = 200L;
        _telemetryService.RecordMapOperation(operationType, mapId, durationMs);
    }
    [Theory]
    [InlineData("create")]
    [InlineData("update")]
    [InlineData("delete")]
    public void RecordTokenInstanceOperation_WithValidOperationType_ShouldRecord(string operationType)
    {
        const int tokenId = 1;
        const long durationMs = 150L;
        _telemetryService.RecordTokenInstanceOperation(operationType, tokenId, durationMs);
    }
    [Fact]
    public void RecordFileUpload_WithSuccessfulUpload_ShouldRecord()
    {
        const string fileName = "test.png";
        const long fileSizeBytes = 1024 * 100;
        const bool success = true;
        const long durationMs = 500L;
        _telemetryService.RecordFileUpload(fileName, fileSizeBytes, success, durationMs);
    }
    [Fact]
    public void RecordFileUpload_WithFailedUpload_ShouldRecord()
    {
        const string fileName = "test.png";
        const long fileSizeBytes = 0;
        const bool success = false;
        const long durationMs = 100L;
        _telemetryService.RecordFileUpload(fileName, fileSizeBytes, success, durationMs);
    }
    [Fact]
    public void StartActivity_WithValidActivityName_ShouldReturnActivityOrNull()
    {
        var activity = _telemetryService.StartActivity("test_activity");
        if (activity != null)
        {
            activity.DisplayName.Should().Be("test_activity");
            activity.Dispose();
        }
    }
    [Fact]
    public void RecordAuthenticationAttempt_WithMultipleAttempts_ShouldRecordAll()
    {
        for (int i = 0; i < 5; i++)
        {
            _telemetryService.RecordAuthenticationAttempt(null, false, 100L);
        }
    }
    [Fact]
    public void RecordCampaignOperation_WithMixedOperations_ShouldRecord()
    {
        _telemetryService.RecordCampaignOperation("create", 1, 100L);
        _telemetryService.RecordCampaignOperation("update", 1, 150L);
        _telemetryService.RecordCampaignOperation("delete", 1, 200L);
    }
    [Fact]
    public void RecordTokenOperation_WithCaseInsensitivity_ShouldRecord()
    {
        _telemetryService.RecordTokenOperation("ISSUE", true);
        _telemetryService.RecordTokenOperation("Refresh", true);
        _telemetryService.RecordTokenOperation("REVOKE", false);
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Infrastructure/CachingConfigurationTests.cs">
using FluentAssertions;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Xunit;
using DnDMapBuilder.Infrastructure.Configuration;
namespace DnDMapBuilder.UnitTests.Infrastructure;
public class CachingConfigurationTests
{
    [Fact]
    public void AddResponseCachingConfiguration_ShouldReturnServiceCollection()
    {
        var services = new ServiceCollection();
        var result = services.AddResponseCachingConfiguration();
        result.Should().NotBeNull();
        result.Should().BeSameAs(services);
    }
    [Fact]
    public void ConfigureCacheProfiles_ShouldAddAllFourCacheProfiles()
    {
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();
        options.Value.CacheProfiles.Should().HaveCount(4);
        options.Value.CacheProfiles.Should().ContainKey("Default60");
        options.Value.CacheProfiles.Should().ContainKey("Long300");
        options.Value.CacheProfiles.Should().ContainKey("Short10");
        options.Value.CacheProfiles.Should().ContainKey("NoCache");
    }
    [Fact]
    public void CacheProfile_Default60_ShouldHave60SecondsExpiration()
    {
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();
        var profile = options.Value.CacheProfiles["Default60"];
        profile.Duration.Should().Be(60);
        profile.NoStore.Should().BeFalse();
        profile.Location.Should().Be(ResponseCacheLocation.Any);
    }
    [Fact]
    public void CacheProfile_Long300_ShouldHave300SecondsExpiration()
    {
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();
        var profile = options.Value.CacheProfiles["Long300"];
        profile.Duration.Should().Be(300);
        profile.NoStore.Should().BeFalse();
        profile.Location.Should().Be(ResponseCacheLocation.Any);
    }
    [Fact]
    public void CacheProfile_Short10_ShouldHave10SecondsExpiration()
    {
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();
        var profile = options.Value.CacheProfiles["Short10"];
        profile.Duration.Should().Be(10);
        profile.NoStore.Should().BeFalse();
        profile.Location.Should().Be(ResponseCacheLocation.Any);
    }
    [Fact]
    public void CacheProfile_NoCache_ShouldDisableCaching()
    {
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();
        mvcBuilder.ConfigureCacheProfiles();
        var serviceProvider = services.BuildServiceProvider();
        var options = serviceProvider.GetRequiredService<IOptions<MvcOptions>>();
        var profile = options.Value.CacheProfiles["NoCache"];
        profile.NoStore.Should().BeTrue();
        profile.Duration.Should().Be(0);
        profile.Location.Should().Be(ResponseCacheLocation.None);
    }
    [Fact]
    public void ConfigureCacheProfiles_ShouldReturnMvcBuilder()
    {
        var services = new ServiceCollection();
        var mvcBuilder = services.AddControllers();
        var result = mvcBuilder.ConfigureCacheProfiles();
        result.Should().NotBeNull();
        result.Should().Be(mvcBuilder);
    }
    [Fact]
    public void UseResponseCachingConfiguration_ShouldReturnApplicationBuilder()
    {
        var app = WebApplication.CreateBuilder().Build();
        var result = app.UseResponseCachingConfiguration();
        result.Should().NotBeNull();
        result.Should().Be(app);
    }
    [Fact]
    public void UseCacheControlHeaders_ShouldSetProperHeadersForGetRequests()
    {
        var context = new DefaultHttpContext();
        context.Request.Method = HttpMethods.Get;
        var middleware = async (HttpContext ctx) => { };
        var app = WebApplication.CreateBuilder().Build();
        app.UseCacheControlHeaders();
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/AuthServiceTests.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
using FluentAssertions;
using Moq;
using Xunit;
namespace DnDMapBuilder.UnitTests.Services;
public class AuthServiceTests
{
    private readonly Mock<IUserRepository> _mockUserRepository;
    private readonly Mock<IJwtService> _mockJwtService;
    private readonly Mock<IPasswordService> _mockPasswordService;
    private readonly AuthService _authService;
    public AuthServiceTests()
    {
        _mockUserRepository = new Mock<IUserRepository>();
        _mockJwtService = new Mock<IJwtService>();
        _mockPasswordService = new Mock<IPasswordService>();
        _authService = new AuthService(_mockUserRepository.Object, _mockJwtService.Object, _mockPasswordService.Object);
    }
    [Fact]
    public async Task LoginAsync_WithValidCredentials_ReturnsAuthResponse()
    {
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };
        var expectedToken = "jwt_token_here";
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        _mockJwtService.Setup(j => j.GenerateToken(user.Id, user.Email, user.Role))
            .Returns(expectedToken);
        var result = await _authService.LoginAsync(loginRequest);
        result.Should().NotBeNull();
        result.Token.Should().Be(expectedToken);
        result.UserId.Should().Be(user.Id);
        result.Email.Should().Be(user.Email);
        result.Username.Should().Be(user.Username);
        result.Role.Should().Be(user.Role);
        result.Status.Should().Be(user.Status);
    }
    [Fact]
    public async Task LoginAsync_WithNonExistentUser_ReturnsNull()
    {
        var loginRequest = new LoginRequest("nonexistent@example.com", "password123");
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync((User)null);
        var result = await _authService.LoginAsync(loginRequest);
        result.Should().BeNull();
    }
    [Fact]
    public async Task LoginAsync_WithInvalidPassword_ReturnsNull()
    {
        var loginRequest = new LoginRequest("test@example.com", "wrongpassword");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(false);
        var result = await _authService.LoginAsync(loginRequest);
        result.Should().BeNull();
    }
    [Fact]
    public async Task LoginAsync_WithPendingUserAndUserRole_ReturnsNull()
    {
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "pending"
        };
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        var result = await _authService.LoginAsync(loginRequest);
        result.Should().BeNull();
    }
    [Fact]
    public async Task LoginAsync_WithRejectedUserAndUserRole_ReturnsNull()
    {
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "rejected"
        };
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        var result = await _authService.LoginAsync(loginRequest);
        result.Should().BeNull();
    }
    [Fact]
    public async Task LoginAsync_WithPendingAdminUser_ReturnsAuthResponse()
    {
        var loginRequest = new LoginRequest("admin@example.com", "password123");
        var user = new User
        {
            Id = "admin123",
            Email = "admin@example.com",
            Username = "admin",
            PasswordHash = "hashedpassword",
            Role = "admin",
            Status = "pending"
        };
        var expectedToken = "jwt_token_here";
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        _mockJwtService.Setup(j => j.GenerateToken(user.Id, user.Email, user.Role))
            .Returns(expectedToken);
        var result = await _authService.LoginAsync(loginRequest);
        result.Should().NotBeNull();
        result.Token.Should().Be(expectedToken);
        result.Role.Should().Be("admin");
    }
    [Fact]
    public async Task LoginAsync_UsesPasswordServiceForVerification()
    {
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(false);
        await _authService.LoginAsync(loginRequest);
        _mockPasswordService.Verify(
            p => p.VerifyPassword(loginRequest.Password, user.PasswordHash),
            Times.Once
        );
    }
    [Fact]
    public async Task LoginAsync_GeneratesTokenWithCorrectParameters()
    {
        var loginRequest = new LoginRequest("test@example.com", "password123");
        var user = new User
        {
            Id = "user123",
            Email = "test@example.com",
            Username = "testuser",
            PasswordHash = "hashedpassword",
            Role = "user",
            Status = "approved"
        };
        _mockUserRepository.Setup(r => r.GetByEmailAsync(loginRequest.Email, default))
            .ReturnsAsync(user);
        _mockPasswordService.Setup(p => p.VerifyPassword(loginRequest.Password, user.PasswordHash))
            .Returns(true);
        _mockJwtService.Setup(j => j.GenerateToken(user.Id, user.Email, user.Role))
            .Returns("token");
        await _authService.LoginAsync(loginRequest);
        _mockJwtService.Verify(
            j => j.GenerateToken(user.Id, user.Email, user.Role),
            Times.Once
        );
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/FileValidationServiceTests.cs">
using FluentAssertions;
using Xunit;
using DnDMapBuilder.Application.Services;
namespace DnDMapBuilder.UnitTests.Services;
public class FileValidationServiceTests
{
    private readonly FileValidationService _fileValidationService = new();
    [Fact]
    public void ValidateFile_WithValidMapFile_ShouldReturnSuccess()
    {
        var fileName = "map.png";
        var fileSize = 1024 * 1024;
        var contentType = "image/png";
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }
    [Fact]
    public void ValidateFile_WithValidTokenFile_ShouldReturnSuccess()
    {
        var fileName = "token.jpeg";
        var fileSize = 512 * 1024;
        var contentType = "image/jpeg";
        var storageCategory = "tokens";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }
    [Fact]
    public void ValidateFile_WithEmptyFileName_ShouldReturnError()
    {
        var fileSize = 1024 * 1024;
        var contentType = "image/png";
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile("", fileSize, contentType, storageCategory);
        // Assert
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("File name cannot be empty"));
    }
    [Fact]
    public void ValidateFile_WithEmptyFile_ShouldReturnError()
    {
        var fileName = "file.png";
        var fileSize = 0;
        var contentType = "image/png";
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("File cannot be empty"));
    }
    [Fact]
    public void ValidateFile_WithFileSizeExceedingMapLimit_ShouldReturnError()
    {
        var fileName = "large_map.png";
        var fileSize = 6 * 1024 * 1024;
        var contentType = "image/png";
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("exceeds the maximum limit"));
    }
    [Fact]
    public void ValidateFile_WithFileSizeExceedingTokenLimit_ShouldReturnError()
    {
        var fileName = "large_token.png";
        var fileSize = 3 * 1024 * 1024;
        var contentType = "image/png";
        var storageCategory = "tokens";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("exceeds the maximum limit"));
    }
    [Fact]
    public void ValidateFile_WithInvalidMimeType_ShouldReturnError()
    {
        var fileName = "file.pdf";
        var fileSize = 1024 * 1024;
        var contentType = "application/pdf";
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeFalse();
        result.Errors.Should().Contain(error => error.Contains("not allowed"));
    }
    [Fact]
    public void ValidateFile_WithWebpMimeType_ShouldReturnSuccess()
    {
        var fileName = "image.webp";
        var fileSize = 1024 * 1024;
        var contentType = "image/webp";
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeTrue();
        result.Errors.Should().BeEmpty();
    }
    [Fact]
    public void ValidateFile_WithNullContentType_ShouldReturnError()
    {
        var fileName = "file.png";
        var fileSize = 1024 * 1024;
        var contentType = (string?)null;
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType!, storageCategory);
        result.IsValid.Should().BeFalse();
        result.Errors.Should().NotBeEmpty();
    }
    [Fact]
    public void GetMaxFileSizeForCategory_Maps_ShouldReturn5MB()
    {
        var maxSize = _fileValidationService.GetMaxFileSizeForCategory("maps");
        maxSize.Should().Be(5 * 1024 * 1024);
    }
    [Fact]
    public void GetMaxFileSizeForCategory_Tokens_ShouldReturn2MB()
    {
        var maxSize = _fileValidationService.GetMaxFileSizeForCategory("tokens");
        maxSize.Should().Be(2 * 1024 * 1024);
    }
    [Fact]
    public void GetMaxFileSizeForCategory_UnknownCategory_ShouldReturnDefault10MB()
    {
        var maxSize = _fileValidationService.GetMaxFileSizeForCategory("unknown");
        maxSize.Should().Be(10 * 1024 * 1024);
    }
    [Fact]
    public void GetAllowedMimeTypesForCategory_Maps_ShouldReturnImageTypes()
    {
        var allowedTypes = _fileValidationService.GetAllowedMimeTypesForCategory("maps");
        allowedTypes.Should().Contain(new[] { "image/png", "image/jpeg", "image/webp" });
    }
    [Fact]
    public void ValidateFile_WithMultipleErrors_ShouldReturnAllErrors()
    {
        var fileName = "file.pdf";
        var fileSize = 6 * 1024 * 1024;
        var contentType = "application/pdf";
        var storageCategory = "maps";
        var result = _fileValidationService.ValidateFile(fileName, fileSize, contentType, storageCategory);
        result.IsValid.Should().BeFalse();
        result.Errors.Should().HaveCountGreaterThan(1);
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/PasswordServiceTests.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using FluentAssertions;
using Xunit;
namespace DnDMapBuilder.UnitTests.Services;
public class PasswordServiceTests
{
    private readonly IPasswordService _passwordService;
    public PasswordServiceTests()
    {
        _passwordService = new PasswordService();
    }
    [Fact]
    public void HashPassword_WithValidPassword_ReturnsNonNullHash()
    {
        const string password = "SecurePassword123!";
        var hash = _passwordService.HashPassword(password);
        hash.Should().NotBeNullOrEmpty();
    }
    [Fact]
    public void HashPassword_WithSamePassword_ReturnsDifferentHashes()
    {
        const string password = "SecurePassword123!";
        var hash1 = _passwordService.HashPassword(password);
        var hash2 = _passwordService.HashPassword(password);
        hash1.Should().NotBe(hash2);
    }
    [Fact]
    public void VerifyPassword_WithCorrectPassword_ReturnsTrue()
    {
        const string password = "SecurePassword123!";
        var hash = _passwordService.HashPassword(password);
        var result = _passwordService.VerifyPassword(password, hash);
        result.Should().BeTrue();
    }
    [Fact]
    public void VerifyPassword_WithIncorrectPassword_ReturnsFalse()
    {
        const string password = "SecurePassword123!";
        const string wrongPassword = "WrongPassword123!";
        var hash = _passwordService.HashPassword(password);
        var result = _passwordService.VerifyPassword(wrongPassword, hash);
        result.Should().BeFalse();
    }
    [Fact]
    public void VerifyPassword_WithEmptyPassword_ReturnsFalse()
    {
        const string password = "SecurePassword123!";
        const string emptyPassword = "";
        var hash = _passwordService.HashPassword(password);
        // Act
        var result = _passwordService.VerifyPassword(emptyPassword, hash);
        // Assert
        result.Should().BeFalse();
    }
    [Fact]
    public void VerifyPassword_WithNullPassword_ThrowsException()
    {
        // Arrange
        const string password = "SecurePassword123!";
        var hash = _passwordService.HashPassword(password);
        // Act & Assert
        var action = () => _passwordService.VerifyPassword(null, hash);
        action.Should().Throw<Exception>();
    }
    [Fact]
    public void HashPassword_WithEmptyPassword_ReturnsNonNullHash()
    {
        // Arrange
        const string password = "";
        // Act
        var hash = _passwordService.HashPassword(password);
        // Assert
        hash.Should().NotBeNullOrEmpty();
    }
    [Fact]
    public void VerifyPassword_CanVerifyHashedEmptyPassword()
    {
        // Arrange
        const string password = "";
        var hash = _passwordService.HashPassword(password);
        var result = _passwordService.VerifyPassword(password, hash);
        result.Should().BeTrue();
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/UserManagementServiceTests.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
using FluentAssertions;
using Moq;
using Xunit;
namespace DnDMapBuilder.UnitTests.Services;
public class UserManagementServiceTests
{
    private readonly Mock<IUserRepository> _mockUserRepository;
    private readonly Mock<IPasswordService> _mockPasswordService;
    private readonly UserManagementService _userManagementService;
    public UserManagementServiceTests()
    {
        _mockUserRepository = new Mock<IUserRepository>();
        _mockPasswordService = new Mock<IPasswordService>();
        _userManagementService = new UserManagementService(_mockUserRepository.Object, _mockPasswordService.Object);
    }
    [Fact]
    public async Task RegisterAsync_WithValidCredentials_CreatesUserSuccessfully()
    {
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";
        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));
        var result = await _userManagementService.RegisterAsync(registerRequest);
        result.Should().NotBeNull();
        result.Username.Should().Be(registerRequest.Username);
        result.Email.Should().Be(registerRequest.Email);
        result.Role.Should().Be("user");
        result.Status.Should().Be("pending");
    }
    [Fact]
    public async Task RegisterAsync_WithDuplicateEmail_ReturnsNull()
    {
        var registerRequest = new RegisterRequest("newuser", "existing@example.com", "password123");
        var existingUser = new User
        {
            Email = registerRequest.Email,
            Username = "existinguser"
        };
        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync(existingUser);
        var result = await _userManagementService.RegisterAsync(registerRequest);
        result.Should().BeNull();
    }
    [Fact]
    public async Task RegisterAsync_WithDuplicateUsername_ReturnsNull()
    {
        var registerRequest = new RegisterRequest("existinguser", "new@example.com", "password123");
        var existingUser = new User
        {
            Username = registerRequest.Username,
            Email = "existing@example.com"
        };
        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync(existingUser);
        var result = await _userManagementService.RegisterAsync(registerRequest);
        result.Should().BeNull();
    }
    [Fact]
    public async Task RegisterAsync_UsesPasswordServiceToHashPassword()
    {
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";
        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));
        await _userManagementService.RegisterAsync(registerRequest);
        _mockPasswordService.Verify(
            p => p.HashPassword(registerRequest.Password),
            Times.Once
        );
    }
    [Fact]
    public async Task RegisterAsync_CallsRepositoryAddAsync()
    {
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";
        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));
        await _userManagementService.RegisterAsync(registerRequest);
        _mockUserRepository.Verify(
            r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }
    [Fact]
    public async Task ApproveUserAsync_WithValidUserId_ApprovesUser()
    {
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };
        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);
        var result = await _userManagementService.ApproveUserAsync(userId, true);
        result.Should().BeTrue();
    }
    [Fact]
    public async Task ApproveUserAsync_WithValidUserId_RejectsUser()
    {
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };
        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);
        var result = await _userManagementService.ApproveUserAsync(userId, false);
        result.Should().BeTrue();
    }
    [Fact]
    public async Task ApproveUserAsync_WithNonExistentUserId_ReturnsFalse()
    {
        var userId = "nonexistent";
        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync((User)null);
        var result = await _userManagementService.ApproveUserAsync(userId, true);
        result.Should().BeFalse();
    }
    [Fact]
    public async Task ApproveUserAsync_UpdatesUserStatus()
    {
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };
        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);
        await _userManagementService.ApproveUserAsync(userId, true);
        _mockUserRepository.Verify(
            r => r.UpdateAsync(It.Is<User>(u => u.Id == userId && u.Status == "approved"), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }
    [Fact]
    public async Task ApproveUserAsync_SetStatusToRejectedWhenApprovedIsFalse()
    {
        var userId = "user123";
        var user = new User
        {
            Id = userId,
            Status = "pending"
        };
        _mockUserRepository.Setup(r => r.GetByIdAsync(userId, default))
            .ReturnsAsync(user);
        _mockUserRepository.Setup(r => r.UpdateAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);
        await _userManagementService.ApproveUserAsync(userId, false);
        _mockUserRepository.Verify(
            r => r.UpdateAsync(It.Is<User>(u => u.Id == userId && u.Status == "rejected"), It.IsAny<CancellationToken>()),
            Times.Once
        );
    }
    [Fact]
    public async Task GetPendingUsersAsync_ReturnsPendingUsers()
    {
        var pendingUsers = new List<User>
        {
            new User { Id = "user1", Username = "user1", Email = "user1@example.com", Status = "pending", Role = "user" },
            new User { Id = "user2", Username = "user2", Email = "user2@example.com", Status = "pending", Role = "user" }
        };
        _mockUserRepository.Setup(r => r.GetPendingUsersAsync(default))
            .ReturnsAsync(pendingUsers);
        var result = await _userManagementService.GetPendingUsersAsync();
        result.Should().HaveCount(2);
        result.Should().AllSatisfy(u => u.Status.Should().Be("pending"));
    }
    [Fact]
    public async Task GetPendingUsersAsync_ReturnsEmptyListWhenNoPendingUsers()
    {
        var emptyList = new List<User>();
        _mockUserRepository.Setup(r => r.GetPendingUsersAsync(default))
            .ReturnsAsync(emptyList);
        var result = await _userManagementService.GetPendingUsersAsync();
        result.Should().BeEmpty();
    }
    [Fact]
    public async Task RegisterAsync_SetsInitialStatusToPending()
    {
        var registerRequest = new RegisterRequest("newuser", "new@example.com", "password123");
        const string hashedPassword = "hashed_password";
        _mockUserRepository.Setup(r => r.GetByEmailAsync(registerRequest.Email, default))
            .ReturnsAsync((User)null);
        _mockUserRepository.Setup(r => r.GetByUsernameAsync(registerRequest.Username, default))
            .ReturnsAsync((User)null);
        _mockPasswordService.Setup(p => p.HashPassword(registerRequest.Password))
            .Returns(hashedPassword);
        _mockUserRepository.Setup(r => r.AddAsync(It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .Returns<User, CancellationToken>((user, ct) => Task.FromResult(user));
        var result = await _userManagementService.RegisterAsync(registerRequest);
        result.Status.Should().Be("pending");
    }
}
</file>

<file path="backend-main-example.yml">
name: CI/CD Pipeline
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
env:
  DOTNET_VERSION: '10.0.x'
  REGISTRY: ghcr.io
jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    - name: Restore dependencies
      run: dotnet restore DnDMapBuilder.sln
    - name: Build
      run: dotnet build DnDMapBuilder.sln --configuration Release --no-restore
    - name: Test
      run: dotnet test DnDMapBuilder.sln --configuration Release --no-build --verbosity normal
  build-docker:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write
    outputs:
      image-name: ${{ steps.image-name.outputs.lowercase }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Convert repository name to lowercase
      id: image-name
      run: echo "lowercase=${GITHUB_REPOSITORY@L}" >> $GITHUB_OUTPUT
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Extract metadata (tags, labels)
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.lowercase }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./src/DnDMapBuilder.Api/Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
  deploy-dev:
    needs: build-docker
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    environment: development
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Deploy to dev server via SSH
      env:
        IMAGE_NAME: ${{ needs.build-docker.outputs.image-name }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.DEV_SERVER_HOST }}
        username: ${{ secrets.DEV_SERVER_USERNAME }}
        key: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
        port: ${{ secrets.DEV_SERVER_PORT || 22 }}
        envs: IMAGE_NAME
        script: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker network create dnd-network 2>/dev/null || true
          docker pull ghcr.io/${IMAGE_NAME}:latest
          echo "Running database migrations..."
          docker run --rm \
            -e ConnectionStrings__DefaultConnection="${{ secrets.DEV_DB_CONNECTION_STRING }}" \
            ghcr.io/${IMAGE_NAME}:latest \
            sh -c "dotnet ef database update --project src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj --startup-project src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj --context DnDMapBuilderDbContext || exit 1"
          echo "Database migrations completed"
          docker stop dnd-api-dev || true
          docker rm dnd-api-dev || true
          mkdir -p ~/dnd-api-dev-uploads
          docker run -d \
            --name dnd-api-dev \
            --restart unless-stopped \
            -p 5000:8080 \
            -p 5001:8443 \
            -e ASPNETCORE_ENVIRONMENT=Development \
            -e ASPNETCORE_URLS="http://+:8080;https://+:8443" \
            -e ConnectionStrings__DefaultConnection="${{ secrets.DEV_DB_CONNECTION_STRING }}" \
            -v ~/dnd-api-dev-uploads:/app/wwwroot/uploads \
            --network dnd-network \
            --health-cmd="curl -f http://localhost:8080/health/live || exit 1" \
            --health-interval=30s \
            --health-timeout=3s \
            --health-retries=3 \
            --health-start-period=10s \
            ghcr.io/${IMAGE_NAME}:latest
          docker image prune -f
    - name: Verify dev deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.DEV_SERVER_HOST }}
        username: ${{ secrets.DEV_SERVER_USERNAME }}
        key: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
        port: ${{ secrets.DEV_SERVER_PORT || 22 }}
        script: |
          echo "Waiting for API container to be healthy..."
          for i in {1..30}; do
            if docker exec dnd-api-dev curl -f http://localhost:8080/health/live > /dev/null 2>&1; then
              echo "✓ API container is healthy"
              break
            fi
            echo "Attempt $i/30: Waiting for API..."
            sleep 2
          done
          echo ""
          echo "Checking container status..."
          docker ps --filter "name=dnd-api-dev" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          echo ""
          echo "Testing health check endpoints..."
          curl -s -f http://localhost:5000/health/live > /dev/null && echo "✓ /health/live - OK" || echo "✗ /health/live - FAILED"
          curl -s -f http://localhost:5000/health > /dev/null && echo "✓ /health - OK" || echo "✗ /health - FAILED"
          echo ""
          echo "Recent API container logs:"
          docker logs dnd-api-dev --tail 30
  # Job 4: Deploy to Production (only on pushes to main branch)
  deploy-prod:
    needs: build-docker
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Deploy to prod server via SSH
      env:
        IMAGE_NAME: ${{ needs.build-docker.outputs.image-name }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_SERVER_HOST }}
        username: ${{ secrets.PROD_SERVER_USERNAME }}
        key: ${{ secrets.PROD_SSH_PRIVATE_KEY }}
        port: ${{ secrets.PROD_SERVER_PORT || 22 }}
        envs: IMAGE_NAME
        script: |
          # Login to GitHub Container Registry
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          # Create Docker network if it doesn't exist
          docker network create dnd-network 2>/dev/null || true
          # Pull the latest API image
          docker pull ghcr.io/${IMAGE_NAME}:latest
          # Run database migrations before deploying new container
          echo "Running database migrations..."
          docker run --rm \
            -e ConnectionStrings__DefaultConnection="${{ secrets.PROD_DB_CONNECTION_STRING }}" \
            ghcr.io/${IMAGE_NAME}:latest \
            sh -c "dotnet ef database update --project src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj --startup-project src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj --context DnDMapBuilderDbContext || exit 1"
          echo "Database migrations completed"
          docker stop dnd-api || true
          docker rm dnd-api || true
          mkdir -p ~/dnd-api-uploads
          docker run -d \
            --name dnd-api \
            --restart unless-stopped \
            -p 5000:8080 \
            -p 5001:8443 \
            -e ASPNETCORE_ENVIRONMENT=Production \
            -e ASPNETCORE_URLS="http://+:8080;https://+:8443" \
            -e ConnectionStrings__DefaultConnection="${{ secrets.PROD_DB_CONNECTION_STRING }}" \
            -v ~/dnd-api-uploads:/app/wwwroot/uploads \
            --network dnd-network \
            --health-cmd="curl -f http://localhost:8080/health/live || exit 1" \
            --health-interval=30s \
            --health-timeout=3s \
            --health-retries=3 \
            --health-start-period=10s \
            ghcr.io/${IMAGE_NAME}:latest
          docker image prune -f
    - name: Verify prod deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PROD_SERVER_HOST }}
        username: ${{ secrets.PROD_SERVER_USERNAME }}
        key: ${{ secrets.PROD_SSH_PRIVATE_KEY }}
        port: ${{ secrets.PROD_SERVER_PORT || 22 }}
        script: |
          echo "Waiting for API container to be healthy..."
          for i in {1..30}; do
            if docker exec dnd-api curl -f http://localhost:8080/health/live > /dev/null 2>&1; then
              echo "✓ API container is healthy"
              break
            fi
            echo "Attempt $i/30: Waiting for API..."
            sleep 2
          done
          echo ""
          echo "Checking container status..."
          docker ps --filter "name=dnd-api" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          echo ""
          echo "Testing health check endpoints..."
          curl -s -f http://localhost:5000/health/live > /dev/null && echo "✓ /health/live - OK" || echo "✗ /health/live - FAILED"
          curl -s -f http://localhost:5000/health > /dev/null && echo "✓ /health - OK" || echo "✗ /health - FAILED"
          echo ""
          echo "Recent API container logs:"
          docker logs dnd-api --tail 30
</file>

<file path="DEPLOYMENT.md">
# Deployment Runbook

## Overview

This runbook documents the procedures, checklists, and strategies for deploying DnDMapBuilder API to production and staging environments.

## Pre-Deployment Checklist

### Code and Build
- [ ] All tests passing: `dotnet test`
- [ ] Build succeeding: `dotnet build --configuration Release`
- [ ] No compiler warnings
- [ ] Code review completed and approved
- [ ] All changes merged to main branch
- [ ] Version bumped (semantic versioning)

### Security
- [ ] No vulnerable dependencies: `dotnet list package --vulnerable`
- [ ] Secrets not in source code
- [ ] CORS origins configured for target environment
- [ ] Security headers configured
- [ ] Rate limiting policies appropriate
- [ ] Authentication/authorization tests passing

### Database
- [ ] Database migrations tested locally
- [ ] Backup created before migration
- [ ] Rollback plan documented
- [ ] Data consistency verified

### Infrastructure
- [ ] Target environment verified (staging/production)
- [ ] Database connection string verified
- [ ] Key Vault secrets configured
- [ ] Health check endpoints responding
- [ ] Monitoring and logging configured

### Documentation
- [ ] Release notes prepared
- [ ] Breaking changes documented
- [ ] Migration guide prepared (if applicable)
- [ ] Runbook reviewed

## Deployment Steps

### Phase 1: Pre-Deployment (30 minutes)

1. **Create deployment ticket**
   - Document deployment date/time
   - List changes and version
   - Assign responsible engineer

2. **Verify environment readiness**
   ```bash
   # Check target environment
   docker ps -a
   docker network ls
   
   # Verify services
   curl https://api.example.com/health
   
   # Check logs
   docker logs dnd-api
   ```

3. **Take database backup**
   ```bash
   # SQL Server backup
   docker exec -it dnd-db sqlcmd -S localhost -U sa \
     -P $SA_PASSWORD \
     -Q "BACKUP DATABASE [DnDMapBuilder] \
         TO DISK = '/var/opt/mssql/backup/pre-deployment.bak'"
   ```

4. **Notify stakeholders**
   - Post deployment notification to Slack/Teams
   - Set deployment status page to "In Progress"
   - Alert support team of potential service interruption

### Phase 2: Application Deployment (15-30 minutes)

#### Option A: Docker Compose (Single Host)

```bash
# 1. Navigate to deployment directory
cd ~/dnd-deployment

# 2. Pull latest image
docker pull ghcr.io/yourorg/dnd-api:latest

# 3. Stop current container
docker-compose down

# 4. Start new container
docker-compose up -d

# 5. Verify startup
sleep 10
docker logs dnd-api | tail -20
```

#### Option B: Kubernetes (Production)

```bash
# 1. Update image version in deployment
kubectl set image deployment/dnd-api \
  dnd-api=ghcr.io/yourorg/dnd-api:v1.2.3

# 2. Monitor rollout
kubectl rollout status deployment/dnd-api

# 3. Verify pods running
kubectl get pods -l app=dnd-api

# 4. Check logs
kubectl logs -l app=dnd-api -f
```

#### Option C: Azure App Service

```bash
# 1. Deploy using Azure CLI
az webapp deployment source config-zip \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --src-path release.zip

# 2. Monitor deployment
az webapp deployment slot show \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --slot staging

# 3. Swap slots when ready
az webapp deployment slot swap \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --slot staging
```

### Phase 3: Database Migration (10-20 minutes)

If database schema changes exist:

```bash
# 1. Run migrations
docker exec -it dnd-api \
  dotnet ef database update --context DnDMapBuilderDbContext

# 2. Verify migration
docker exec -it dnd-api \
  dotnet ef migrations list --context DnDMapBuilderDbContext

# 3. Check database state
docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
  -Q "SELECT TOP 5 * FROM dbo.Users"
```

### Phase 4: Post-Deployment Verification (15-20 minutes)

1. **Health Check**
   ```bash
   curl https://api.example.com/health
   curl https://api.example.com/health/ready
   curl https://api.example.com/health/live
   ```

2. **Smoke Tests**
   - Login endpoint: `curl -X POST https://api.example.com/api/v1/auth/login`
   - Get user data: `curl -H "Authorization: Bearer $TOKEN" https://api.example.com/api/v1/campaigns`
   - Create resource: Test campaign creation
   - File upload: Test image upload
   - Rate limiting: Verify 429 responses

3. **Monitor Metrics**
   ```bash
   # Check application logs
   docker logs -f dnd-api
   
   # Check error rate
   curl https://api.example.com/metrics | grep http_requests_total
   
   # Check performance
   kubectl top pod -l app=dnd-api  # Kubernetes
   ```

4. **Database Consistency**
   ```bash
   # Check record counts
   docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
     -Q "SELECT COUNT(*) FROM Users; SELECT COUNT(*) FROM Campaigns;"
   ```

## Rollback Procedure

If issues occur during or after deployment:

### Quick Rollback (< 2 minutes)

```bash
# Docker Compose
docker-compose down
git checkout previous-tag
docker-compose up -d

# Kubernetes
kubectl rollout undo deployment/dnd-api

# Azure App Service
az webapp deployment slot swap \
  --resource-group dnd-rg \
  --name dnd-api-app \
  --slot staging
```

### Database Rollback (if needed)

```bash
# SQL Server restore
docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
  -Q "RESTORE DATABASE [DnDMapBuilder] \
      FROM DISK = '/var/opt/mssql/backup/pre-deployment.bak' \
      WITH REPLACE"

# Verify database
docker exec -it dnd-db sqlcmd -S localhost -U sa -P $SA_PASSWORD \
  -Q "SELECT @@VERSION"
```

### Notification After Rollback

- Post incident notification to Slack/Teams
- Document root cause
- Create ticket for issue resolution
- Plan re-deployment

## Environment-Specific Procedures

### Staging Deployment

```bash
# Deploy to staging for validation
git push origin develop

# Automated deployment via GitHub Actions
# Verify health: https://staging-api.example.com/health

# Run extended smoke tests
./scripts/smoke_tests.sh https://staging-api.example.com

# If tests pass, proceed to production
```

### Production Deployment

```bash
# Merge develop to main
git push origin develop:main

# Wait for automated deployment
# Verify all post-deployment checks
# Monitor for 24 hours

# If issues arise, execute rollback
```

## Monitoring Post-Deployment

### First Hour
- Monitor error rates in real-time
- Check for exceptions in logs
- Verify performance metrics
- Monitor database queries

### First Day
- Check for memory leaks
- Verify all endpoints responding
- Monitor rate limiting effectiveness
- Check for security events

### First Week
- Review error trends
- Analyze performance metrics
- Check for regressions
- Verify telemetry collection

## Incident Response During Deployment

### If deployment fails to complete

1. **Assess severity**
   - Is service down or degraded?
   - Are users affected?
   - Can it be fixed quickly?

2. **Immediate action**
   - If critical: Execute rollback immediately
   - If minor: Continue investigation

3. **Investigation**
   - Check logs: `docker logs dnd-api`
   - Check database: Verify connection
   - Check infrastructure: Resource availability
   - Check dependencies: External services

4. **Communication**
   - Update status page
   - Notify stakeholders
   - Post incident channel updates
   - Document timeline

### If health checks fail

1. Verify network connectivity
2. Check service startup logs
3. Verify configuration files
4. Check database connectivity
5. Execute rollback if unable to resolve quickly

### If performance degrades

1. Check memory usage
2. Monitor CPU utilization
3. Analyze slow queries
4. Check rate limiting
5. Scale infrastructure if necessary

## Post-Deployment Reporting

### Deployment Report Template

```
Deployment Report - [Date]

Deployment Details:
- Version: [Version number]
- Environment: [staging/production]
- Start time: [Time]
- End time: [Time]
- Duration: [Minutes]

Changes Deployed:
- [List of features/fixes]

Pre-Deployment Checks:
- [✓] Tests passing
- [✓] Security audit passed
- [✓] Database backup created

Post-Deployment Results:
- [✓] Health checks passing
- [✓] Smoke tests passed
- [✓] Performance acceptable

Issues Encountered:
- None

Verification:
- [✓] Endpoints responding
- [✓] Authentication working
- [✓] File uploads functional
- [✓] Rate limiting active

Rollback Status:
- Not required

Signed off by: [Name]
Date: [Date]
```

## Deployment Automation

### GitHub Actions Workflow

```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Build Docker image
        run: docker build -t dnd-api:${{ github.sha }} .
      
      - name: Push to registry
        run: docker push dnd-api:${{ github.sha }}
      
      - name: Deploy to production
        run: |
          # Deploy commands
          docker pull dnd-api:${{ github.sha }}
          docker-compose up -d
      
      - name: Run smoke tests
        run: ./scripts/smoke_tests.sh
      
      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
```

## Disaster Recovery

### Database Corruption

1. Restore from latest backup
2. Verify data consistency
3. Run integrity checks
4. Monitor for anomalies

### Complete Service Failure

1. Execute rollback procedure
2. Restore from backup
3. Verify service startup
4. Run full smoke test suite

### Data Loss Scenario

1. Restore from backup (ideally < 1 hour old)
2. Verify backup integrity
3. Communicate to users about data recovery
4. Monitor for issues

## References

- [ASP.NET Core Deployment](https://learn.microsoft.com/aspnet/core/host-and-deploy/)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Kubernetes Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
- [Incident Response](https://www.atlassian.com/incident-management)
</file>

<file path="dotnet-tools.json">
{
  "version": 1,
  "isRoot": true,
  "tools": {
    "dotnet-ef": {
      "version": "10.0.2",
      "commands": [
        "dotnet-ef"
      ],
      "rollForward": false
    }
  }
}
</file>

<file path="FILE_STRUCTURE.md">
# DnD Map Builder - Complete File Structure

## Solution Structure

```
DnDMapBuilder/
│
├── DnDMapBuilder.sln                      # Visual Studio Solution File
├── .gitignore                             # Git ignore patterns
├── docker-compose.yml                     # Docker Compose configuration
├── setup.sh                               # Quick setup script (chmod +x)
│
├── README.md                              # Main documentation
├── QUICKSTART.md                          # Quick start guide
├── API_DOCUMENTATION.md                   # Complete API reference
├── PROJECT_SUMMARY.md                     # Project overview
├── FILE_STRUCTURE.md                      # This file
│
└── src/                                   # Source code directory
    │
    ├── DnDMapBuilder.Contracts/           # DTO & Contract Layer
    │   ├── DnDMapBuilder.Contracts.csproj
    │   ├── DTOs/
    │   │   └── DomainDtos.cs             # Campaign, Mission, Map, Token DTOs
    │   ├── Requests/
    │   │   └── ApiRequests.cs            # Create/Update request models
    │   └── Responses/
    │       └── ApiResponses.cs           # API response wrappers
    │
    ├── DnDMapBuilder.Data/                # Data Access Layer
    │   ├── DnDMapBuilder.Data.csproj
    │   ├── DnDMapBuilderDbContext.cs     # EF Core DbContext
    │   ├── Entities/
    │   │   └── DomainEntities.cs         # Database entities (User, Campaign, etc.)
    │   └── Repositories/
    │       ├── IRepositories.cs          # Repository interfaces
    │       └── Repositories.cs           # Repository implementations
    │
    ├── DnDMapBuilder.Application/         # Business Logic Layer
    │   ├── DnDMapBuilder.Application.csproj
    │   ├── Interfaces/
    │   │   └── IServices.cs              # Service interfaces
    │   ├── Mappings/
    │   │   └── MappingExtensions.cs      # Entity to DTO mappings
    │   └── Services/
    │       ├── AuthService.cs            # Authentication & user management
    │       ├── CampaignService.cs        # Campaign operations
    │       ├── MissionService.cs         # Mission operations
    │       ├── GameMapAndTokenServices.cs # Map & token operations
    │       └── JwtService.cs             # JWT token generation/validation
    │
    ├── DnDMapBuilder.Api/                 # Web API Layer
    │   ├── DnDMapBuilder.Api.csproj
    │   ├── Program.cs                    # Application entry point & DI configuration
    │   ├── Dockerfile                    # Docker image definition
    │   ├── appsettings.json              # Application configuration
    │   ├── appsettings.Development.json  # Development configuration
    │   ├── Controllers/
    │   │   ├── AuthController.cs         # /api/auth endpoints
    │   │   ├── CampaignsController.cs    # /api/campaigns endpoints
    │   │   └── OtherControllers.cs       # Missions, Maps, Tokens endpoints
    │   └── Properties/
    │       └── launchSettings.json       # Launch profiles (HTTP/HTTPS)
    │
    ├── DnDMapBuilder.Aspire.AppHost/      # Aspire Orchestration
    │   ├── DnDMapBuilder.Aspire.AppHost.csproj
    │   └── Program.cs                    # Aspire app host configuration
    │
    └── DnDMapBuilder.Aspire.ServiceDefaults/ # Aspire Shared Services
        ├── DnDMapBuilder.Aspire.ServiceDefaults.csproj
        └── Extensions.cs                 # OpenTelemetry & health checks
```

## File Descriptions

### Root Level

- **DnDMapBuilder.sln**: Visual Studio solution file that references all projects
- **.gitignore**: Specifies files/folders to ignore in version control
- **docker-compose.yml**: Docker Compose configuration for SQL Server + API
- **setup.sh**: Bash script for quick project setup (make executable with `chmod +x`)

### Documentation Files

- **README.md**: Complete setup instructions and project overview
- **QUICKSTART.md**: Fast setup guide with minimal steps
- **API_DOCUMENTATION.md**: Full API endpoint reference with examples
- **PROJECT_SUMMARY.md**: Architecture overview and technology stack

### Source Projects

#### 1. DnDMapBuilder.Contracts (No Dependencies)
**Purpose**: Define data contracts used across all layers

- `DTOs/DomainDtos.cs`: Data transfer objects for all domain models
- `Requests/ApiRequests.cs`: Request models for API endpoints
- `Responses/ApiResponses.cs`: Standardized response wrappers

#### 2. DnDMapBuilder.Data (Depends on: None)
**Purpose**: Database access and entity definitions

- `DnDMapBuilderDbContext.cs`: EF Core database context with configuration
- `Entities/DomainEntities.cs`: Database entity classes (User, Campaign, Mission, GameMap, TokenDefinition, MapTokenInstance)
- `Repositories/IRepositories.cs`: Repository interface definitions
- `Repositories/Repositories.cs`: Concrete repository implementations with EF Core

**Key Features**:
- Entity relationships configured with Fluent API
- Repository pattern for data access abstraction
- Seeded admin user for initial setup

#### 3. DnDMapBuilder.Application (Depends on: Contracts, Data)
**Purpose**: Business logic and service layer

- `Interfaces/IServices.cs`: Service contracts (IAuthService, ICampaignService, etc.)
- `Mappings/MappingExtensions.cs`: Extension methods for Entity→DTO conversion
- `Services/AuthService.cs`: User registration, login, approval workflow
- `Services/JwtService.cs`: JWT token generation and validation
- `Services/CampaignService.cs`: Campaign CRUD operations
- `Services/MissionService.cs`: Mission CRUD operations
- `Services/GameMapAndTokenServices.cs`: Map and token CRUD operations

**Key Features**:
- User ownership validation
- Role-based authorization checks
- Password hashing with BCrypt
- JWT token management

#### 4. DnDMapBuilder.Api (Depends on: Application, Contracts, Data)
**Purpose**: REST API endpoints and HTTP handling

- `Program.cs`: Application startup, DI container configuration, middleware pipeline
- `Controllers/AuthController.cs`: Authentication endpoints
- `Controllers/CampaignsController.cs`: Campaign management endpoints
- `Controllers/OtherControllers.cs`: Missions, Maps, and Tokens endpoints
- `appsettings.json`: Database connection, JWT settings
- `Dockerfile`: Multi-stage Docker build definition

**Key Features**:
- JWT Bearer authentication
- Swagger/OpenAPI documentation
- CORS configuration
- Automatic database migration on startup

#### 5. DnDMapBuilder.Aspire.AppHost (Depends on: Api, ServiceDefaults)
**Purpose**: Local development orchestration

- `Program.cs`: Configure SQL Server and API containers

**Features**:
- SQL Server container with persistent volume
- Automatic service discovery
- Health check monitoring
- Aspire dashboard

#### 6. DnDMapBuilder.Aspire.ServiceDefaults (No Dependencies)
**Purpose**: Shared Aspire configuration

- `Extensions.cs`: OpenTelemetry, health checks, service discovery

## Total File Count

- **C# Project Files**: 6
- **C# Source Files**: 19
- **Configuration Files**: 5
- **Documentation Files**: 5
- **Docker Files**: 2
- **Scripts**: 1

**Total**: 38 files

## File Sizes (Approximate)

- Total solution size: ~115 KB (code only)
- Largest file: `Repositories.cs` (~6 KB)
- Average file size: ~3 KB

## Technology Stack by Project

### DnDMapBuilder.Contracts
- .NET 9.0
- No external dependencies

### DnDMapBuilder.Data
- .NET 9.0
- Entity Framework Core 9.0
- SQL Server provider

### DnDMapBuilder.Application
- .NET 9.0
- BCrypt.Net-Next
- System.IdentityModel.Tokens.Jwt

### DnDMapBuilder.Api
- ASP.NET Core 9.0
- JWT Bearer Authentication
- Swashbuckle (Swagger)
- Entity Framework Core Design Tools

### Aspire Projects
- .NET 9.0
- Aspire.Hosting
- OpenTelemetry

## Quick Navigation

| Task | File to Modify |
|------|---------------|
| Add new API endpoint | `src/DnDMapBuilder.Api/Controllers/` |
| Add business logic | `src/DnDMapBuilder.Application/Services/` |
| Add database entity | `src/DnDMapBuilder.Data/Entities/DomainEntities.cs` |
| Add repository method | `src/DnDMapBuilder.Data/Repositories/` |
| Change DB schema | `src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs` |
| Add DTO | `src/DnDMapBuilder.Contracts/DTOs/` |
| Configure JWT | `src/DnDMapBuilder.Api/appsettings.json` |
| Change connection string | `src/DnDMapBuilder.Api/appsettings.json` |
| Modify Aspire setup | `src/DnDMapBuilder.Aspire.AppHost/Program.cs` |

## Missing Files (By Design)

The following are **NOT** included as they're generated/downloaded:
- `bin/` and `obj/` directories (build output)
- `packages/` directory (NuGet packages)
- `.vs/` directory (Visual Studio cache)
- `*.user` files (user-specific settings)
- Database migration files (generate with EF Core tools)
- `node_modules/` (not applicable for this project)

## Next Steps After Download

1. Extract the ZIP file
2. Navigate to the `DnDMapBuilder` directory
3. Choose a run method:
   - Aspire: Run `setup.sh` and select option 1
   - Docker: Run `docker-compose up`
   - Direct: Configure SQL Server and run `dotnet run`
4. Access Swagger UI to test the API

## Verifying the Structure

Run this command in the root directory to verify all files are present:

```bash
find . -name "*.csproj" | wc -l  # Should show 6
find . -name "*.cs" | wc -l      # Should show 19
```

## Support Files

All necessary support files are included:
- ✅ Solution file (.sln)
- ✅ Project files (.csproj)
- ✅ Configuration files (appsettings.json, launchSettings.json)
- ✅ Docker files (Dockerfile, docker-compose.yml)
- ✅ Documentation (4 markdown files)
- ✅ Setup script (setup.sh)
- ✅ Git ignore (.gitignore)

The solution is **complete and ready to build**!
</file>

<file path="LOAD_TESTING.md">
# Load Testing and Performance Validation Guide

## Overview

This guide provides load testing strategies and performance benchmarks for the DnDMapBuilder API. Load testing helps identify bottlenecks, validate rate limiting, and ensure the API can handle expected and peak loads.

## Load Testing Tools

### Recommended Tools

1. **k6** (JavaScript-based, cloud-native)
   - Easy to write tests in JavaScript
   - Real-time results
   - Cloud execution for distributed load
   - Excellent metrics and visualization

2. **Apache JMeter** (Java-based, GUI)
   - Enterprise standard
   - Good for complex scenarios
   - Built-in reporting
   - Large community

3. **Apache Bench (ab)** (Simple, CLI)
   - Quick and simple
   - Good for baseline testing
   - Limited features

### Installation

#### k6
```bash
# macOS
brew install k6

# Linux
sudo apt-get install k6

# Windows (via Chocolatey)
choco install k6
```

#### JMeter
```bash
# macOS
brew install jmeter

# Download from https://jmeter.apache.org/download_jmeter.html
```

## Test Scenarios

### Scenario 1: Authentication Load Test

**Objective:** Validate login endpoint under sustained load

**Test Profile:**
- Duration: 2 minutes
- Ramp-up: 30 seconds to 100 concurrent users
- Steady state: 100 users for 1.5 minutes
- Ramp-down: 30 seconds

**Expected Metrics:**
- Response time p95: < 500ms
- Response time p99: < 1000ms
- Error rate: < 0.1%
- Throughput: > 50 requests/sec

**k6 Script:**
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '30s', target: 100 },
    { duration: '1m30s', target: 100 },
    { duration: '30s', target: 0 },
  ],
  thresholds: {
    http_req_duration: ['p(95)<500', 'p(99)<1000'],
    http_req_failed: ['rate<0.01'],
  },
};

const BASE_URL = 'http://localhost:5000/api/v1';

export default function() {
  const loginPayload = JSON.stringify({
    email: `user${Math.floor(Math.random() * 1000)}@example.com`,
    password: 'TestPassword123!',
  });

  const response = http.post(`${BASE_URL}/auth/login`, loginPayload, {
    headers: { 'Content-Type': 'application/json' },
  });

  check(response, {
    'login status is 200 or 401': (r) => r.status === 200 || r.status === 401,
  });

  sleep(1);
}
```

### Scenario 2: CRUD Operations Load Test

**Objective:** Validate campaign CRUD operations under load

**Test Profile:**
- Duration: 3 minutes
- Ramp-up: 1 minute to 50 concurrent users
- Steady state: 50 users for 1.5 minutes
- Ramp-down: 30 seconds
- Mix: 40% GET, 30% POST, 20% PUT, 10% DELETE

**Expected Metrics:**
- Response time p95: < 300ms
- Response time p99: < 700ms
- Error rate: < 0.5%
- Throughput: > 30 requests/sec

### Scenario 3: File Upload Load Test

**Objective:** Validate file upload performance under concurrent uploads

**Test Profile:**
- Duration: 2 minutes
- Concurrent users: 10 (limited by file upload rate limit)
- File size: 1-3MB images
- Expected: Hits rate limit at ~10 requests/minute

**Expected Metrics:**
- Response time p95: < 2 seconds (includes file I/O)
- Error rate: < 1% (429 status acceptable)
- Rate limit compliance: 100% at > 10 req/min

### Scenario 4: Sustained Load Test

**Objective:** Validate API stability under 8-hour sustained load

**Test Profile:**
- Duration: 8 hours
- Concurrent users: 50 (constant)
- Think time: 1-2 seconds between requests
- Request mix: 60% GET, 20% POST, 15% PUT, 5% DELETE

**Expected Metrics:**
- No memory leaks (stable memory usage)
- Response time degradation: < 10% over 8 hours
- Error rate: < 0.1%
- Database connection pool stable

### Scenario 5: Spike Load Test

**Objective:** Validate API behavior during sudden traffic spikes

**Test Profile:**
- Baseline: 10 concurrent users
- Spike: Increase to 500 concurrent users in 10 seconds
- Hold: Maintain for 2 minutes
- Return to baseline

**Expected Metrics:**
- Response time p99 during spike: < 2000ms
- Error rate during spike: < 5%
- Recovery: Return to normal response times within 1 minute

## Performance Benchmarks

### Target Metrics

| Metric | Target | Acceptable | Warning |
|--------|--------|-----------|---------|
| Response Time (p50) | < 100ms | < 200ms | > 200ms |
| Response Time (p95) | < 300ms | < 500ms | > 500ms |
| Response Time (p99) | < 500ms | < 1000ms | > 1000ms |
| Error Rate | < 0.1% | < 0.5% | > 0.5% |
| Throughput | > 100 req/s | > 50 req/s | < 50 req/s |
| CPU Utilization | < 60% | < 80% | > 80% |
| Memory Utilization | < 60% | < 80% | > 80% |
| Database Connection Pool | < 80% utilized | < 90% utilized | > 90% utilized |

## Running Load Tests

### Using k6

```bash
# Basic run
k6 run load_test.js

# With output file
k6 run load_test.js --out csv=results.csv

# Cloud execution (requires k6 Cloud account)
k6 cloud load_test.js

# With custom environment
k6 run -e BASE_URL=https://api.production.com load_test.js
```

### Using Apache JMeter

```bash
# Interactive GUI
jmeter -t load_test.jmx

# Headless (command line)
jmeter -n -t load_test.jmx -l results.jtl -j jmeter.log

# Generate HTML report
jmeter -g results.jtl -o report/
```

## Performance Optimization Recommendations

### Based on Load Test Results

**If response times > target:**
1. Check database query performance (use query analyzer)
2. Add caching for frequently accessed data
3. Implement pagination for large result sets
4. Consider read replicas for database scaling
5. Review middleware performance (remove unnecessary middleware)
6. Profile application code for hotspots

**If error rate > acceptable:**
1. Review error logs for specific failure modes
2. Increase database connection pool size
3. Add circuit breaker for external dependencies
4. Implement request queuing/backpressure
5. Scale horizontally (add more instances)

**If memory usage increases:**
1. Profile for memory leaks
2. Review logging configuration (excessive log data)
3. Check for unbounded collections
4. Verify connection pool cleanup
5. Monitor garbage collection frequency

**If CPU usage high:**
1. Profile CPU-intensive operations
2. Review encryption/hashing operations
3. Check for tight loops
4. Consider async operations where applicable
5. Profile LINQ query compilation

## Continuous Load Testing

### CI/CD Integration

Add to GitHub Actions workflow:

```yaml
name: Load Testing

on:
  schedule:
    - cron: '0 2 * * 0'  # Weekly at 2 AM UTC

jobs:
  load-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Install k6
        run: sudo apt-get install k6
      
      - name: Start API
        run: |
          docker-compose up -d
          sleep 10
      
      - name: Run Load Tests
        run: k6 run load_tests/auth_load_test.js
      
      - name: Upload Results
        uses: actions/upload-artifact@v2
        with:
          name: load-test-results
          path: results/
```

## Monitoring During Load Tests

### Metrics to Monitor

**Application Level:**
- CPU and Memory usage
- Request rate (requests/sec)
- Response times (p50, p95, p99)
- Error rate
- Active connections

**Database Level:**
- Query execution time
- Connection pool utilization
- Deadlock occurrences
- I/O operations

**Infrastructure Level:**
- Network bandwidth
- Disk I/O
- System load
- Available resources

### Tools

- **Grafana:** Real-time metrics visualization
- **Prometheus:** Metrics collection
- **Application Insights:** Azure integrated monitoring
- **DataDog:** Enterprise monitoring
- **New Relic:** APM and monitoring

## Load Test Results Documentation

### Standard Report Includes

1. **Executive Summary**
   - Test date and duration
   - Peak concurrent users
   - Overall pass/fail status

2. **Key Metrics**
   - Response time statistics (min, max, avg, p50, p95, p99)
   - Throughput (requests/sec)
   - Error rate and error types
   - Resource utilization (CPU, Memory, Disk)

3. **Scenario Results**
   - Per-scenario performance
   - Any threshold violations
   - Anomalies or unexpected behavior

4. **Analysis**
   - Bottleneck identification
   - Performance trends
   - Comparison to previous tests

5. **Recommendations**
   - Optimization opportunities
   - Configuration adjustments
   - Infrastructure scaling needs

## Baseline Metrics

### Initial Deployment (Single Instance)

Record baseline metrics for comparison:

```
Configuration: 
- 1 API instance (2 vCPU, 4GB RAM)
- 1 SQL Server instance (2 vCPU, 8GB RAM)

Scenario: 100 concurrent users, 2 minute duration
- Response Time p50: 89ms
- Response Time p95: 234ms
- Response Time p99: 456ms
- Error Rate: 0.02%
- Throughput: 85 requests/sec
- CPU (API): 42%
- Memory (API): 512MB
- Database Connections: 12/50
```

## Maintenance and Review

- **Monthly:** Review baselines against current performance
- **Quarterly:** Full regression load testing
- **Before Major Release:** Comprehensive load testing
- **After Infrastructure Changes:** Re-baseline metrics
- **Performance Regression:** Immediate investigation

## References

- [k6 Documentation](https://k6.io/docs/)
- [Apache JMeter](https://jmeter.apache.org/usermanual/)
- [Performance Testing Guide](https://www.perfmatrix.com/)
- [Load Testing Best Practices](https://www.thoughtworks.com/insights/blog/load-testing)
</file>

<file path="PROJECT_SUMMARY.md">
# DnD Map Builder - Complete Backend Solution

## 🎯 Project Overview

A full-featured ASP.NET Web API backend for the DnD Map Builder application, implementing user authentication, campaign management, mission planning, map creation, and token management.

## 📁 Solution Structure

```
DnDMapBuilder/
├── src/
│   ├── DnDMapBuilder.Contracts/          # DTOs, Requests, Responses
│   ├── DnDMapBuilder.Data/               # EF Core, Entities, Repositories
│   ├── DnDMapBuilder.Application/        # Business Logic & Services
│   ├── DnDMapBuilder.Api/                # Web API Controllers
│   ├── DnDMapBuilder.Aspire.AppHost/     # Aspire Orchestration
│   └── DnDMapBuilder.Aspire.ServiceDefaults/  # Aspire Service Defaults
├── DnDMapBuilder.sln                     # Solution file
├── docker-compose.yml                    # Docker Compose configuration
├── setup.sh                              # Quick setup script
├── README.md                             # Main documentation
├── API_DOCUMENTATION.md                  # Complete API reference
├── QUICKSTART.md                         # Quick start guide
└── .gitignore
```

## 🏗️ Architecture

### Clean Architecture Pattern

1. **Contracts Layer** (`DnDMapBuilder.Contracts`)
   - DTOs (Data Transfer Objects)
   - Request/Response models
   - API contracts
   - No dependencies on other layers

2. **Data Layer** (`DnDMapBuilder.Data`)
   - Entity Framework Core
   - Database entities
   - DbContext configuration
   - Repository pattern implementation
   - Database migrations

3. **Application Layer** (`DnDMapBuilder.Application`)
   - Business logic
   - Service implementations
   - Mapping extensions
   - JWT service
   - Depends on: Contracts, Data

4. **API Layer** (`DnDMapBuilder.Api`)
   - Controllers
   - Authentication/Authorization
   - Middleware
   - Swagger configuration
   - Depends on: Application, Contracts, Data

5. **Aspire Orchestration** (`DnDMapBuilder.Aspire.*`)
   - Container orchestration
   - Service discovery
   - Health checks
   - Telemetry

## 🔑 Key Features

### Authentication & Authorization
- JWT-based authentication
- Role-based authorization (Admin, User)
- User approval workflow
- Secure password hashing with BCrypt

### Campaign Management
- Create, read, update, delete campaigns
- User-owned campaigns
- Complete campaign hierarchy (Campaign → Mission → Map)

### Mission Management
- Organize missions within campaigns
- Mission descriptions and metadata
- Cascade delete with campaigns

### Map Builder
- Grid-based map system
- Custom map images
- Configurable grid (rows, columns, color, opacity)
- Token placement on maps

### Token Library
- User-specific token definitions
- Token types (player, enemy)
- Token sizes (1x1, 2x2, 3x3 grid squares)
- Image URL support

## 🗄️ Database Schema

### Users
- Id, Username, Email, PasswordHash
- Role (admin/user)
- Status (pending/approved/rejected)
- Timestamps

### Campaigns
- Id, Name, Description
- OwnerId → Users
- Timestamps

### Missions
- Id, Name, Description
- CampaignId → Campaigns

### GameMaps
- Id, Name, ImageUrl
- Rows, Cols, GridColor, GridOpacity
- MissionId → Missions

### TokenDefinitions
- Id, Name, ImageUrl, Size, Type
- UserId → Users

### MapTokenInstances
- Id, TokenId → TokenDefinitions
- MapId → GameMaps
- X, Y coordinates

## 🚀 Deployment Options

### Option 1: .NET Aspire (Recommended)
```bash
cd src/DnDMapBuilder.Aspire.AppHost
dotnet user-secrets set "Parameters:sql-password" "YourPassword"
dotnet run
```

**Advantages:**
- Automatic container orchestration
- Built-in service discovery
- Health monitoring dashboard
- Telemetry and logging
- Development-optimized

### Option 2: Docker Compose
```bash
docker-compose up --build
```

**Advantages:**
- Simple deployment
- Consistent environment
- Easy to share
- Production-ready

### Option 3: Direct Deployment
- Requires SQL Server instance
- Manual configuration
- More control over environment

## 🔐 Security Features

1. **JWT Authentication**
   - Secure token generation
   - Token expiration
   - Role-based claims

2. **Password Security**
   - BCrypt hashing
   - Salt per password
   - Secure password storage

3. **Authorization**
   - Role-based access control
   - User ownership validation
   - Admin-only endpoints

4. **API Security**
   - HTTPS support
   - CORS configuration
   - Input validation

## 📊 API Endpoints Summary

### Authentication (`/api/auth`)
- POST `/register` - Register new user
- POST `/login` - User login
- GET `/pending-users` - Get pending approvals (Admin)
- POST `/approve-user` - Approve/reject user (Admin)

### Campaigns (`/api/campaigns`)
- GET `/` - List user campaigns
- GET `/{id}` - Get campaign details
- POST `/` - Create campaign
- PUT `/{id}` - Update campaign
- DELETE `/{id}` - Delete campaign

### Missions (`/api/missions`)
- GET `/{id}` - Get mission
- GET `/campaign/{campaignId}` - List campaign missions
- POST `/` - Create mission
- PUT `/{id}` - Update mission
- DELETE `/{id}` - Delete mission

### Maps (`/api/maps`)
- GET `/{id}` - Get map with tokens
- GET `/mission/{missionId}` - List mission maps
- POST `/` - Create map
- PUT `/{id}` - Update map and tokens
- DELETE `/{id}` - Delete map

### Tokens (`/api/tokens`)
- GET `/` - List user tokens
- GET `/{id}` - Get token
- POST `/` - Create token
- PUT `/{id}` - Update token
- DELETE `/{id}` - Delete token

## 🛠️ Technology Stack

- **.NET 9.0** - Latest .NET framework
- **ASP.NET Core** - Web API framework
- **Entity Framework Core 9.0** - ORM
- **SQL Server 2022** - Database
- **JWT Bearer** - Authentication
- **BCrypt.Net** - Password hashing
- **Swagger/OpenAPI** - API documentation
- **.NET Aspire** - Cloud-native orchestration
- **Docker** - Containerization

## 📦 NuGet Packages

### API Project
- Microsoft.AspNetCore.Authentication.JwtBearer
- Microsoft.AspNetCore.OpenApi
- Swashbuckle.AspNetCore

### Application Project
- BCrypt.Net-Next
- System.IdentityModel.Tokens.Jwt

### Data Project
- Microsoft.EntityFrameworkCore
- Microsoft.EntityFrameworkCore.SqlServer
- Microsoft.EntityFrameworkCore.Tools

### Aspire Projects
- Aspire.Hosting.AppHost
- Aspire.Hosting.SqlServer
- OpenTelemetry packages

## 🎨 Design Patterns Used

1. **Repository Pattern** - Data access abstraction
2. **Service Layer Pattern** - Business logic separation
3. **Dependency Injection** - Loose coupling
4. **DTO Pattern** - Data transfer optimization
5. **Clean Architecture** - Layer separation
6. **Factory Pattern** - Object creation
7. **Strategy Pattern** - Service implementations

## 🔄 Data Flow

```
Client Request
    ↓
API Controller (Authentication/Authorization)
    ↓
Application Service (Business Logic)
    ↓
Repository (Data Access)
    ↓
Entity Framework Core
    ↓
SQL Server Database
    ↓
Response (via DTOs)
```

## 📝 Default Credentials

**Admin Account** (Pre-seeded):
- Email: `admin@dndmapbuilder.com`
- Password: `Admin123!`
- Role: `admin`
- Status: `approved`

## 🧪 Testing the API

### Using Swagger UI
1. Navigate to `https://localhost:5001/swagger`
2. Login to get a token
3. Click "Authorize" and enter: `Bearer <token>`
4. Test endpoints interactively

### Using cURL
```bash
# Login
curl -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@dndmapbuilder.com","password":"Admin123!"}'

# Create Campaign (replace <token>)
curl -X POST https://localhost:5001/api/campaigns \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","description":"Test campaign"}'
```

## 📈 Future Enhancements

Potential features to add:
- [ ] Real-time collaboration (SignalR)
- [ ] File upload for map images
- [ ] Export/import campaigns
- [ ] Campaign sharing between users
- [ ] Map templates
- [ ] Advanced token properties (HP, AC, etc.)
- [ ] Combat tracker
- [ ] Dice roller integration
- [ ] Character sheets
- [ ] Unit tests
- [ ] Integration tests
- [ ] Rate limiting
- [ ] API versioning
- [ ] GraphQL endpoint

## 📚 Documentation Files

1. **README.md** - Complete setup and overview
2. **API_DOCUMENTATION.md** - Full API reference
3. **QUICKSTART.md** - Fast setup guide
4. **setup.sh** - Automated setup script

## 🤝 Integration with Frontend

The React frontend can integrate with this API by:

1. **Authentication**
   ```typescript
   // Replace localStorage auth with API calls
   const login = async (email, password) => {
     const response = await fetch('https://api-url/api/auth/login', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({ email, password })
     });
     const { data } = await response.json();
     localStorage.setItem('token', data.token);
   };
   ```

2. **Data Fetching**
   ```typescript
   // Fetch campaigns
   const getCampaigns = async () => {
     const token = localStorage.getItem('token');
     const response = await fetch('https://api-url/api/campaigns', {
       headers: { 'Authorization': `Bearer ${token}` }
     });
     return await response.json();
   };
   ```

3. **Replace local storage state** with API-backed state management

## ✅ Production Checklist

Before deploying to production:

- [ ] Change JWT secret key
- [ ] Update SQL Server credentials
- [ ] Configure HTTPS certificates
- [ ] Set up proper CORS policy
- [ ] Enable rate limiting
- [ ] Configure logging (Application Insights, Serilog)
- [ ] Set up CI/CD pipeline
- [ ] Database backup strategy
- [ ] Monitoring and alerting
- [ ] Load balancing (if needed)
- [ ] CDN for static assets
- [ ] Security headers
- [ ] Input validation
- [ ] Error handling
- [ ] API documentation versioning

## 🎓 Learning Resources

To understand this codebase:
1. Review the clean architecture layers
2. Follow a request from Controller → Service → Repository → Database
3. Examine the entity relationships in DbContext
4. Study the JWT authentication flow
5. Explore the Aspire orchestration setup

## 📄 License

MIT License - Feel free to use and modify

---

**Created**: January 2026  
**.NET Version**: 9.0  
**Database**: SQL Server 2022  
**Architecture**: Clean Architecture with Repository Pattern
</file>

<file path="QUICKSTART.md">
# Quick Start Guide

## TL;DR - Fastest Way to Run

### Using .NET Aspire (Recommended)

```bash
# 1. Navigate to the project
cd DnDMapBuilder

# 2. Set SQL password
cd src/DnDMapBuilder.Aspire.AppHost
dotnet user-secrets set "Parameters:sql-password" "YourStrong@Passw0rd"

# 3. Run
dotnet run

# 4. Open the Aspire dashboard URL shown in console
# The API will be available at the URL shown for 'api' service
```

### Using Docker Compose

```bash
# From project root
docker-compose up --build
```

API available at: `http://localhost:5000`

### Using Direct API (Requires SQL Server)

```bash
# 1. Update connection string in src/DnDMapBuilder.Api/appsettings.json

# 2. Run migrations
cd src/DnDMapBuilder.Api
dotnet ef database update --project ../DnDMapBuilder.Data

# 3. Run API
dotnet run
```

## First Steps After Running

### 1. Access Swagger UI

Navigate to: `https://localhost:<port>/swagger`

### 2. Login as Admin

**Default Admin Credentials:**
- Email: `admin@dndmapbuilder.com`
- Password: `Admin123!`

### 3. Test the API

```bash
# Login
curl -X POST https://localhost:5001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@dndmapbuilder.com","password":"Admin123!"}'

# Copy the token from response

# Create a campaign
curl -X POST https://localhost:5001/api/campaigns \
  -H "Authorization: Bearer <your-token>" \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Campaign","description":"My first campaign"}'
```

## Common Issues

### Issue: Port already in use

**Solution:** Change the port in `launchSettings.json` or stop the service using that port.

### Issue: SQL Server connection failed

**Aspire:** Wait for SQL Server container to be healthy (check Aspire dashboard)

**Docker Compose:** Check `docker-compose logs sqlserver`

**Direct:** Verify SQL Server is running: `sqlcmd -S localhost -U sa -P <password> -Q "SELECT @@VERSION"`

### Issue: Database migrations not applied

```bash
cd src/DnDMapBuilder.Api
dotnet ef database update --project ../DnDMapBuilder.Data
```

## Project Structure Quick Reference

```
src/
├── DnDMapBuilder.Api/              ← API Controllers & Startup
│   ├── Controllers/                ← REST endpoints
│   ├── Program.cs                  ← Application entry point
│   └── appsettings.json           ← Configuration
├── DnDMapBuilder.Application/      ← Business logic
│   ├── Services/                   ← Service implementations
│   └── Interfaces/                 ← Service contracts
├── DnDMapBuilder.Contracts/        ← DTOs & Models
│   ├── DTOs/                       ← Data transfer objects
│   ├── Requests/                   ← Request models
│   └── Responses/                  ← Response models
├── DnDMapBuilder.Data/             ← Data access
│   ├── Entities/                   ← Database entities
│   ├── Repositories/               ← Data repositories
│   └── DnDMapBuilderDbContext.cs  ← EF Core context
└── DnDMapBuilder.Aspire.AppHost/   ← Orchestration
    └── Program.cs                  ← Aspire configuration
```

## Next Steps

1. **Register a new user** via `/api/auth/register`
2. **Approve the user** as admin via `/api/auth/approve-user`
3. **Create campaigns, missions, and maps** using the authenticated user
4. **Define custom tokens** for your maps
5. **Build maps** and place tokens

## Useful Commands

```bash
# Restore dependencies
dotnet restore

# Build solution
dotnet build

# Run migrations
dotnet ef migrations add <name> --project src/DnDMapBuilder.Data

# Update database
dotnet ef database update --project src/DnDMapBuilder.Data

# Clean build artifacts
dotnet clean

# Watch for changes and auto-rebuild
dotnet watch run --project src/DnDMapBuilder.Api
```

## Environment Variables

When not using Aspire, you can override settings with environment variables:

```bash
export ConnectionStrings__DefaultConnection="Server=...;Database=...;"
export JwtSettings__SecretKey="your-secret-key"
export ASPNETCORE_ENVIRONMENT="Development"
```

## Testing with Postman

1. Import the API into Postman using the Swagger JSON: `https://localhost:5001/swagger/v1/swagger.json`
2. Set up an environment variable for the token
3. Use `{{token}}` in the Authorization header

## Production Checklist

Before deploying to production:

- [ ] Change JWT SecretKey in appsettings.json
- [ ] Update SQL Server password
- [ ] Configure proper CORS policy
- [ ] Enable HTTPS
- [ ] Set up proper logging
- [ ] Configure rate limiting
- [ ] Review and update default admin credentials
- [ ] Set up database backups
- [ ] Configure monitoring
- [ ] Review security headers

## Support

For issues or questions:
1. Check the full README.md
2. Review API_DOCUMENTATION.md
3. Check application logs
4. Review Aspire dashboard for container health
</file>

<file path="SMOKE_TESTS.md">
# Smoke Testing Guide

## Overview

Smoke tests are quick, automated tests that verify critical application functionality immediately after deployment. They're the first validation that the application is operational.

## Smoke Test Objectives

✓ Verify application startup and health endpoints
✓ Validate core authentication flow
✓ Ensure database connectivity
✓ Test CRUD operations for each entity
✓ Verify file upload functionality
✓ Confirm telemetry collection
✓ Validate security headers

## Test Environment

### Required Setup

```bash
# Environment variables
export API_URL="http://localhost:5000"
export API_USERNAME="smoketest@example.com"
export API_PASSWORD="SmokeTestPassword123!"
export TEST_ADMIN_USERNAME="admin@example.com"
export TEST_ADMIN_PASSWORD="AdminPassword123!"
```

## Smoke Test Scenarios

### 1. Application Health Check

**Test:** Verify application is running and healthy

```bash
#!/bin/bash

echo "Testing health endpoints..."

# Health endpoint (no auth required)
echo "1. GET /health"
curl -s -w "\nStatus: %{http_code}\n" http://localhost:5000/health | jq .

# Ready endpoint
echo "2. GET /health/ready"
curl -s -w "\nStatus: %{http_code}\n" http://localhost:5000/health/ready | jq .

# Live endpoint
echo "3. GET /health/live"
curl -s -w "\nStatus: %{http_code}\n" http://localhost:5000/health/live | jq .

echo "✓ Health checks complete"
```

### 2. Authentication Flow

**Test:** Verify user registration and login

```bash
#!/bin/bash

echo "Testing authentication flow..."

# Register new user
echo "1. POST /auth/register"
REGISTER_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "smoketest_'$(date +%s)'",
    "email": "smoketest_'$(date +%s)'@example.com",
    "password": "SmokeTest123!"
  }')

echo $REGISTER_RESPONSE | jq .

USER_ID=$(echo $REGISTER_RESPONSE | jq -r '.data.id')
echo "Created user: $USER_ID"

# Login as admin and approve user
echo "2. POST /auth/login (Admin)"
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "'$TEST_ADMIN_USERNAME'",
    "password": "'$TEST_ADMIN_PASSWORD'"
  }')

ADMIN_TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.data.token')
echo "Admin token: ${ADMIN_TOKEN:0:20}..."

# Approve user
echo "3. POST /auth/approve-user"
curl -s -X POST http://localhost:5000/api/v1/auth/approve-user \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"userId": "'$USER_ID'", "approved": true}' | jq .

# Login as new user
echo "4. POST /auth/login (New User)"
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "smoketest_'$(date +%s)'@example.com",
    "password": "SmokeTest123!"
  }')

TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.data.token')
echo "User token: ${TOKEN:0:20}..."

echo "✓ Authentication flow complete"
```

### 3. Campaign CRUD Operations

**Test:** Create, read, update, and delete campaigns

```bash
#!/bin/bash

echo "Testing Campaign CRUD..."

# CREATE
echo "1. POST /campaigns (Create)"
CREATE_RESPONSE=$(curl -s -X POST http://localhost:5000/api/v1/campaigns \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Smoke Test Campaign",
    "description": "Campaign for smoke testing"
  }')

CAMPAIGN_ID=$(echo $CREATE_RESPONSE | jq -r '.data.id')
echo "Created campaign: $CAMPAIGN_ID"

# READ
echo "2. GET /campaigns/{id} (Read)"
curl -s -H "Authorization: Bearer $TOKEN" \
  http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID | jq .

# UPDATE
echo "3. PUT /campaigns/{id} (Update)"
curl -s -X PUT http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Updated Campaign Name",
    "description": "Updated description"
  }' | jq .

# LIST
echo "4. GET /campaigns (List)"
curl -s -H "Authorization: Bearer $TOKEN" \
  http://localhost:5000/api/v1/campaigns | jq .

# DELETE
echo "5. DELETE /campaigns/{id} (Delete)"
curl -s -X DELETE http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID \
  -H "Authorization: Bearer $TOKEN" | jq .

echo "✓ Campaign CRUD complete"
```

### 4. Mission Operations

**Test:** Create mission and verify relationships

```bash
#!/bin/bash

echo "Testing Mission operations..."

# Create campaign first
CAMPAIGN=$(curl -s -X POST http://localhost:5000/api/v1/campaigns \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name": "Mission Test", "description": "Test"}')

CAMPAIGN_ID=$(echo $CAMPAIGN | jq -r '.data.id')

# Create mission
echo "1. POST /missions (Create)"
MISSION=$(curl -s -X POST http://localhost:5000/api/v1/missions \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "campaignId": "'$CAMPAIGN_ID'",
    "name": "Test Mission",
    "description": "Mission for smoke testing"
  }')

MISSION_ID=$(echo $MISSION | jq -r '.data.id')
echo "Created mission: $MISSION_ID"

# Get mission
echo "2. GET /missions/{id}"
curl -s -H "Authorization: Bearer $TOKEN" \
  http://localhost:5000/api/v1/missions/$MISSION_ID | jq .

echo "✓ Mission operations complete"
```

### 5. Authorization Verification

**Test:** Verify authorization enforcement

```bash
#!/bin/bash

echo "Testing authorization..."

# Create different user
ANOTHER_USER=$(curl -s -X POST http://localhost:5000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "another_'$(date +%s)'",
    "email": "another_'$(date +%s)'@example.com",
    "password": "AnotherUser123!"
  }')

ANOTHER_USER_ID=$(echo $ANOTHER_USER | jq -r '.data.id')

# Approve other user
curl -s -X POST http://localhost:5000/api/v1/auth/approve-user \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"userId": "'$ANOTHER_USER_ID'", "approved": true}' > /dev/null

# Login as other user
ANOTHER_TOKEN=$(curl -s -X POST http://localhost:5000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "another_'$(date +%s)'@example.com",
    "password": "AnotherUser123!"
  }' | jq -r '.data.token')

# Try to access another user's campaign (should fail)
echo "1. Attempting unauthorized access (should get 404/403)"
curl -s -w "\nStatus: %{http_code}\n" -H "Authorization: Bearer $ANOTHER_TOKEN" \
  http://localhost:5000/api/v1/campaigns/$CAMPAIGN_ID | jq .

echo "✓ Authorization verification complete"
```

### 6. Rate Limiting Test

**Test:** Verify rate limiting is active

```bash
#!/bin/bash

echo "Testing rate limiting..."

# Make rapid requests
echo "1. Making 15 rapid requests (limit is 10/min for anonymous)"
for i in {1..15}; do
  STATUS=$(curl -s -w "%{http_code}" -o /dev/null http://localhost:5000/health)
  echo "Request $i: HTTP $STATUS"
  if [ "$STATUS" = "429" ]; then
    echo "✓ Rate limit hit at request $i (expected)"
    break
  fi
done

echo "✓ Rate limiting test complete"
```

### 7. Security Headers Verification

**Test:** Verify security headers are present

```bash
#!/bin/bash

echo "Testing security headers..."

# Get response headers
curl -s -i http://localhost:5000/health | grep -i "X-" | head -10

echo "Expected headers:"
echo "- X-Content-Type-Options: nosniff"
echo "- X-Frame-Options: DENY"
echo "- X-XSS-Protection: 1; mode=block"
echo "- Strict-Transport-Security"
echo "- Content-Security-Policy"

echo "✓ Security headers verification complete"
```

### 8. Telemetry Collection

**Test:** Verify telemetry is being collected

```bash
#!/bin/bash

echo "Testing telemetry collection..."

# Check OpenTelemetry metrics endpoint (if configured)
echo "1. Checking metrics endpoint"
curl -s http://localhost:5000/metrics | head -20

# Check application logs contain request/response data
echo "2. Checking logs for structured logging"
docker logs dnd-api | grep -i "request\|response" | head -5

echo "✓ Telemetry collection verification complete"
```

## Automated Smoke Test Suite

### shell Script

Create `scripts/smoke_tests.sh`:

```bash
#!/bin/bash

set -e

API_URL="${1:-http://localhost:5000}"
FAILED=0
PASSED=0

test_endpoint() {
  local method=$1
  local endpoint=$2
  local expected_status=$3
  local data=$4
  
  echo -n "Testing $method $endpoint... "
  
  if [ -z "$data" ]; then
    STATUS=$(curl -s -w "%{http_code}" -o /dev/null -X $method $API_URL$endpoint)
  else
    STATUS=$(curl -s -w "%{http_code}" -o /dev/null -X $method $API_URL$endpoint \
      -H "Content-Type: application/json" \
      -d "$data")
  fi
  
  if [ "$STATUS" = "$expected_status" ] || [ "$STATUS" = "200" ]; then
    echo "✓ ($STATUS)"
    ((PASSED++))
  else
    echo "✗ (Expected $expected_status, got $STATUS)"
    ((FAILED++))
  fi
}

# Run tests
echo "Running Smoke Tests for $API_URL"
echo "=================================="

test_endpoint "GET" "/health" "200"
test_endpoint "GET" "/health/ready" "200"
test_endpoint "GET" "/health/live" "200"

echo "=================================="
echo "Results: $PASSED passed, $FAILED failed"

if [ $FAILED -gt 0 ]; then
  exit 1
fi
```

### k6 Script

Create `scripts/smoke_tests.js`:

```javascript
import http from 'k6/http';
import { check } from 'k6';

const API_URL = 'http://localhost:5000';

export let options = {
  vus: 1,
  duration: '1m',
  thresholds: {
    http_req_failed: ['rate<0.1'],
  },
};

export default function() {
  // Test health endpoints
  let res = http.get(`${API_URL}/health`);
  check(res, {
    'health status is 200': (r) => r.status === 200,
  });

  res = http.get(`${API_URL}/health/ready`);
  check(res, {
    'health ready status is 200': (r) => r.status === 200,
  });

  res = http.get(`${API_URL}/health/live`);
  check(res, {
    'health live status is 200': (r) => r.status === 200,
  });

  // Test auth endpoint
  res = http.post(`${API_URL}/api/v1/auth/login`, JSON.stringify({
    email: 'test@example.com',
    password: 'TestPassword123!',
  }), {
    headers: { 'Content-Type': 'application/json' },
  });

  check(res, {
    'login response received': (r) => r.status === 200 || r.status === 401,
  });
}
```

## Running Smoke Tests

```bash
# Run shell script
./scripts/smoke_tests.sh http://localhost:5000

# Run k6 script
k6 run scripts/smoke_tests.js

# Run in CI/CD
./scripts/smoke_tests.sh https://api.production.com
```

## Success Criteria

All smoke tests must pass:
- [ ] Health endpoints return 200 OK
- [ ] Authentication flow works (register → approve → login)
- [ ] CRUD operations functional
- [ ] Authorization enforced
- [ ] Rate limiting active
- [ ] Security headers present
- [ ] No 5xx errors in logs
- [ ] Telemetry collection active

## Post-Deployment Verification Checklist

- [ ] Application responding to requests
- [ ] Database connectivity verified
- [ ] Authentication working
- [ ] Authorization working
- [ ] Rate limiting active
- [ ] Security headers present
- [ ] Telemetry flowing
- [ ] No critical errors in logs
- [ ] Performance acceptable
- [ ] All smoke tests passing

## Troubleshooting

### Connection Refused
- Verify API is running: `docker ps`
- Check port: `netstat -an | grep 5000`
- Review startup logs: `docker logs dnd-api`

### Authentication Failed
- Verify user exists and is approved
- Check JWT configuration
- Review auth logs

### Health Check Failed
- Check database connection
- Verify configuration
- Review startup logs

### Rate Limiting Not Working
- Verify rate limiting middleware is configured
- Check configuration values
- Verify rate limiting policy applied
</file>

<file path="STRUCTURE_DIAGRAM.md">
# Visual Structure

```
DnDMapBuilder/
│
├── 📄 DnDMapBuilder.sln
├── 📄 .gitignore
├── 🐳 docker-compose.yml
├── 🔧 setup.sh
├── 🔧 verify-structure.sh
│
├── 📚 Documentation
│   ├── 📖 README.md
│   ├── 📖 QUICKSTART.md
│   ├── 📖 API_DOCUMENTATION.md
│   ├── 📖 PROJECT_SUMMARY.md
│   └── 📖 FILE_STRUCTURE.md
│
└── 📁 src/
    │
    ├── 📦 DnDMapBuilder.Contracts/
    │   ├── 📄 DnDMapBuilder.Contracts.csproj
    │   ├── 📁 DTOs/
    │   │   └── 📝 DomainDtos.cs
    │   ├── 📁 Requests/
    │   │   └── 📝 ApiRequests.cs
    │   └── 📁 Responses/
    │       └── 📝 ApiResponses.cs
    │
    ├── 📦 DnDMapBuilder.Data/
    │   ├── 📄 DnDMapBuilder.Data.csproj
    │   ├── 📝 DnDMapBuilderDbContext.cs
    │   ├── 📁 Entities/
    │   │   └── 📝 DomainEntities.cs
    │   └── 📁 Repositories/
    │       ├── 📝 IRepositories.cs
    │       └── 📝 Repositories.cs
    │
    ├── 📦 DnDMapBuilder.Application/
    │   ├── 📄 DnDMapBuilder.Application.csproj
    │   ├── 📁 Interfaces/
    │   │   └── 📝 IServices.cs
    │   ├── 📁 Mappings/
    │   │   └── 📝 MappingExtensions.cs
    │   └── 📁 Services/
    │       ├── 📝 AuthService.cs
    │       ├── 📝 JwtService.cs
    │       ├── 📝 CampaignService.cs
    │       ├── 📝 MissionService.cs
    │       └── 📝 GameMapAndTokenServices.cs
    │
    ├── 📦 DnDMapBuilder.Api/
    │   ├── 📄 DnDMapBuilder.Api.csproj
    │   ├── 📝 Program.cs
    │   ├── 🐳 Dockerfile
    │   ├── ⚙️ appsettings.json
    │   ├── ⚙️ appsettings.Development.json
    │   ├── 📁 Controllers/
    │   │   ├── 📝 AuthController.cs
    │   │   ├── 📝 CampaignsController.cs
    │   │   └── 📝 OtherControllers.cs
    │   └── 📁 Properties/
    │       └── ⚙️ launchSettings.json
    │
    ├── 📦 DnDMapBuilder.Aspire.AppHost/
    │   ├── 📄 DnDMapBuilder.Aspire.AppHost.csproj
    │   └── 📝 Program.cs
    │
    └── 📦 DnDMapBuilder.Aspire.ServiceDefaults/
        ├── 📄 DnDMapBuilder.Aspire.ServiceDefaults.csproj
        └── 📝 Extensions.cs
```

## Legend

- 📄 Project/Solution Files (.csproj, .sln)
- 📝 C# Source Files (.cs)
- 📖 Documentation (.md)
- ⚙️ Configuration (.json)
- 🐳 Docker Files
- 🔧 Scripts (.sh)
- 📦 Project Folders
- 📁 Code Organization Folders
- 📚 Documentation Section

## Statistics

- **Total Projects**: 6
- **Total C# Files**: 20
- **Total Lines of Code**: ~2,500
- **Total Documentation Files**: 5
- **Total Configuration Files**: 4
- **Total Scripts**: 2

## Quick Access

| What You Need | Where to Find It |
|---------------|------------------|
| Start the app | `setup.sh` or `docker-compose.yml` |
| API endpoints | `src/DnDMapBuilder.Api/Controllers/` |
| Database setup | `src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs` |
| Business logic | `src/DnDMapBuilder.Application/Services/` |
| API contracts | `src/DnDMapBuilder.Contracts/` |
| Configuration | `src/DnDMapBuilder.Api/appsettings.json` |
| Documentation | Root `*.md` files |
</file>

<file path="WORKFLOW_SETUP.md">
# Backend CI/CD Workflow Setup Instructions

## Overview
This setup implements a multi-environment deployment strategy:
- **Feature branches** → PR to develop (runs tests only)
- **develop branch** → Development environment deployment
- **main branch** → Production environment deployment
- **Protected branches** → No direct pushes allowed

## Required GitHub Secrets

### Development Environment Secrets
Add these secrets to your GitHub repository (Settings → Secrets and Variables → Actions):

```
DEV_SERVER_HOST              # Development server IP/hostname
DEV_SERVER_USERNAME          # SSH username for dev server
DEV_SSH_PRIVATE_KEY          # SSH private key for dev server
DEV_SERVER_PORT              # SSH port (optional, defaults to 22)
DEV_DB_CONNECTION_STRING     # Development database connection string
```

### Production Environment Secrets
```
PROD_SERVER_HOST             # Production server IP/hostname
PROD_SERVER_USERNAME         # SSH username for prod server
PROD_SSH_PRIVATE_KEY         # SSH private key for prod server
PROD_SERVER_PORT             # SSH port (optional, defaults to 22)
PROD_DB_CONNECTION_STRING    # Production database connection string
```

## Workflow File

Replace the contents of `.github/workflows/main.yml` with the example below.

The workflow includes:
1. **build-and-test** - Runs on all PRs and pushes (no deployment)
2. **build-docker** - Builds Docker image only on pushes to develop/main
3. **deploy-dev** - Deploys to development when commits pushed to develop
4. **deploy-prod** - Deploys to production when commits pushed to main

Each deployment job:
- Uses environment-specific secrets
- Runs database migrations
- Deploys to a separate container instance
- Verifies health checks before completion

## Setup Steps

### 1. Add GitHub Secrets

Go to: Repository → Settings → Secrets and Variables → Actions → New repository secret

Add each secret listed above with values from your actual servers.

### 2. Update Workflow File

Copy the contents of `backend-main-example.yml` to `.github/workflows/main.yml`:

```bash
cp backend-main-example.yml .github/workflows/main.yml
```

### 3. Protect Main and Develop Branches

Go to: Repository → Settings → Branches → Add branch protection rule

**For `main` branch:**
- ✅ Require pull request reviews before merging
- ✅ Require status checks to pass before merging
  - Select `build-and-test`
  - Select `build-docker`
  - Select `deploy-prod` (production environment)
- ✅ Require branches to be up to date before merging
- ✅ Include administrators
- ✅ Restrict who can push to matching branches (only releases if used)

**For `develop` branch:**
- ✅ Require pull request reviews before merging
- ✅ Require status checks to pass before merging
  - Select `build-and-test`
  - Select `build-docker`
  - Select `deploy-dev` (development environment)
- ✅ Require branches to be up to date before merging
- ✅ Include administrators
- ✅ Restrict who can push to matching branches

### 4. Create .gitignore Exception (Optional)

If you want to keep the example files in version control for reference:

```bash
# .gitignore
# Keep workflow examples for reference
!backend-main-example.yml
```

## Workflow Behavior

### When developing a feature:
1. Create feature branch from `develop`
2. Push commits and create PR to `develop`
3. CI runs: build-and-test only (no deployment)
4. After review, merge to `develop`
5. CI runs: build-and-test, build-docker, deploy-dev (development deployment)

### When releasing to production:
1. Create PR from `develop` to `main`
2. CI runs: build-and-test only (no deployment)
3. After review, merge to `main`
4. CI runs: build-and-test, build-docker, deploy-prod (production deployment)

## Container Naming

- Development: `dnd-api-dev` (ports 5000-5001)
- Production: `dnd-api` (ports 5000-5001)

## Environment Variables

Docker containers are deployed with:
- **Development**: `ASPNETCORE_ENVIRONMENT=Development`
- **Production**: `ASPNETCORE_ENVIRONMENT=Production`

## Monitoring Deployments

Check workflow runs in: Repository → Actions

Each deployment shows:
- Build and test results
- Docker image build and push
- SSH deployment commands
- Health check verification
- Container logs

## Troubleshooting

**Deployment fails with "Host key verification failed":**
- Ensure the SSH private key is properly formatted (including newlines)
- The host must be in the SSH known_hosts file or the key must be added correctly

**Docker login fails:**
- Verify `GITHUB_TOKEN` has necessary permissions
- Check if `secrets.GITHUB_TOKEN` is automatically provided (it is in GitHub Actions)

**Database migrations fail:**
- Verify connection string is correct
- Ensure the database server is accessible from the deployment server
- Check Entity Framework migration files exist

**Health check timeouts:**
- May need to increase wait time if initial startup is slow
- Check container logs in the verification step

## Future Enhancement: Staging Environment

When ready to add a staging environment (release branch):

1. Create branch protection rule for `release` branch
2. Add staging secrets: `STAGING_SERVER_HOST`, `STAGING_SERVER_USERNAME`, etc.
3. Add `deploy-staging` job triggered on commits to `release` branch
4. Update branch protection rules accordingly
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(move \"DnDMapBuilder.Aspire.ServiceDefaults.csproj\" \"src\\DnDMapBuilder.Aspire.ServiceDefaults\"\" && move \"Extensions.cs\" \"srcDnDMapBuilder.Aspire.ServiceDefaults\"\")",
      "Bash(git -C /Users/mikedeiktakis/RiderProjects/DnDMapbuilder-Api show:*)",
      "Bash(dotnet build:*)",
      "Bash(dotnet workload list:*)",
      "Bash(dotnet workload install:*)",
      "Bash(dotnet ef migrations:*)",
      "Bash(dotnet tool install:*)",
      "Bash(dotnet tool update:*)",
      "Bash(export PATH=\"$PATH:/Users/mikedeiktakis/.dotnet/tools\")",
      "Bash(docker ps:*)",
      "Bash(git checkout:*)",
      "Bash(dotnet test:*)",
      "Bash(tree:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(ls:*)",
      "Bash(repomix:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="src/DnDMapBuilder.AppHost/AppHost.cs">
var builder = DistributedApplication.CreateBuilder(args);
builder.Configuration["RunSession:UseIdeRunSession"] = "false";
var sql = builder.AddSqlServer("Database")
    .WithLifetime(ContainerLifetime.Persistent)
    .AddDatabase("dndmapbuilder");
builder.AddProject<Projects.DnDMapBuilder_Api>("dndmapapi")
    .WithReference(sql)
    .WithEnvironment("ConnectionStrings__DefaultConnection", sql)
    .WaitFor(sql)
    .WithEnvironment("ADMIN_EMAIL", "admin@test.com")
    .WithEnvironment("ADMIN_DEFAULT_PASSWORD", "1234")
    .WithEnvironment("MIGRATIONS_EXECUTE", "true");
builder.Build().Run();
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IAuthService.cs">
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
namespace DnDMapBuilder.Application.Interfaces;
public interface IAuthService
{
    Task<AuthResponse?> LoginAsync(LoginRequest request, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Interfaces/IUserManagementService.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
namespace DnDMapBuilder.Application.Interfaces;
public interface IUserManagementService
{
    Task<UserDto?> RegisterAsync(RegisterRequest request, CancellationToken cancellationToken = default);
    Task<bool> ApproveUserAsync(string userId, bool approved, CancellationToken cancellationToken = default);
    Task<IEnumerable<UserDto>> GetPendingUsersAsync(CancellationToken cancellationToken = default);
    Task<IEnumerable<UserDto>> GetActiveUsersAsync(CancellationToken cancellationToken = default);
    Task<bool> DeleteUserAsync(string userId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Application/Services/FileStorageService.cs">
using Microsoft.Extensions.Logging;
using DnDMapBuilder.Application.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class LocalFileStorageService : IFileStorageService
{
    private readonly string _baseStoragePath;
    private readonly string _basePublicUrl;
    private readonly ILogger<LocalFileStorageService> _logger;
    public LocalFileStorageService(string baseStoragePath, string basePublicUrl, ILogger<LocalFileStorageService> logger)
    {
        _baseStoragePath = baseStoragePath ?? throw new ArgumentNullException(nameof(baseStoragePath));
        _basePublicUrl = basePublicUrl ?? throw new ArgumentNullException(nameof(basePublicUrl));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        EnsureStorageDirectoriesExist();
    }
    public async Task<string> UploadAsync(Stream file, string fileName, string contentType, string storageCategory, CancellationToken cancellationToken = default)
    {
        if (file == null || file.Length == 0)
            throw new ArgumentException("File stream is empty", nameof(file));
        if (string.IsNullOrWhiteSpace(fileName))
            throw new ArgumentException("File name is required", nameof(fileName));
        if (string.IsNullOrWhiteSpace(contentType))
            throw new ArgumentException("Content type is required", nameof(contentType));
        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));
        var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
        if (!allowedMimeTypes.Contains(contentType.ToLower()))
            throw new InvalidOperationException($"MIME type '{contentType}' is not allowed");
        var fileExtension = Path.GetExtension(fileName);
        if (string.IsNullOrWhiteSpace(fileExtension))
            fileExtension = GetExtensionFromMimeType(contentType);
        var fileId = $"{Guid.NewGuid()}{fileExtension}";
        var categoryPath = Path.Combine(_baseStoragePath, storageCategory);
        var fullFilePath = Path.Combine(categoryPath, fileId);
        if (!Directory.Exists(categoryPath))
            Directory.CreateDirectory(categoryPath);
        try
        {
            using (var fileStream = new FileStream(fullFilePath, FileMode.Create, FileAccess.Write, FileShare.None, 4096, useAsync: true))
            {
                await file.CopyToAsync(fileStream, cancellationToken);
            }
            _logger.LogInformation($"File uploaded successfully: {fileId} to category {storageCategory}");
            return fileId;
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error uploading file: {ex.Message}");
            if (File.Exists(fullFilePath))
                File.Delete(fullFilePath);
            throw;
        }
    }
    public string GetPublicUrl(string fileId, string storageCategory)
    {
        if (string.IsNullOrWhiteSpace(fileId))
            throw new ArgumentException("File ID is required", nameof(fileId));
        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));
        if (fileId.Contains("..") || fileId.Contains("/") || fileId.Contains("\\"))
            throw new InvalidOperationException("Invalid file ID");
        return $"{_basePublicUrl}/{storageCategory}/{fileId}";
    }
    public async Task<bool> DeleteAsync(string fileId, string storageCategory, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(fileId))
            throw new ArgumentException("File ID is required", nameof(fileId));
        if (string.IsNullOrWhiteSpace(storageCategory))
            throw new ArgumentException("Storage category is required", nameof(storageCategory));
        if (fileId.Contains("..") || fileId.Contains("/") || fileId.Contains("\\"))
            throw new InvalidOperationException("Invalid file ID");
        var categoryPath = Path.Combine(_baseStoragePath, storageCategory);
        var fullFilePath = Path.Combine(categoryPath, fileId);
        try
        {
            if (File.Exists(fullFilePath))
            {
                File.Delete(fullFilePath);
                _logger.LogInformation($"File deleted successfully: {fileId} from category {storageCategory}");
                return true;
            }
            _logger.LogWarning($"File not found for deletion: {fileId} in category {storageCategory}");
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError($"Error deleting file: {ex.Message}");
            throw;
        }
    }
    private void EnsureStorageDirectoriesExist()
    {
        var categories = new[] { "maps", "tokens" };
        foreach (var category in categories)
        {
            var categoryPath = Path.Combine(_baseStoragePath, category);
            if (!Directory.Exists(categoryPath))
                Directory.CreateDirectory(categoryPath);
        }
    }
    private string GetExtensionFromMimeType(string mimeType)
    {
        return mimeType.ToLower() switch
        {
            "image/png" => ".png",
            "image/jpeg" => ".jpg",
            "image/webp" => ".webp",
            _ => ".bin"
        };
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/GoogleOAuthService.cs">
using System.Text.Json;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
namespace DnDMapBuilder.Application.Services;
public class GoogleOAuthService
{
    private readonly HttpClient _httpClient;
    private readonly OAuthSettings _settings;
    private readonly ILogger<GoogleOAuthService> _logger;
    private const string TokenInfoEndpoint = "https://oauth2.googleapis.com/tokeninfo";
    private const string UserInfoEndpoint = "https://www.googleapis.com/oauth2/v3/userinfo";
    private const string TokenEndpoint = "https://oauth2.googleapis.com/token";
    private const string AuthEndpoint = "https://accounts.google.com/o/oauth2/v2/auth";
    public GoogleOAuthService(
        HttpClient httpClient,
        IOptions<OAuthSettings> settings,
        ILogger<GoogleOAuthService> logger)
    {
        _httpClient = httpClient;
        _settings = settings.Value;
        _logger = logger;
    }
    public string GetAuthorizationUrl(string redirectUri, string state)
    {
        var scopes = Uri.EscapeDataString("openid email profile");
        return $"{AuthEndpoint}?client_id={_settings.Google.ClientId}&redirect_uri={Uri.EscapeDataString(redirectUri)}&response_type=code&scope={scopes}&state={state}&access_type=offline&prompt=consent";
    }
    public async Task<GoogleTokenResponse?> ExchangeCodeForTokensAsync(string code, string redirectUri)
    {
        var content = new FormUrlEncodedContent(new Dictionary<string, string>
        {
            ["code"] = code,
            ["client_id"] = _settings.Google.ClientId,
            ["client_secret"] = _settings.Google.ClientSecret,
            ["redirect_uri"] = redirectUri,
            ["grant_type"] = "authorization_code"
        });
        var response = await _httpClient.PostAsync(TokenEndpoint, content);
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to exchange Google auth code: {Status}", response.StatusCode);
            return null;
        }
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<GoogleTokenResponse>(json);
    }
    public async Task<GoogleUserInfo?> ValidateIdTokenAsync(string idToken)
    {
        var response = await _httpClient.GetAsync($"{TokenInfoEndpoint}?id_token={idToken}");
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to validate Google ID token: {Status}", response.StatusCode);
            return null;
        }
        var json = await response.Content.ReadAsStringAsync();
        var tokenInfo = JsonSerializer.Deserialize<GoogleTokenInfo>(json);
        if (tokenInfo?.Aud != _settings.Google.ClientId)
        {
            _logger.LogError("Google ID token audience mismatch");
            return null;
        }
        return new GoogleUserInfo
        {
            Id = tokenInfo.Sub,
            Email = tokenInfo.Email,
            EmailVerified = tokenInfo.EmailVerified,
            Name = tokenInfo.Name,
            Picture = tokenInfo.Picture
        };
    }
    public async Task<GoogleUserInfo?> GetUserInfoAsync(string accessToken)
    {
        _httpClient.DefaultRequestHeaders.Authorization =
            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);
        var response = await _httpClient.GetAsync(UserInfoEndpoint);
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to get Google user info: {Status}", response.StatusCode);
            return null;
        }
        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<GoogleUserInfo>(json);
    }
}
public class GoogleTokenResponse
{
    [System.Text.Json.Serialization.JsonPropertyName("access_token")]
    public string AccessToken { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("id_token")]
    public string IdToken { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("refresh_token")]
    public string? RefreshToken { get; set; }
    [System.Text.Json.Serialization.JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }
}
public class GoogleTokenInfo
{
    [System.Text.Json.Serialization.JsonPropertyName("sub")]
    public string Sub { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("email")]
    public string Email { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("email_verified")]
    [System.Text.Json.Serialization.JsonConverter(typeof(StringBooleanConverter))]
    public bool EmailVerified { get; set; }
    [System.Text.Json.Serialization.JsonPropertyName("name")]
    public string? Name { get; set; }
    [System.Text.Json.Serialization.JsonPropertyName("picture")]
    public string? Picture { get; set; }
    [System.Text.Json.Serialization.JsonPropertyName("aud")]
    public string Aud { get; set; } = string.Empty;
}
public class GoogleUserInfo
{
    [System.Text.Json.Serialization.JsonPropertyName("sub")]
    public string Id { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("email")]
    public string Email { get; set; } = string.Empty;
    [System.Text.Json.Serialization.JsonPropertyName("email_verified")]
    [System.Text.Json.Serialization.JsonConverter(typeof(StringBooleanConverter))]
    public bool EmailVerified { get; set; }
    [System.Text.Json.Serialization.JsonPropertyName("name")]
    public string? Name { get; set; }
    [System.Text.Json.Serialization.JsonPropertyName("picture")]
    public string? Picture { get; set; }
}
public class StringBooleanConverter : System.Text.Json.Serialization.JsonConverter<bool>
{
    public override bool Read(ref System.Text.Json.Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == System.Text.Json.JsonTokenType.True || reader.TokenType == System.Text.Json.JsonTokenType.False)
        {
            return reader.GetBoolean();
        }
        if (reader.TokenType == System.Text.Json.JsonTokenType.String)
        {
            var stringValue = reader.GetString();
            return stringValue?.ToLowerInvariant() == "true";
        }
        throw new JsonException($"Unable to convert '{reader.GetString()}' to boolean");
    }
    public override void Write(System.Text.Json.Utf8JsonWriter writer, bool value, JsonSerializerOptions options)
    {
        writer.WriteBooleanValue(value);
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/UserManagementService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class UserManagementService : IUserManagementService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordService _passwordService;
    public UserManagementService(IUserRepository userRepository, IPasswordService passwordService)
    {
        _userRepository = userRepository;
        _passwordService = passwordService;
    }
    public async Task<UserDto?> RegisterAsync(RegisterRequest request, CancellationToken cancellationToken = default)
    {
        var existingUser = await _userRepository.GetByEmailAsync(request.Email, cancellationToken);
        if (existingUser != null)
        {
            return null;
        }
        var existingUsername = await _userRepository.GetByUsernameAsync(request.Username, cancellationToken);
        if (existingUsername != null)
        {
            return null;
        }
        var user = new User
        {
            Id = Guid.NewGuid().ToString(),
            Username = request.Username,
            Email = request.Email,
            PasswordHash = _passwordService.HashPassword(request.Password),
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        await _userRepository.AddAsync(user, cancellationToken);
        return user.ToDto();
    }
    public async Task<bool> ApproveUserAsync(string userId, bool approved, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user == null)
        {
            return false;
        }
        user.Status = approved ? "approved" : "rejected";
        user.UpdatedAt = DateTime.UtcNow;
        await _userRepository.UpdateAsync(user, cancellationToken);
        return true;
    }
    public async Task<IEnumerable<UserDto>> GetPendingUsersAsync(CancellationToken cancellationToken = default)
    {
        var users = await _userRepository.GetPendingUsersAsync(cancellationToken);
        return users.Select(u => u.ToDto());
    }
    public async Task<IEnumerable<UserDto>> GetActiveUsersAsync(CancellationToken cancellationToken = default)
    {
        var users = await _userRepository.GetActiveUsersAsync(cancellationToken);
        return users.Select(u => u.ToDto());
    }
    public async Task<bool> DeleteUserAsync(string userId, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByIdAsync(userId, cancellationToken);
        if (user == null)
        {
            return false;
        }
        await _userRepository.DeleteAsync(userId, cancellationToken);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.ArchitectureTests/DnDMapBuilder.ArchitectureTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- xUnit Testing Framework -->
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />

    <!-- Architecture Testing -->
    <PackageReference Include="NetArchTest.Rules" Version="1.3.2" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Aspire.ServiceDefaults/DnDMapBuilder.Aspire.ServiceDefaults.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsAspireSharedProject>true</IsAspireSharedProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Http.Resilience" Version="10.2.0" />
    <PackageReference Include="Microsoft.Extensions.ServiceDiscovery" Version="10.2.0" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Contracts/DTOs/UserDto.cs">
namespace DnDMapBuilder.Contracts.DTOs;
public record UserDto(
    string Id,
    string Username,
    string Email,
    string Role,
    string Status,
    string? OAuthProvider = null,
    string? ProfilePictureUrl = null,
    bool EmailVerified = false
);
</file>

<file path="src/DnDMapBuilder.Contracts/DnDMapBuilder.Contracts.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Data/Entities/User.cs">
namespace DnDMapBuilder.Data.Entities;
public class User
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Username { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string PasswordHash { get; set; } = string.Empty;
    public string Role { get; set; } = "user";
    public string Status { get; set; } = "pending";
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public string? OAuthProvider { get; set; }
    public string? OAuthProviderId { get; set; }
    public string? ProfilePictureUrl { get; set; }
    public bool EmailVerified { get; set; }
    public ICollection<Campaign> Campaigns { get; set; } = new List<Campaign>();
    public ICollection<TokenDefinition> TokenDefinitions { get; set; } = new List<TokenDefinition>();
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/ICampaignRepository.cs">
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Data.Repositories.Interfaces;
public interface ICampaignRepository : IGenericRepository<Campaign>
{
    Task<IEnumerable<Campaign>> GetByOwnerIdAsync(string ownerId, CancellationToken cancellationToken = default);
    Task<Campaign?> GetWithMissionsAsync(string id, CancellationToken cancellationToken = default);
    Task<Campaign?> GetCompleteAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IGameMapRepository.cs">
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Data.Repositories.Interfaces;
public interface IGameMapRepository : IGenericRepository<GameMap>
{
    Task<IEnumerable<GameMap>> GetByMissionIdAsync(string missionId, CancellationToken cancellationToken = default);
    Task<GameMap?> GetWithTokensAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IMapTokenInstanceRepository.cs">
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Data.Repositories.Interfaces;
public interface IMapTokenInstanceRepository : IGenericRepository<MapTokenInstance>
{
    Task<IEnumerable<MapTokenInstance>> GetByMapIdAsync(string mapId, CancellationToken cancellationToken = default);
    Task DeleteByMapIdAsync(string mapId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IMissionRepository.cs">
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Data.Repositories.Interfaces;
public interface IMissionRepository : IGenericRepository<Mission>
{
    Task<IEnumerable<Mission>> GetByCampaignIdAsync(string campaignId, CancellationToken cancellationToken = default);
    Task<Mission?> GetWithMapsAsync(string id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/ITokenDefinitionRepository.cs">
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Data.Repositories.Interfaces;
public interface ITokenDefinitionRepository : IGenericRepository<TokenDefinition>
{
    Task<IEnumerable<TokenDefinition>> GetByUserIdAsync(string userId, CancellationToken cancellationToken = default);
    Task<IEnumerable<TokenDefinition>> GetByTypeAsync(string type, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/GenericRepository.cs">
using Microsoft.EntityFrameworkCore;
namespace DnDMapBuilder.Data.Repositories;
public class GenericRepository<T> : IGenericRepository<T> where T : class
{
    protected readonly DnDMapBuilderDbContext _context;
    protected readonly DbSet<T> _dbSet;
    public GenericRepository(DnDMapBuilderDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }
    public virtual async Task<T?> GetByIdAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, cancellationToken);
    }
    public virtual async Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.ToListAsync(cancellationToken);
    }
    public virtual async Task<T> AddAsync(T entity, CancellationToken cancellationToken = default)
    {
        await _dbSet.AddAsync(entity, cancellationToken);
        await _context.SaveChangesAsync(cancellationToken);
        return entity;
    }
    public virtual async Task UpdateAsync(T entity, CancellationToken cancellationToken = default)
    {
        _dbSet.Update(entity);
        await _context.SaveChangesAsync(cancellationToken);
    }
    public virtual async Task DeleteAsync(string id, CancellationToken cancellationToken = default)
    {
        var entity = await GetByIdAsync(id, cancellationToken);
        if (entity != null)
        {
            _dbSet.Remove(entity);
            await _context.SaveChangesAsync(cancellationToken);
        }
    }
    public virtual async Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet.FindAsync(new object[] { id }, cancellationToken) != null;
    }
    public virtual async Task<(IEnumerable<T> Items, int TotalCount)> GetPagedAsync(int pageNumber, int pageSize, CancellationToken cancellationToken = default)
    {
        if (pageNumber < 1) pageNumber = 1;
        if (pageSize < 1) pageSize = 20;
        if (pageSize > 100) pageSize = 100;
        var totalCount = await _dbSet.AsNoTracking().CountAsync(cancellationToken);
        var items = await _dbSet
            .AsNoTracking()
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(cancellationToken);
        return (items, totalCount);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/DbInitializer.cs">
using DnDMapBuilder.Data.Entities;
using Microsoft.EntityFrameworkCore;
namespace DnDMapBuilder.Data;
public static class DbInitializer
{
    public static async Task InitializeAsync(DnDMapBuilderDbContext context)
    {
        await context.Database.MigrateAsync();
        var adminEmail = Environment.GetEnvironmentVariable("ADMIN_EMAIL")
            ?? throw new InvalidOperationException("ADMIN_EMAIL environment variable is required");
        var adminPassword = Environment.GetEnvironmentVariable("ADMIN_DEFAULT_PASSWORD")
            ?? throw new InvalidOperationException("ADMIN_DEFAULT_PASSWORD environment variable is required");
        var existingAdmin = await context.Users
            .FirstOrDefaultAsync(u => u.Role == "admin" && u.Email == adminEmail);
        if (existingAdmin == null)
        {
            var admin = new User
            {
                Id = Guid.NewGuid().ToString(),
                Username = "admin",
                Email = adminEmail,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(adminPassword, 11),
                Role = "admin",
                Status = "approved",
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            context.Users.Add(admin);
            await context.SaveChangesAsync();
            Console.WriteLine($"Admin user created: {adminEmail}");
        }
        else
        {
            existingAdmin.PasswordHash = BCrypt.Net.BCrypt.HashPassword(adminPassword, 11);
            existingAdmin.UpdatedAt = DateTime.UtcNow;
            await context.SaveChangesAsync();
            Console.WriteLine($"Admin user password updated: {adminEmail}");
        }
    }
}
</file>

<file path="src/DnDMapBuilder.UnitTests/Services/OAuthServiceTests.cs">
using Xunit;
namespace DnDMapBuilder.UnitTests.Services;
public class OAuthServiceTests
{
    [Fact]
    public void OAuthService_IsProperlyStructured()
    {
        var serviceType = typeof(DnDMapBuilder.Application.Services.OAuthService);
        Assert.NotNull(serviceType);
    }
}
</file>

<file path="API_DOCUMENTATION.md">
# DnD Map Builder API Documentation

## Overview

This API provides endpoints for managing D&D campaigns, missions, maps, and tokens with JWT-based authentication.

## Base URL

- Development: `https://localhost:5001`
- Production: Update according to your deployment

## Authentication

All endpoints except `/api/auth/register` and `/api/auth/login` require authentication.

### How to Authenticate

1. Register a new user or login
2. Copy the `token` from the response
3. Include it in the `Authorization` header: `Bearer <token>`

Example:
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

## API Endpoints

### Authentication

#### Register

```http
POST /api/auth/register
Content-Type: application/json

{
  "username": "john_doe",
  "email": "john@example.com",
  "password": "SecurePassword123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": "user-id",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user",
    "status": "pending"
  },
  "message": "Registration successful. Awaiting admin approval."
}
```

**Note:** New users require admin approval before they can access protected resources.

#### Login

```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "SecurePassword123!"
}
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": "user-id",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user",
    "status": "approved"
  },
  "message": "Login successful."
}
```

#### Get Pending Users (Admin Only)

```http
GET /api/auth/pending-users
Authorization: Bearer <admin-token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "user-id",
      "username": "new_user",
      "email": "newuser@example.com",
      "role": "user",
      "status": "pending"
    }
  ]
}
```

#### Approve User (Admin Only)

```http
POST /api/auth/approve-user
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "userId": "user-id",
  "approved": true
}
```

### Campaigns

#### Get All User Campaigns

```http
GET /api/campaigns
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "campaign-id",
      "name": "Lost Mines of Phandelver",
      "description": "A classic D&D adventure",
      "missions": [...],
      "ownerId": "user-id",
      "createdAt": "2024-01-15T10:30:00Z",
      "updatedAt": "2024-01-15T10:30:00Z"
    }
  ]
}
```

#### Get Campaign by ID

```http
GET /api/campaigns/{id}
Authorization: Bearer <token>
```

#### Create Campaign

```http
POST /api/campaigns
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Curse of Strahd",
  "description": "A gothic horror adventure in Barovia"
}
```

#### Update Campaign

```http
PUT /api/campaigns/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Curse of Strahd - Updated",
  "description": "Updated description"
}
```

#### Delete Campaign

```http
DELETE /api/campaigns/{id}
Authorization: Bearer <token>
```

### Missions

#### Get Mission by ID

```http
GET /api/missions/{id}
Authorization: Bearer <token>
```

#### Get Missions by Campaign

```http
GET /api/missions/campaign/{campaignId}
Authorization: Bearer <token>
```

#### Create Mission

```http
POST /api/missions
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Village of Barovia",
  "description": "Explore the mysterious village",
  "campaignId": "campaign-id"
}
```

#### Update Mission

```http
PUT /api/missions/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Village of Barovia - Updated",
  "description": "Updated description"
}
```

#### Delete Mission

```http
DELETE /api/missions/{id}
Authorization: Bearer <token>
```

### Maps

#### Get Map by ID

```http
GET /api/maps/{id}
Authorization: Bearer <token>
```

**Response includes all placed tokens on the map.**

#### Get Maps by Mission

```http
GET /api/maps/mission/{missionId}
Authorization: Bearer <token>
```

#### Create Map

```http
POST /api/maps
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Tavern Interior",
  "imageUrl": "https://example.com/tavern.jpg",
  "rows": 20,
  "cols": 30,
  "gridColor": "#000000",
  "gridOpacity": 0.3,
  "missionId": "mission-id"
}
```

#### Update Map (Including Tokens)

```http
PUT /api/maps/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Tavern Interior - Night",
  "imageUrl": "https://example.com/tavern-night.jpg",
  "rows": 20,
  "cols": 30,
  "tokens": [
    {
      "tokenId": "token-definition-id",
      "x": 5,
      "y": 10
    },
    {
      "tokenId": "another-token-id",
      "x": 15,
      "y": 8
    }
  ],
  "gridColor": "#000000",
  "gridOpacity": 0.5
}
```

**Note:** The tokens array replaces all existing tokens on the map.

#### Delete Map

```http
DELETE /api/maps/{id}
Authorization: Bearer <token>
```

### Token Definitions

#### Get All User Tokens

```http
GET /api/tokens
Authorization: Bearer <token>
```

**Response (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "id": "token-id",
      "name": "Warrior",
      "imageUrl": "https://example.com/warrior.png",
      "size": 1,
      "type": "player",
      "userId": "user-id"
    }
  ]
}
```

#### Get Token by ID

```http
GET /api/tokens/{id}
Authorization: Bearer <token>
```

#### Create Token

```http
POST /api/tokens
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Dragon",
  "imageUrl": "https://example.com/dragon.png",
  "size": 3,
  "type": "enemy"
}
```

**Token Sizes:**
- `1`: 1x1 grid square (Medium creature)
- `2`: 2x2 grid squares (Large creature)
- `3`: 3x3 grid squares (Huge creature)

**Token Types:**
- `player`: Player character or ally
- `enemy`: Enemy or monster

#### Update Token

```http
PUT /api/tokens/{id}
Authorization: Bearer <token>
Content-Type: application/json

{
  "name": "Ancient Dragon",
  "imageUrl": "https://example.com/ancient-dragon.png",
  "size": 3,
  "type": "enemy"
}
```

#### Delete Token

```http
DELETE /api/tokens/{id}
Authorization: Bearer <token>
```

**Note:** Deleting a token definition does not remove it from existing maps.

## Error Responses

### 400 Bad Request
```json
{
  "success": false,
  "data": null,
  "message": "Validation error or bad request",
  "errors": ["Error detail 1", "Error detail 2"]
}
```

### 401 Unauthorized
```json
{
  "success": false,
  "data": null,
  "message": "Invalid credentials or account not approved."
}
```

### 403 Forbidden
```json
{
  "success": false,
  "data": null,
  "message": "You don't have permission to perform this action."
}
```

### 404 Not Found
```json
{
  "success": false,
  "data": null,
  "message": "Resource not found."
}
```

### 500 Internal Server Error
```json
{
  "success": false,
  "data": null,
  "message": "An internal error occurred."
}
```

## Data Models

### User
```typescript
{
  id: string;
  username: string;
  email: string;
  role: "admin" | "user";
  status: "pending" | "approved" | "rejected";
}
```

### Campaign
```typescript
{
  id: string;
  name: string;
  description: string;
  missions: Mission[];
  ownerId: string;
  createdAt: string; // ISO 8601
  updatedAt: string; // ISO 8601
}
```

### Mission
```typescript
{
  id: string;
  name: string;
  description: string;
  maps: GameMap[];
  campaignId: string;
}
```

### GameMap
```typescript
{
  id: string;
  name: string;
  imageUrl: string | null;
  rows: number;
  cols: number;
  tokens: MapTokenInstance[];
  gridColor: string; // Hex color
  gridOpacity: number; // 0.0 - 1.0
  missionId: string;
}
```

### TokenDefinition
```typescript
{
  id: string;
  name: string;
  imageUrl: string;
  size: 1 | 2 | 3;
  type: "player" | "enemy";
  userId: string;
}
```

### MapTokenInstance
```typescript
{
  instanceId: string;
  tokenId: string; // References TokenDefinition
  x: number;
  y: number;
}
```

## Rate Limiting

Currently, no rate limiting is implemented. Consider adding rate limiting in production.

## CORS

CORS is configured to allow all origins in development. Update CORS policy for production deployment.

## Versioning

Current API version: v1

Future versions will be accessible via `/api/v2/...`

---

## OAuth Authentication

The API supports OAuth authentication through Google and Apple Sign-In providers. This allows users to authenticate without creating a password.

### OAuth Flows Supported

1. **Authorization Code Flow**: For web applications
2. **ID Token Validation**: For mobile and single-page applications (SPAs)

### Get OAuth Authorization URL

**Endpoint**: `GET /api/v1/auth/oauth/{provider}/url`

**Parameters**:
- `provider` (path): OAuth provider ("google" or "apple")
- `redirectUri` (query, optional): Custom redirect URI (defaults to configured backend redirect URI)

**Response**:
```json
{
  "success": true,
  "data": {
    "authorizationUrl": "https://accounts.google.com/o/oauth2/v2/auth?client_id=...",
    "state": "random-state-string"
  },
  "message": "google authorization URL generated."
}
```

### OAuth Callback (Authorization Code Flow)

**Endpoint**: `POST /api/v1/auth/oauth/callback`

**Body**:
```json
{
  "provider": "google",
  "code": "authorization-code-from-provider",
  "redirectUri": "https://your-app.com/callback"
}
```

**Response**: Same as login endpoint (returns user info and JWT token)

**Example Response**:
```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIs...",
    "id": "user-id",
    "username": "john_doe",
    "email": "john@example.com",
    "role": "user",
    "status": "approved"
  },
  "message": "OAuth login successful."
}
```

### OAuth Token Validation (For Mobile/SPA)

**Endpoint**: `POST /api/v1/auth/oauth/token`

**Body**:
```json
{
  "provider": "google",
  "idToken": "id-token-from-google-sdk"
}
```

**Response**: Same as OAuth callback (returns user info and JWT token)

### OAuth Provider Configuration

#### Google OAuth

To use Google OAuth, you need to:
1. Create a Google Cloud project
2. Create OAuth 2.0 credentials (Web application type)
3. Add redirect URIs to your project
4. Configure credentials in `appsettings.json`:
```json
{
  "OAuth": {
    "Google": {
      "ClientId": "your-client-id.apps.googleusercontent.com",
      "ClientSecret": "your-client-secret"
    }
  }
}
```

#### Apple OAuth

To use Apple Sign-In, you need to:
1. Enroll in Apple Developer Program
2. Create App IDs and sign certificates
3. Create a private key for server-to-server communication
4. Configure credentials in `appsettings.json`:
```json
{
  "OAuth": {
    "Apple": {
      "ClientId": "com.yourcompany.appid",
      "TeamId": "your-team-id",
      "KeyId": "your-key-id",
      "PrivateKey": "your-private-key-in-base64"
    }
  }
}
```

### OAuth User Management

- When a user authenticates via OAuth for the first time, a new account is automatically created
- The account is automatically approved (no admin approval needed)
- If an email already exists, the OAuth provider is linked to the existing account
- User profile pictures from OAuth providers are stored and returned in the API

### JWT Token Usage

After OAuth authentication, the API returns a JWT token in the response. Use this token in subsequent requests:

```bash
curl -H "Authorization: Bearer <your-jwt-token>" http://localhost:5000/api/v1/campaigns
```
</file>

<file path="prompt_plan.md">
# OAuth Authentication Implementation - Backend

## Overview

This plan outlines the implementation of Google and Apple OAuth authentication for the DnD Map Builder API. The implementation will allow users to sign in using their Google or Apple accounts as an alternative to email/password authentication.

---

## Architecture Decisions

### OAuth Flow
- **Flow Type**: Authorization Code Flow with PKCE (recommended for security)
- **Token Handling**: Backend validates OAuth tokens and issues its own JWT tokens
- **User Linking**: OAuth accounts can be linked to existing email-based accounts

### Database Changes
- Add OAuth provider fields to User entity
- Support multiple OAuth providers per user
- Store provider-specific user IDs for account linking

---

## Implementation Steps

---

### STEP-OAUTH-BE-001

**Status:** done
**Task:** Add Required NuGet Packages
**Files:** `src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj`

**Instructions:**

1. Add the following NuGet packages to the API project:

```xml
<PackageReference Include="Microsoft.AspNetCore.Authentication.Google" Version="9.0.0" />
<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />
```

2. For Apple Sign-In, we'll use a custom implementation since Apple requires JWT-based client secrets. Add:

```xml
<PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.0.0" />
```

3. Run `dotnet restore` to install packages

4. Verify build succeeds: `dotnet build`

---

### STEP-OAUTH-BE-002

**Status:** done
**Task:** Update User Entity for OAuth Support
**Files:** `src/DnDMapBuilder.Data/Entities/User.cs`

**Instructions:**

1. Read the current User.cs entity file

2. Add the following OAuth-related properties:

```csharp
/// <summary>
/// The OAuth provider used for authentication (null for email/password users)
/// Values: "google", "apple", null
/// </summary>
public string? OAuthProvider { get; set; }

/// <summary>
/// The unique identifier from the OAuth provider
/// </summary>
public string? OAuthProviderId { get; set; }

/// <summary>
/// URL to the user's profile picture from OAuth provider
/// </summary>
public string? ProfilePictureUrl { get; set; }

/// <summary>
/// Whether the email has been verified by the OAuth provider
/// </summary>
public bool EmailVerified { get; set; }
```

3. Ensure the entity still compiles correctly

4. Run `dotnet build` to verify

---

### STEP-OAUTH-BE-003

**Status:** done
**Task:** Create Database Migration for OAuth Fields
**Files:** `src/DnDMapBuilder.Data/Migrations/`

**Instructions:**

1. Navigate to the Data project directory

2. Create a new migration:
```bash
dotnet ef migrations add AddOAuthUserFields --project src/DnDMapBuilder.Data --startup-project src/DnDMapBuilder.Api
```

3. Review the generated migration file to ensure it:
   - Adds `OAuthProvider` column (nullable nvarchar)
   - Adds `OAuthProviderId` column (nullable nvarchar)
   - Adds `ProfilePictureUrl` column (nullable nvarchar)
   - Adds `EmailVerified` column (bit, default false)

4. Apply the migration:
```bash
dotnet ef database update --project src/DnDMapBuilder.Data --startup-project src/DnDMapBuilder.Api
```

5. Verify migration applied successfully

---

### STEP-OAUTH-BE-004

**Status:** done
**Task:** Create OAuth Configuration Settings
**Files:** `src/DnDMapBuilder.Api/appsettings.json`, `src/DnDMapBuilder.Api/appsettings.Development.json`

**Instructions:**

1. Add OAuth configuration section to appsettings.json:

```json
{
  "OAuth": {
    "Google": {
      "ClientId": "",
      "ClientSecret": ""
    },
    "Apple": {
      "ClientId": "",
      "TeamId": "",
      "KeyId": "",
      "PrivateKey": ""
    },
    "RedirectUri": "https://localhost:5001/api/v1/auth/oauth/callback",
    "FrontendRedirectUri": "https://localhost:3000/auth/callback"
  }
}
```

2. Create a configuration class in `src/DnDMapBuilder.Contracts/Configuration/OAuthSettings.cs`:

```csharp
namespace DnDMapBuilder.Contracts.Configuration;

public class OAuthSettings
{
    public GoogleSettings Google { get; set; } = new();
    public AppleSettings Apple { get; set; } = new();
    public string RedirectUri { get; set; } = string.Empty;
    public string FrontendRedirectUri { get; set; } = string.Empty;
}

public class GoogleSettings
{
    public string ClientId { get; set; } = string.Empty;
    public string ClientSecret { get; set; } = string.Empty;
}

public class AppleSettings
{
    public string ClientId { get; set; } = string.Empty;
    public string TeamId { get; set; } = string.Empty;
    public string KeyId { get; set; } = string.Empty;
    public string PrivateKey { get; set; } = string.Empty;
}
```

3. Register configuration in Program.cs:

```csharp
builder.Services.Configure<OAuthSettings>(builder.Configuration.GetSection("OAuth"));
```

4. Verify build succeeds

---

### STEP-OAUTH-BE-005

**Status:** done
**Task:** Create OAuth DTOs and Contracts
**Files:** `src/DnDMapBuilder.Contracts/Requests/`, `src/DnDMapBuilder.Contracts/Responses/`

**Instructions:**

1. Create `OAuthLoginRequest.cs` in Requests folder:

```csharp
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request for OAuth-based login/registration
/// </summary>
public record OAuthLoginRequest(
    /// <summary>
    /// The OAuth provider ("google" or "apple")
    /// </summary>
    string Provider,

    /// <summary>
    /// The authorization code received from OAuth provider
    /// </summary>
    string Code,

    /// <summary>
    /// The redirect URI used in the OAuth flow (for validation)
    /// </summary>
    string RedirectUri
);
```

2. Create `OAuthTokenRequest.cs` for token-based flow (mobile/SPA):

```csharp
namespace DnDMapBuilder.Contracts.Requests;

/// <summary>
/// Request for OAuth login using ID token (for mobile/SPA clients)
/// </summary>
public record OAuthTokenRequest(
    /// <summary>
    /// The OAuth provider ("google" or "apple")
    /// </summary>
    string Provider,

    /// <summary>
    /// The ID token received from OAuth provider
    /// </summary>
    string IdToken
);
```

3. Create `OAuthUrlResponse.cs` in Responses folder:

```csharp
namespace DnDMapBuilder.Contracts.Responses;

/// <summary>
/// Response containing OAuth authorization URL
/// </summary>
public record OAuthUrlResponse(
    /// <summary>
    /// The URL to redirect the user to for OAuth authentication
    /// </summary>
    string AuthorizationUrl,

    /// <summary>
    /// State parameter for CSRF protection
    /// </summary>
    string State
);
```

4. Verify build succeeds

---

### STEP-OAUTH-BE-006

**Status:** done
**Task:** Create IOAuthService Interface
**Files:** `src/DnDMapBuilder.Application/Interfaces/IOAuthService.cs`

**Instructions:**

1. Create a new interface file `IOAuthService.cs`:

```csharp
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;

namespace DnDMapBuilder.Application.Interfaces;

/// <summary>
/// Service interface for OAuth authentication operations
/// </summary>
public interface IOAuthService
{
    /// <summary>
    /// Generates the OAuth authorization URL for the specified provider
    /// </summary>
    /// <param name="provider">OAuth provider (google or apple)</param>
    /// <param name="redirectUri">The redirect URI after authentication</param>
    /// <returns>Authorization URL and state parameter</returns>
    Task<OAuthUrlResponse> GetAuthorizationUrlAsync(string provider, string redirectUri);

    /// <summary>
    /// Handles OAuth callback and exchanges code for tokens
    /// </summary>
    /// <param name="request">OAuth login request with authorization code</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Auth response with JWT token or null if failed</returns>
    Task<AuthResponse?> HandleOAuthCallbackAsync(OAuthLoginRequest request, CancellationToken cancellationToken = default);

    /// <summary>
    /// Validates an ID token and authenticates the user (for mobile/SPA clients)
    /// </summary>
    /// <param name="request">OAuth token request with ID token</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Auth response with JWT token or null if failed</returns>
    Task<AuthResponse?> ValidateIdTokenAsync(OAuthTokenRequest request, CancellationToken cancellationToken = default);
}
```

2. Verify build succeeds

---

### STEP-OAUTH-BE-007

**Status:** done
**Task:** Implement Google OAuth Token Validation
**Files:** `src/DnDMapBuilder.Application/Services/GoogleOAuthService.cs`

**Instructions:**

1. Create `GoogleOAuthService.cs`:

```csharp
using System.Text.Json;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for Google OAuth token validation and user info retrieval
/// </summary>
public class GoogleOAuthService
{
    private readonly HttpClient _httpClient;
    private readonly OAuthSettings _settings;
    private readonly ILogger<GoogleOAuthService> _logger;

    private const string TokenInfoEndpoint = "https://oauth2.googleapis.com/tokeninfo";
    private const string UserInfoEndpoint = "https://www.googleapis.com/oauth2/v3/userinfo";
    private const string TokenEndpoint = "https://oauth2.googleapis.com/token";
    private const string AuthEndpoint = "https://accounts.google.com/o/oauth2/v2/auth";

    public GoogleOAuthService(
        HttpClient httpClient,
        IOptions<OAuthSettings> settings,
        ILogger<GoogleOAuthService> logger)
    {
        _httpClient = httpClient;
        _settings = settings.Value;
        _logger = logger;
    }

    /// <summary>
    /// Generates Google OAuth authorization URL
    /// </summary>
    public string GetAuthorizationUrl(string redirectUri, string state)
    {
        var scopes = Uri.EscapeDataString("openid email profile");
        return $"{AuthEndpoint}?client_id={_settings.Google.ClientId}&redirect_uri={Uri.EscapeDataString(redirectUri)}&response_type=code&scope={scopes}&state={state}&access_type=offline&prompt=consent";
    }

    /// <summary>
    /// Exchanges authorization code for tokens
    /// </summary>
    public async Task<GoogleTokenResponse?> ExchangeCodeForTokensAsync(string code, string redirectUri)
    {
        var content = new FormUrlEncodedContent(new Dictionary<string, string>
        {
            ["code"] = code,
            ["client_id"] = _settings.Google.ClientId,
            ["client_secret"] = _settings.Google.ClientSecret,
            ["redirect_uri"] = redirectUri,
            ["grant_type"] = "authorization_code"
        });

        var response = await _httpClient.PostAsync(TokenEndpoint, content);
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to exchange Google auth code: {Status}", response.StatusCode);
            return null;
        }

        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<GoogleTokenResponse>(json);
    }

    /// <summary>
    /// Validates an ID token and returns user info
    /// </summary>
    public async Task<GoogleUserInfo?> ValidateIdTokenAsync(string idToken)
    {
        var response = await _httpClient.GetAsync($"{TokenInfoEndpoint}?id_token={idToken}");
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to validate Google ID token: {Status}", response.StatusCode);
            return null;
        }

        var json = await response.Content.ReadAsStringAsync();
        var tokenInfo = JsonSerializer.Deserialize<GoogleTokenInfo>(json);

        // Verify the token is for our app
        if (tokenInfo?.Aud != _settings.Google.ClientId)
        {
            _logger.LogError("Google ID token audience mismatch");
            return null;
        }

        return new GoogleUserInfo
        {
            Id = tokenInfo.Sub,
            Email = tokenInfo.Email,
            EmailVerified = tokenInfo.EmailVerified,
            Name = tokenInfo.Name,
            Picture = tokenInfo.Picture
        };
    }

    /// <summary>
    /// Gets user info using access token
    /// </summary>
    public async Task<GoogleUserInfo?> GetUserInfoAsync(string accessToken)
    {
        _httpClient.DefaultRequestHeaders.Authorization =
            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);

        var response = await _httpClient.GetAsync(UserInfoEndpoint);
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to get Google user info: {Status}", response.StatusCode);
            return null;
        }

        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<GoogleUserInfo>(json);
    }
}

public class GoogleTokenResponse
{
    [System.Text.Json.Serialization.JsonPropertyName("access_token")]
    public string AccessToken { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("id_token")]
    public string IdToken { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("refresh_token")]
    public string? RefreshToken { get; set; }

    [System.Text.Json.Serialization.JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }
}

public class GoogleTokenInfo
{
    [System.Text.Json.Serialization.JsonPropertyName("sub")]
    public string Sub { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("email")]
    public string Email { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("email_verified")]
    public bool EmailVerified { get; set; }

    [System.Text.Json.Serialization.JsonPropertyName("name")]
    public string? Name { get; set; }

    [System.Text.Json.Serialization.JsonPropertyName("picture")]
    public string? Picture { get; set; }

    [System.Text.Json.Serialization.JsonPropertyName("aud")]
    public string Aud { get; set; } = string.Empty;
}

public class GoogleUserInfo
{
    [System.Text.Json.Serialization.JsonPropertyName("sub")]
    public string Id { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("email")]
    public string Email { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("email_verified")]
    public bool EmailVerified { get; set; }

    [System.Text.Json.Serialization.JsonPropertyName("name")]
    public string? Name { get; set; }

    [System.Text.Json.Serialization.JsonPropertyName("picture")]
    public string? Picture { get; set; }
}
```

2. Verify build succeeds

---

### STEP-OAUTH-BE-008

**Status:** done
**Task:** Implement Apple OAuth Token Validation
**Files:** `src/DnDMapBuilder.Application/Services/AppleOAuthService.cs`

**Instructions:**

1. Create `AppleOAuthService.cs`:

```csharp
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text.Json;
using DnDMapBuilder.Contracts.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Service for Apple OAuth token validation and user info retrieval
/// </summary>
public class AppleOAuthService
{
    private readonly HttpClient _httpClient;
    private readonly OAuthSettings _settings;
    private readonly ILogger<AppleOAuthService> _logger;

    private const string AuthEndpoint = "https://appleid.apple.com/auth/authorize";
    private const string TokenEndpoint = "https://appleid.apple.com/auth/token";
    private const string KeysEndpoint = "https://appleid.apple.com/auth/keys";

    public AppleOAuthService(
        HttpClient httpClient,
        IOptions<OAuthSettings> settings,
        ILogger<AppleOAuthService> logger)
    {
        _httpClient = httpClient;
        _settings = settings.Value;
        _logger = logger;
    }

    /// <summary>
    /// Generates Apple OAuth authorization URL
    /// </summary>
    public string GetAuthorizationUrl(string redirectUri, string state)
    {
        var scopes = Uri.EscapeDataString("name email");
        return $"{AuthEndpoint}?client_id={_settings.Apple.ClientId}&redirect_uri={Uri.EscapeDataString(redirectUri)}&response_type=code&scope={scopes}&state={state}&response_mode=form_post";
    }

    /// <summary>
    /// Exchanges authorization code for tokens
    /// </summary>
    public async Task<AppleTokenResponse?> ExchangeCodeForTokensAsync(string code, string redirectUri)
    {
        var clientSecret = GenerateClientSecret();

        var content = new FormUrlEncodedContent(new Dictionary<string, string>
        {
            ["code"] = code,
            ["client_id"] = _settings.Apple.ClientId,
            ["client_secret"] = clientSecret,
            ["redirect_uri"] = redirectUri,
            ["grant_type"] = "authorization_code"
        });

        var response = await _httpClient.PostAsync(TokenEndpoint, content);
        if (!response.IsSuccessStatusCode)
        {
            _logger.LogError("Failed to exchange Apple auth code: {Status}", response.StatusCode);
            return null;
        }

        var json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<AppleTokenResponse>(json);
    }

    /// <summary>
    /// Validates an Apple ID token and returns user info
    /// </summary>
    public async Task<AppleUserInfo?> ValidateIdTokenAsync(string idToken)
    {
        try
        {
            // Get Apple's public keys
            var keysResponse = await _httpClient.GetStringAsync(KeysEndpoint);
            var keys = JsonSerializer.Deserialize<AppleKeysResponse>(keysResponse);

            if (keys?.Keys == null || keys.Keys.Count == 0)
            {
                _logger.LogError("Failed to get Apple public keys");
                return null;
            }

            var handler = new JwtSecurityTokenHandler();
            var jwtToken = handler.ReadJwtToken(idToken);

            // Find the key that matches the token's kid
            var kid = jwtToken.Header.Kid;
            var key = keys.Keys.FirstOrDefault(k => k.Kid == kid);

            if (key == null)
            {
                _logger.LogError("No matching Apple key found for kid: {Kid}", kid);
                return null;
            }

            var rsa = new RSACryptoServiceProvider();
            rsa.ImportParameters(new RSAParameters
            {
                Modulus = Base64UrlEncoder.DecodeBytes(key.N),
                Exponent = Base64UrlEncoder.DecodeBytes(key.E)
            });

            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidIssuer = "https://appleid.apple.com",
                ValidateAudience = true,
                ValidAudience = _settings.Apple.ClientId,
                ValidateLifetime = true,
                IssuerSigningKey = new RsaSecurityKey(rsa)
            };

            var principal = handler.ValidateToken(idToken, validationParameters, out _);

            return new AppleUserInfo
            {
                Id = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? string.Empty,
                Email = principal.FindFirst(ClaimTypes.Email)?.Value ?? string.Empty,
                EmailVerified = true // Apple verifies emails
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to validate Apple ID token");
            return null;
        }
    }

    /// <summary>
    /// Generates Apple client secret (JWT signed with private key)
    /// </summary>
    private string GenerateClientSecret()
    {
        var now = DateTime.UtcNow;
        var ecdsa = ECDsa.Create();
        ecdsa.ImportPkcs8PrivateKey(Convert.FromBase64String(_settings.Apple.PrivateKey), out _);

        var signingCredentials = new SigningCredentials(
            new ECDsaSecurityKey(ecdsa) { KeyId = _settings.Apple.KeyId },
            SecurityAlgorithms.EcdsaSha256);

        var claims = new[]
        {
            new Claim("iss", _settings.Apple.TeamId),
            new Claim("iat", ((long)(now - DateTime.UnixEpoch).TotalSeconds).ToString()),
            new Claim("exp", ((long)(now.AddMonths(6) - DateTime.UnixEpoch).TotalSeconds).ToString()),
            new Claim("aud", "https://appleid.apple.com"),
            new Claim("sub", _settings.Apple.ClientId)
        };

        var token = new JwtSecurityToken(
            claims: claims,
            signingCredentials: signingCredentials);

        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}

public class AppleTokenResponse
{
    [System.Text.Json.Serialization.JsonPropertyName("access_token")]
    public string AccessToken { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("id_token")]
    public string IdToken { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("refresh_token")]
    public string? RefreshToken { get; set; }

    [System.Text.Json.Serialization.JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }
}

public class AppleUserInfo
{
    public string Id { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public bool EmailVerified { get; set; }
    public string? Name { get; set; }
}

public class AppleKeysResponse
{
    [System.Text.Json.Serialization.JsonPropertyName("keys")]
    public List<AppleKey> Keys { get; set; } = new();
}

public class AppleKey
{
    [System.Text.Json.Serialization.JsonPropertyName("kid")]
    public string Kid { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("n")]
    public string N { get; set; } = string.Empty;

    [System.Text.Json.Serialization.JsonPropertyName("e")]
    public string E { get; set; } = string.Empty;
}
```

2. Verify build succeeds

---

### STEP-OAUTH-BE-009

**Status:** done
**Task:** Implement Main OAuthService
**Files:** `src/DnDMapBuilder.Application/Services/OAuthService.cs`

**Instructions:**

1. Create `OAuthService.cs` that implements `IOAuthService`:

```csharp
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.Configuration;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace DnDMapBuilder.Application.Services;

/// <summary>
/// Main OAuth service that coordinates authentication across providers
/// </summary>
public class OAuthService : IOAuthService
{
    private readonly GoogleOAuthService _googleService;
    private readonly AppleOAuthService _appleService;
    private readonly IUserRepository _userRepository;
    private readonly IJwtService _jwtService;
    private readonly OAuthSettings _settings;
    private readonly ILogger<OAuthService> _logger;

    public OAuthService(
        GoogleOAuthService googleService,
        AppleOAuthService appleService,
        IUserRepository userRepository,
        IJwtService jwtService,
        IOptions<OAuthSettings> settings,
        ILogger<OAuthService> logger)
    {
        _googleService = googleService;
        _appleService = appleService;
        _userRepository = userRepository;
        _jwtService = jwtService;
        _settings = settings.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public Task<OAuthUrlResponse> GetAuthorizationUrlAsync(string provider, string redirectUri)
    {
        var state = GenerateState();

        var authUrl = provider.ToLowerInvariant() switch
        {
            "google" => _googleService.GetAuthorizationUrl(redirectUri, state),
            "apple" => _appleService.GetAuthorizationUrl(redirectUri, state),
            _ => throw new ArgumentException($"Unsupported OAuth provider: {provider}")
        };

        return Task.FromResult(new OAuthUrlResponse(authUrl, state));
    }

    /// <inheritdoc />
    public async Task<AuthResponse?> HandleOAuthCallbackAsync(OAuthLoginRequest request, CancellationToken cancellationToken = default)
    {
        return request.Provider.ToLowerInvariant() switch
        {
            "google" => await HandleGoogleCallbackAsync(request.Code, request.RedirectUri, cancellationToken),
            "apple" => await HandleAppleCallbackAsync(request.Code, request.RedirectUri, cancellationToken),
            _ => throw new ArgumentException($"Unsupported OAuth provider: {request.Provider}")
        };
    }

    /// <inheritdoc />
    public async Task<AuthResponse?> ValidateIdTokenAsync(OAuthTokenRequest request, CancellationToken cancellationToken = default)
    {
        return request.Provider.ToLowerInvariant() switch
        {
            "google" => await ValidateGoogleIdTokenAsync(request.IdToken, cancellationToken),
            "apple" => await ValidateAppleIdTokenAsync(request.IdToken, cancellationToken),
            _ => throw new ArgumentException($"Unsupported OAuth provider: {request.Provider}")
        };
    }

    private async Task<AuthResponse?> HandleGoogleCallbackAsync(string code, string redirectUri, CancellationToken cancellationToken)
    {
        var tokens = await _googleService.ExchangeCodeForTokensAsync(code, redirectUri);
        if (tokens == null) return null;

        var userInfo = await _googleService.ValidateIdTokenAsync(tokens.IdToken);
        if (userInfo == null) return null;

        return await CreateOrUpdateUserAndGenerateTokenAsync("google", userInfo.Id, userInfo.Email, userInfo.Name, userInfo.Picture, userInfo.EmailVerified, cancellationToken);
    }

    private async Task<AuthResponse?> HandleAppleCallbackAsync(string code, string redirectUri, CancellationToken cancellationToken)
    {
        var tokens = await _appleService.ExchangeCodeForTokensAsync(code, redirectUri);
        if (tokens == null) return null;

        var userInfo = await _appleService.ValidateIdTokenAsync(tokens.IdToken);
        if (userInfo == null) return null;

        return await CreateOrUpdateUserAndGenerateTokenAsync("apple", userInfo.Id, userInfo.Email, userInfo.Name, null, userInfo.EmailVerified, cancellationToken);
    }

    private async Task<AuthResponse?> ValidateGoogleIdTokenAsync(string idToken, CancellationToken cancellationToken)
    {
        var userInfo = await _googleService.ValidateIdTokenAsync(idToken);
        if (userInfo == null) return null;

        return await CreateOrUpdateUserAndGenerateTokenAsync("google", userInfo.Id, userInfo.Email, userInfo.Name, userInfo.Picture, userInfo.EmailVerified, cancellationToken);
    }

    private async Task<AuthResponse?> ValidateAppleIdTokenAsync(string idToken, CancellationToken cancellationToken)
    {
        var userInfo = await _appleService.ValidateIdTokenAsync(idToken);
        if (userInfo == null) return null;

        return await CreateOrUpdateUserAndGenerateTokenAsync("apple", userInfo.Id, userInfo.Email, userInfo.Name, null, userInfo.EmailVerified, cancellationToken);
    }

    private async Task<AuthResponse?> CreateOrUpdateUserAndGenerateTokenAsync(
        string provider,
        string providerId,
        string email,
        string? name,
        string? picture,
        bool emailVerified,
        CancellationToken cancellationToken)
    {
        // Try to find existing user by OAuth provider ID
        var user = await _userRepository.GetByOAuthProviderAsync(provider, providerId, cancellationToken);

        // If not found, try to find by email
        if (user == null)
        {
            user = await _userRepository.GetByEmailAsync(email, cancellationToken);

            if (user != null)
            {
                // Link OAuth provider to existing account
                user.OAuthProvider = provider;
                user.OAuthProviderId = providerId;
                user.ProfilePictureUrl = picture;
                user.EmailVerified = emailVerified;
                user.UpdatedAt = DateTime.UtcNow;
                await _userRepository.UpdateAsync(user, cancellationToken);
            }
        }

        // Create new user if not found
        if (user == null)
        {
            user = new User
            {
                Id = Guid.NewGuid().ToString(),
                Username = name ?? email.Split('@')[0],
                Email = email,
                PasswordHash = string.Empty, // OAuth users don't have passwords
                Role = "user",
                Status = "approved", // OAuth users are auto-approved
                OAuthProvider = provider,
                OAuthProviderId = providerId,
                ProfilePictureUrl = picture,
                EmailVerified = emailVerified,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            await _userRepository.AddAsync(user, cancellationToken);
        }

        // Check if user is approved (may have been rejected previously)
        if (user.Status != "approved")
        {
            _logger.LogWarning("OAuth user {Email} attempted login but status is {Status}", email, user.Status);
            return null;
        }

        // Generate JWT token
        var token = _jwtService.GenerateToken(user);
        var userDto = user.ToDto();

        return new AuthResponse(token, userDto.Id, userDto.Username, userDto.Email, userDto.Role, userDto.Status);
    }

    private static string GenerateState()
    {
        var bytes = new byte[32];
        using var rng = System.Security.Cryptography.RandomNumberGenerator.Create();
        rng.GetBytes(bytes);
        return Convert.ToBase64String(bytes).Replace("+", "-").Replace("/", "_").TrimEnd('=');
    }
}
```

2. Verify build succeeds

---

### STEP-OAUTH-BE-010

**Status:** done
**Task:** Update IUserRepository for OAuth Queries
**Files:** `src/DnDMapBuilder.Data/Repositories/Interfaces/IUserRepository.cs`, `src/DnDMapBuilder.Data/Repositories/UserRepository.cs`

**Instructions:**

1. Add new method to `IUserRepository.cs`:

```csharp
/// <summary>
/// Gets a user by OAuth provider and provider-specific ID.
/// </summary>
/// <param name="provider">OAuth provider name (google, apple)</param>
/// <param name="providerId">Provider-specific user ID</param>
/// <param name="cancellationToken">Cancellation token</param>
/// <returns>The user or null if not found</returns>
Task<User?> GetByOAuthProviderAsync(string provider, string providerId, CancellationToken cancellationToken = default);
```

2. Implement in `UserRepository.cs`:

```csharp
public async Task<User?> GetByOAuthProviderAsync(string provider, string providerId, CancellationToken cancellationToken = default)
{
    return await _dbSet.AsNoTracking()
        .FirstOrDefaultAsync(u => u.OAuthProvider == provider && u.OAuthProviderId == providerId, cancellationToken);
}
```

3. Verify build succeeds

---

### STEP-OAUTH-BE-011

**Status:** done
**Task:** Add OAuth Endpoints to AuthController
**Files:** `src/DnDMapBuilder.Api/Controllers/AuthController.cs`

**Instructions:**

1. Read the current AuthController.cs file

2. Add IOAuthService dependency injection to constructor:

```csharp
private readonly IOAuthService _oAuthService;

public AuthController(IAuthService authService, IUserManagementService userManagementService, IOAuthService oAuthService)
{
    _authService = authService;
    _userManagementService = userManagementService;
    _oAuthService = oAuthService;
}
```

3. Add OAuth endpoints:

```csharp
/// <summary>
/// Get OAuth authorization URL for the specified provider
/// </summary>
[HttpGet("oauth/{provider}/url")]
public async Task<ActionResult<ApiResponse<OAuthUrlResponse>>> GetOAuthUrl(string provider, [FromQuery] string? redirectUri)
{
    try
    {
        var effectiveRedirectUri = redirectUri ?? $"{Request.Scheme}://{Request.Host}/api/v1/auth/oauth/callback";
        var response = await _oAuthService.GetAuthorizationUrlAsync(provider, effectiveRedirectUri);
        return Ok(new ApiResponse<OAuthUrlResponse>(true, response, $"{provider} authorization URL generated."));
    }
    catch (ArgumentException ex)
    {
        return BadRequest(new ApiResponse<OAuthUrlResponse>(false, null, ex.Message));
    }
}

/// <summary>
/// Handle OAuth callback with authorization code
/// </summary>
[HttpPost("oauth/callback")]
public async Task<ActionResult<ApiResponse<AuthResponse>>> OAuthCallback([FromBody] OAuthLoginRequest request, CancellationToken cancellationToken)
{
    try
    {
        var result = await _oAuthService.HandleOAuthCallbackAsync(request, cancellationToken);

        if (result == null)
        {
            return Unauthorized(new ApiResponse<AuthResponse>(false, null, "OAuth authentication failed."));
        }

        return Ok(new ApiResponse<AuthResponse>(true, result, "OAuth login successful."));
    }
    catch (ArgumentException ex)
    {
        return BadRequest(new ApiResponse<AuthResponse>(false, null, ex.Message));
    }
}

/// <summary>
/// Authenticate with OAuth ID token (for mobile/SPA clients)
/// </summary>
[HttpPost("oauth/token")]
public async Task<ActionResult<ApiResponse<AuthResponse>>> OAuthToken([FromBody] OAuthTokenRequest request, CancellationToken cancellationToken)
{
    try
    {
        var result = await _oAuthService.ValidateIdTokenAsync(request, cancellationToken);

        if (result == null)
        {
            return Unauthorized(new ApiResponse<AuthResponse>(false, null, "OAuth token validation failed."));
        }

        return Ok(new ApiResponse<AuthResponse>(true, result, "OAuth authentication successful."));
    }
    catch (ArgumentException ex)
    {
        return BadRequest(new ApiResponse<AuthResponse>(false, null, ex.Message));
    }
}
```

4. Add required using statements at the top of the file

5. Verify build succeeds

---

### STEP-OAUTH-BE-012

**Status:** done
**Task:** Register OAuth Services in DI Container
**Files:** `src/DnDMapBuilder.Api/Program.cs`

**Instructions:**

1. Read the current Program.cs file

2. Add OAuth settings configuration:

```csharp
builder.Services.Configure<OAuthSettings>(builder.Configuration.GetSection("OAuth"));
```

3. Register OAuth services:

```csharp
// OAuth Services
builder.Services.AddHttpClient<GoogleOAuthService>();
builder.Services.AddHttpClient<AppleOAuthService>();
builder.Services.AddScoped<IOAuthService, OAuthService>();
```

4. Ensure the services are registered after other authentication services

5. Add required using statements

6. Verify build succeeds: `dotnet build`

---

### STEP-OAUTH-BE-013

**Status:** done
**Task:** Update UserDto to Include OAuth Fields
**Files:** `src/DnDMapBuilder.Contracts/DTOs/UserDto.cs`, `src/DnDMapBuilder.Application/Mappings/UserMappings.cs`

**Instructions:**

1. Update `UserDto.cs` to include OAuth fields:

```csharp
public record UserDto(
    string Id,
    string Username,
    string Email,
    string Role,
    string Status,
    string? OAuthProvider = null,
    string? ProfilePictureUrl = null,
    bool EmailVerified = false
);
```

2. Update `UserMappings.cs` to map the new fields:

```csharp
public static UserDto ToDto(this User user)
{
    return new UserDto(
        user.Id,
        user.Username,
        user.Email,
        user.Role,
        user.Status,
        user.OAuthProvider,
        user.ProfilePictureUrl,
        user.EmailVerified
    );
}
```

3. Verify build succeeds

---

### STEP-OAUTH-BE-014

**Status:** done
**Task:** Add CORS Configuration for OAuth
**Files:** `src/DnDMapBuilder.Api/Program.cs`

**Instructions:**

1. Ensure CORS policy allows the frontend origin:

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        policy.WithOrigins(
                builder.Configuration["OAuth:FrontendRedirectUri"]?.TrimEnd('/') ?? "http://localhost:3000"
            )
            .AllowAnyHeader()
            .AllowAnyMethod()
            .AllowCredentials();
    });
});
```

2. Apply CORS middleware (should already exist, verify it's before UseRouting):

```csharp
app.UseCors("AllowFrontend");
```

3. Verify build succeeds

---

### STEP-OAUTH-BE-015

**Status:** done
**Task:** Write Unit Tests for OAuth Services
**Files:** `tests/DnDMapBuilder.Application.Tests/Services/OAuthServiceTests.cs`

**Instructions:**

1. Create test file for OAuth service:

```csharp
using Xunit;
using Moq;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Data.Repositories.Interfaces;

namespace DnDMapBuilder.Application.Tests.Services;

public class OAuthServiceTests
{
    [Fact]
    public async Task GetAuthorizationUrlAsync_Google_ReturnsValidUrl()
    {
        // Arrange & Act & Assert
        // Test implementation
    }

    [Fact]
    public async Task GetAuthorizationUrlAsync_Apple_ReturnsValidUrl()
    {
        // Test implementation
    }

    [Fact]
    public async Task GetAuthorizationUrlAsync_InvalidProvider_ThrowsArgumentException()
    {
        // Test implementation
    }

    [Fact]
    public async Task HandleOAuthCallbackAsync_ValidGoogleCode_ReturnsAuthResponse()
    {
        // Test implementation with mocked Google service
    }

    [Fact]
    public async Task ValidateIdTokenAsync_ValidGoogleToken_CreatesNewUser()
    {
        // Test implementation
    }

    [Fact]
    public async Task ValidateIdTokenAsync_ExistingUser_LinksOAuthProvider()
    {
        // Test implementation
    }
}
```

2. Run tests: `dotnet test`

---

### STEP-OAUTH-BE-016

**Status:** done
**Task:** Update API Documentation
**Files:** `API_DOCUMENTATION.md`

**Instructions:**

1. Add OAuth endpoints documentation:

```markdown
## OAuth Authentication

### Get OAuth Authorization URL
- **Endpoint**: `GET /api/v1/auth/oauth/{provider}/url`
- **Parameters**:
  - `provider` (path): OAuth provider ("google" or "apple")
  - `redirectUri` (query, optional): Custom redirect URI
- **Response**:
  ```json
  {
    "success": true,
    "data": {
      "authorizationUrl": "https://accounts.google.com/o/oauth2/v2/auth?...",
      "state": "random-state-string"
    }
  }
  ```

### OAuth Callback (Authorization Code Flow)
- **Endpoint**: `POST /api/v1/auth/oauth/callback`
- **Body**:
  ```json
  {
    "provider": "google",
    "code": "authorization-code-from-provider",
    "redirectUri": "https://your-app.com/callback"
  }
  ```
- **Response**: Same as login endpoint

### OAuth Token Validation (For Mobile/SPA)
- **Endpoint**: `POST /api/v1/auth/oauth/token`
- **Body**:
  ```json
  {
    "provider": "google",
    "idToken": "id-token-from-google-sdk"
  }
  ```
- **Response**: Same as login endpoint
```

2. Save changes

---

### STEP-OAUTH-BE-017

**Status:** done
**Task:** Final Build and Integration Testing
**Files:** All modified files

**Instructions:**

1. Run full build:
```bash
dotnet build
```

2. Run all tests:
```bash
dotnet test
```

3. Start the API:
```bash
dotnet run --project src/DnDMapBuilder.Api
```

4. Test OAuth URL generation:
```bash
curl http://localhost:5000/api/v1/auth/oauth/google/url
```

5. Verify Swagger documentation shows new endpoints

6. Fix any remaining issues

---

## Environment Variables Required

For production deployment, ensure these environment variables are set:

```
OAuth__Google__ClientId=your-google-client-id
OAuth__Google__ClientSecret=your-google-client-secret
OAuth__Apple__ClientId=your-apple-client-id
OAuth__Apple__TeamId=your-apple-team-id
OAuth__Apple__KeyId=your-apple-key-id
OAuth__Apple__PrivateKey=base64-encoded-private-key
OAuth__RedirectUri=https://api.yourdomain.com/api/v1/auth/oauth/callback
OAuth__FrontendRedirectUri=https://yourdomain.com
```

---

## Summary

**Total Steps:** 17

**Files Modified:**
- 1 .csproj file (packages)
- 1 Entity file
- 1 Migration
- 2 Configuration files
- 3 Contract files (DTOs)
- 1 Interface file
- 4 Service files
- 1 Controller file
- 1 DI registration file
- 1 Test file
- 1 Documentation file

**Key Features:**
- Google OAuth support
- Apple OAuth support
- Authorization code flow
- ID token validation (for mobile/SPA)
- Automatic user creation
- Account linking for existing users
- CSRF protection via state parameter
</file>

<file path="README.md">
# DnD Map Builder - Backend API

A comprehensive ASP.NET Web API for managing D&D campaigns, missions, maps, and tokens with authentication and authorization.

## Architecture

The solution follows a layered architecture with clean separation of concerns:

### Project Organization

- **DnDMapBuilder.Contracts**: DTOs, Requests, and Response models
- **DnDMapBuilder.Data**: Entity Framework Core, Entities, DbContext, and Repositories
- **DnDMapBuilder.Application**: Business logic, services, and domain validation
- **DnDMapBuilder.Infrastructure**: Cross-cutting concerns (logging, telemetry, middleware, security)
- **DnDMapBuilder.Api**: ASP.NET Core Web API with controllers and route handlers
- **DnDMapBuilder.UnitTests**: Unit tests with mocked dependencies
- **DnDMapBuilder.IntegrationTests**: Integration tests with real database
- **DnDMapBuilder.ArchitectureTests**: Architectural rule enforcement

### Layered Architecture

```
Client (Frontend)
    ↓
API Layer (Controllers, Routes)
    ↓
Application Layer (Services, Business Logic)
    ↓
Data Layer (Repositories, EF Core)
    ↓
Database (SQL Server)
```

**Separation of Concerns:**
- Controllers handle HTTP concerns only
- Services handle business logic
- Repositories handle data access
- Entities are database models (not exposed to clients)
- DTOs are used for API contracts

## Prerequisites

- .NET 10.0 SDK
- Docker Desktop (for containerized deployment and SQL Server)
- Visual Studio 2022 or Visual Studio Code
- SQL Server 2022 (local or cloud-based)
- Git for version control

## Getting Started

### Option 1: Run with .NET Aspire (Recommended)

.NET Aspire orchestrates the SQL Server database and API application in Docker containers.

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd DnDMapBuilder
   ```

2. **Set SQL Server password**
   
   When running for the first time, Aspire will prompt for a SQL Server password. You can also set it via:
   ```bash
   dotnet user-secrets set Parameters:sql-password "YourStrong@Passw0rd" --project src/DnDMapBuilder.Aspire.AppHost
   ```

3. **Run the Aspire AppHost**
   ```bash
   cd src/DnDMapBuilder.Aspire.AppHost
   dotnet run
   ```

4. **Access the application**
   - Aspire Dashboard: https://localhost:17001 (or check console output)
   - API: https://localhost:7001 (check Aspire dashboard for actual port)
   - Swagger UI: https://localhost:7001/swagger

### Option 2: Run API Directly

1. **Set up SQL Server**
   
   Update the connection string in `src/DnDMapBuilder.Api/appsettings.json`:
   ```json
   "ConnectionStrings": {
     "DefaultConnection": "Server=localhost;Database=DnDMapBuilder;User Id=sa;Password=YourPassword;TrustServerCertificate=True;"
   }
   ```

2. **Run migrations**
   ```bash
   cd src/DnDMapBuilder.Api
   dotnet ef database update
   ```

3. **Run the API**
   ```bash
   dotnet run
   ```

4. **Access Swagger UI**
   - Navigate to: https://localhost:5001/swagger

## Database Migrations

To create a new migration:

```bash
cd src/DnDMapBuilder.Api
dotnet ef migrations add <MigrationName> --project ../DnDMapBuilder.Data
```

To update the database:

```bash
dotnet ef database update --project ../DnDMapBuilder.Data
```

## Default Admin Account

A default admin account is seeded automatically:

- **Email**: admin@dndmapbuilder.com
- **Password**: Admin123!
- **Role**: admin
- **Status**: approved

## API Endpoints

### Authentication

- `POST /api/auth/register` - Register a new user (requires admin approval)
- `POST /api/auth/login` - Login and receive JWT token
- `GET /api/auth/pending-users` - Get pending user registrations (Admin only)
- `POST /api/auth/approve-user` - Approve/reject user registration (Admin only)

### Campaigns

- `GET /api/campaigns` - Get all campaigns for the authenticated user
- `GET /api/campaigns/{id}` - Get a specific campaign
- `POST /api/campaigns` - Create a new campaign
- `PUT /api/campaigns/{id}` - Update a campaign
- `DELETE /api/campaigns/{id}` - Delete a campaign

### Missions

- `GET /api/missions/{id}` - Get a specific mission
- `GET /api/missions/campaign/{campaignId}` - Get all missions for a campaign
- `POST /api/missions` - Create a new mission
- `PUT /api/missions/{id}` - Update a mission
- `DELETE /api/missions/{id}` - Delete a mission

### Maps

- `GET /api/maps/{id}` - Get a specific map
- `GET /api/maps/mission/{missionId}` - Get all maps for a mission
- `POST /api/maps` - Create a new map
- `PUT /api/maps/{id}` - Update a map (including tokens)
- `DELETE /api/maps/{id}` - Delete a map

### Tokens

- `GET /api/tokens` - Get all tokens for the authenticated user
- `GET /api/tokens/{id}` - Get a specific token
- `POST /api/tokens` - Create a new token
- `PUT /api/tokens/{id}` - Update a token
- `DELETE /api/tokens/{id}` - Delete a token

## Authentication

The API uses JWT Bearer token authentication. To authenticate:

1. Register or login via `/api/auth/register` or `/api/auth/login`
2. Copy the token from the response
3. In Swagger UI, click "Authorize" and enter: `Bearer <your-token>`
4. Or include the header in your requests: `Authorization: Bearer <your-token>`

## Configuration

### JWT Settings

Update in `appsettings.json`:

```json
"JwtSettings": {
  "SecretKey": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
  "Issuer": "DnDMapBuilderApi",
  "Audience": "DnDMapBuilderClient",
  "ExpirationMinutes": "1440"
}
```

### CORS

CORS is configured via `CorsSettings` in `appsettings.json`:

```json
"CorsSettings": {
  "AllowedOrigins": [
    "http://localhost:3000",
    "https://yourdomain.com"
  ]
}
```

## Security Features

The API includes several security features by default:

### Security Headers

The following security headers are automatically included in all responses:
- `X-Content-Type-Options: nosniff` - Prevent MIME sniffing
- `X-Frame-Options: DENY` - Prevent clickjacking
- `X-XSS-Protection: 1; mode=block` - Enable XSS protection
- `Strict-Transport-Security: max-age=31536000` - Force HTTPS
- `Content-Security-Policy: default-src 'self'` - Restrict content to same-origin
- `Referrer-Policy: strict-origin-when-cross-origin` - Control referrer information
- `Permissions-Policy: geolocation=(), microphone=(), camera=()` - Disable dangerous APIs

### Rate Limiting

Rate limiting is enabled to prevent abuse:
- **Anonymous users**: 100 requests per minute (IP-based)
- **Authenticated users**: 300 requests per minute (User ID-based)
- **File uploads**: 10 requests per minute

Exceeded rate limits return HTTP 429 (Too Many Requests) with a Retry-After header.

### Request/Response Logging

All HTTP requests and responses are logged with:
- Request method, path, query string, and user identity
- Response status code and duration
- Correlation IDs for request tracing
- Sensitive headers (Authorization, Cookie) are sanitized in logs

### API Versioning

The API supports versioning via URL path. Current version is **v1.0**.

Routes follow the pattern: `/api/v{version:apiVersion}/[controller]`

Example: `/api/v1.0/auth/login`

## Testing

### Running Tests

Execute all tests:
```bash
dotnet test
```

Run only unit tests:
```bash
dotnet test --filter Category=Unit
```

Run only integration tests (requires database):
```bash
dotnet test --filter Category=Integration
```

Run only architecture tests:
```bash
dotnet test --filter Category=Architecture
```

### Test Coverage

The project includes:
- **75+ Unit Tests**: Services, repositories, entities, and utilities
- **8 Architecture Tests**: Enforce layered architecture and design principles
- **7 Integration Tests**: Database operations and API endpoints (with database)

Target coverage: >80% for core business logic

### Running Tests in CI/CD

Tests are automatically run in the GitHub Actions pipeline on every push to `main` or `develop` branches.

## Monitoring and Logging

### Application Logging

Structured logging is configured with Serilog:
- **Console**: Real-time log output in development
- **File**: Rolling file logs (daily rotation, 100MB max size)
- **Structured JSON**: Machine-readable log format

### Optional: External Monitoring

You can configure optional monitoring integrations by setting secrets in GitHub:

#### Azure Application Insights
```bash
APPLICATIONINSIGHTS_CONNECTION_STRING=<your-connection-string>
```

#### OpenTelemetry (OTEL)
```bash
OTEL_EXPORTER_OTLP_ENDPOINT=http://your-otel-collector:4317
```

#### Log Level Configuration
```bash
LOG_LEVEL=Information  # Options: Debug, Information, Warning, Error, Critical
```

## Docker Support

The Aspire AppHost automatically manages Docker containers for:

- SQL Server 2022 (with persistent data volume)
- The API application

Container orchestration is handled automatically by .NET Aspire.

## Project Structure

```
DnDMapBuilder/
├── src/
│   ├── DnDMapBuilder.Api/           # Web API Controllers
│   ├── DnDMapBuilder.Application/   # Business Logic & Services
│   ├── DnDMapBuilder.Contracts/     # DTOs & Request/Response Models
│   ├── DnDMapBuilder.Data/          # EF Core, Entities, Repositories
│   ├── DnDMapBuilder.Aspire.AppHost/         # Aspire Orchestration
│   └── DnDMapBuilder.Aspire.ServiceDefaults/ # Shared Aspire Config
└── DnDMapBuilder.sln
```

## Technologies Used

**Core Framework:**
- .NET 10.0
- ASP.NET Core Web API
- Entity Framework Core 10.0
- SQL Server 2022 / Azure SQL Edge

**Authentication & Security:**
- JWT Bearer Token Authentication
- BCrypt.Net for secure password hashing
- Security headers middleware
- CORS policy enforcement
- Rate limiting

**API Documentation & Testing:**
- Swagger/OpenAPI with XML documentation
- xUnit testing framework
- FluentAssertions for readable test assertions
- Moq for mocking dependencies
- AutoFixture for test data generation

**Logging & Observability:**
- Serilog for structured logging
- OpenTelemetry for distributed tracing
- Health checks endpoints
- Request/response logging middleware

**Infrastructure & Deployment:**
- Docker containerization
- GitHub Actions for CI/CD
- Alpine Linux for minimal image size
- Non-root container user for security

## Development

### Running Tests

```bash
dotnet test
```

### Code Style

The project follows standard C# coding conventions with nullable reference types enabled.

## Continuous Integration & Deployment

### GitHub Actions Pipeline

The project includes automated CI/CD pipeline (`.github/workflows/main.yml`) that:

1. **Build & Test** (on every push)
   - Restores dependencies
   - Builds in Release mode
   - Runs all unit, integration, and architecture tests

2. **Docker Image Build** (on main branch only)
   - Builds multi-platform Docker image (linux/amd64, linux/arm64)
   - Pushes to GitHub Container Registry (ghcr.io)
   - Uses layer caching for faster builds

3. **Deployment** (on main branch only)
   - Creates Docker network if needed
   - Runs database migrations
   - Deploys API container with health checks
   - Verifies deployment with health endpoints
   - Cleans up old images

### Required GitHub Secrets

To enable CI/CD deployment, configure these secrets in GitHub repository settings:

| Secret | Description | Example |
|--------|-------------|---------|
| `DB_CONNECTION_STRING` | SQL Server connection string | `Server=your-server;Database=dndmapbuilder;User Id=sa;Password=***;` |
| `SERVER_HOST` | Deployment server hostname | `api.example.com` |
| `SERVER_USERNAME` | SSH username for deployment | `deploy` |
| `SSH_PRIVATE_KEY` | SSH private key for authentication | (SSH RSA private key) |
| `SERVER_PORT` | SSH port (optional) | `22` |

### Optional Monitoring Secrets

Configure these secrets if using external monitoring services:

| Secret | Description |
|--------|-------------|
| `APPLICATIONINSIGHTS_CONNECTION_STRING` | Azure Application Insights connection string |
| `OTEL_EXPORTER_OTLP_ENDPOINT` | OpenTelemetry collector endpoint |

### Deployment Flow

```
Push to main
    ↓
Run tests in GitHub
    ↓
Build Docker image
    ↓
Push to container registry
    ↓
SSH to deployment server
    ↓
Pull latest image
    ↓
Run database migrations
    ↓
Start new API container
    ↓
Verify health checks
```

### Local Docker Deployment

To test deployment locally:

```bash
# Build Docker image
docker build -t dnd-api:latest -f src/DnDMapBuilder.Api/Dockerfile .

# Create network
docker network create dnd-network

# Run migrations
docker run --rm \
  -e ConnectionStrings__DefaultConnection="<connection-string>" \
  dnd-api:latest \
  sh -c "dotnet ef database update --project src/DnDMapBuilder.Data --startup-project src/DnDMapBuilder.Api"

# Start API container
docker run -d \
  --name dnd-api \
  -p 5000:8080 \
  -e ASPNETCORE_ENVIRONMENT=Production \
  -e ConnectionStrings__DefaultConnection="<connection-string>" \
  --network dnd-network \
  dnd-api:latest

# Check health
curl http://localhost:5000/health/live
```

## License

This project is licensed under the MIT License.
</file>

<file path="SECURITY.md">
# Security Policy and Procedures

## Overview

This document outlines the security measures, best practices, and incident response procedures for the DnDMapBuilder backend API.

## Security Features

### Authentication

- **JWT (JSON Web Tokens)** for stateless authentication
  - Configurable secret key (via environment or Key Vault)
  - HS256 signing algorithm
  - Configurable expiration (default: 24 hours)
  - Token validation includes issuer, audience, and signature checks
  - Location: `src/DnDMapBuilder.Infrastructure/Security/JwtService.cs`

### Authorization

- **Role-Based Access Control (RBAC)**
  - User role: Standard user with personal resource access
  - Admin role: Administrative operations (user approval, etc.)
  - Authorization enforced via `[Authorize]` and `[Authorize(Roles = "admin")]` attributes
  - Per-resource ownership verification for multi-tenant scenarios

### Password Security

- **BCrypt hashing** with configurable work factor
- Passwords are hashed before storage
- Password verification without storing plaintext
- Unit tests verify hash security and uniqueness
- Service: `src/DnDMapBuilder.Application/Services/PasswordService.cs`

## Data Protection

### HTTPS/TLS

- HTTPS enforcement via middleware: `app.UseHttpsRedirection()`
- All API communications encrypted in transit
- TLS 1.2+ enforced by ASP.NET Core defaults

### Secrets Management

#### Development Environment
```bash
# Set up local secrets (not in source control)
dotnet user-secrets init
dotnet user-secrets set "JwtSettings:SecretKey" "your-dev-secret-key"
dotnet user-secrets set "ConnectionStrings:DefaultConnection" "your-dev-connection-string"
```

#### Production Environment
- **Recommended:** Azure Key Vault or HashiCorp Vault
- Environment variables for secrets:
  - `JwtSettings__SecretKey`
  - `ConnectionStrings__DefaultConnection`
  - `Database__ConnectionString`

### SQL Injection Prevention

- **Entity Framework Core** with parameterized queries
- All LINQ queries use parameter placeholders
- No string concatenation or raw SQL for user-provided data

### XSS Protection

- **Security Headers Middleware** configured:
  - X-Content-Type-Options: nosniff
  - X-Frame-Options: DENY
  - X-XSS-Protection: 1; mode=block
  - Strict-Transport-Security for HTTPS enforcement
  - Content-Security-Policy: default-src 'self'

### CORS (Cross-Origin Resource Sharing)

- Whitelist-based CORS configuration (not AllowAll)
- Configurable allowed origins
- Credentials support enabled for authenticated requests

## API Security

### Rate Limiting

- Anonymous users: 100 requests/minute
- Authenticated users: 300 requests/minute
- File uploads: 10 requests/minute
- Returns 429 (Too Many Requests) with Retry-After header

### File Upload Security

- File size limits: Maps (5MB), Tokens (2MB), Default (10MB)
- MIME type validation: image/png, image/jpeg, image/webp
- Storage isolation and directory traversal protection
- Comprehensive validation service with unit tests

## Logging and Monitoring

### Structured Logging

- Serilog for structured, machine-readable logs
- Correlation IDs for request tracing
- Sensitive data filtering to prevent leakage
- Environment-specific log levels (Debug in dev, Warning in prod)

### Request/Response Logging

- RequestResponseLoggingMiddleware logs requests, responses, and duration
- User identity tracking for authenticated requests
- Correlation ID propagation
- Excludes health check endpoints

### OpenTelemetry Tracing

- Distributed tracing for request flow
- Custom metrics for security events
- OTLP exporter for centralized collection

## OWASP Top 10 Compliance

| Vulnerability | Status | Details |
|---|---|---|
| A01: Broken Access Control | ✓ | Authorization checks; resource ownership verified |
| A02: Cryptographic Failures | ✓ | HTTPS enforced; BCrypt hashing; no hardcoded secrets |
| A03: Injection | ✓ | EF Core parameterized queries; no command injection |
| A04: Insecure Design | ✓ | Security headers; rate limiting; authentication required |
| A05: Security Misconfiguration | ✓ | Security headers; proper CORS; reduced SQL logging |
| A06: Vulnerable Components | ✓ | No vulnerable packages; .NET 10.0 latest |
| A07: Authentication Failures | ✓ | JWT; BCrypt; user status verification |
| A08: Data Integrity | ✓ | Secure CI/CD; code review required |
| A09: Logging & Monitoring | ✓ | Serilog; request logging; OpenTelemetry tracing |
| A10: SSRF | ✓ | No user-controlled URLs; no untrusted outbound requests |

## Dependency Vulnerability Status

**Result:** No vulnerable packages identified
- All NuGet packages up-to-date
- Regular automated scanning recommended
- .NET 10.0 runtime (latest stable)

## Best Practices for Deployment

### Pre-Deployment Checklist

- [ ] All tests passing (unit, integration, architecture)
- [ ] No vulnerable dependencies (`dotnet list package --vulnerable`)
- [ ] Secrets configured in Key Vault (not in code)
- [ ] CORS origins configured for production domain
- [ ] Security headers configured and tested
- [ ] Database migrations tested
- [ ] Health checks verified
- [ ] Monitoring and alerting configured

### Security Update Frequency

- Critical: Immediate (within 24 hours)
- High: Within 1 week
- Medium: Within 2 weeks
- Low: Next scheduled release

## Incident Response

### Reporting Security Issues

DO NOT create public GitHub issues for security vulnerabilities.

Contact project maintainers directly with:
- Detailed vulnerability description
- Reproduction steps
- Severity assessment
- Allow 30 days for patch development

### Response Process

1. Acknowledge receipt within 24 hours
2. Assess severity and impact
3. Develop and test patch
4. Release security update with advisory
5. Notify affected users

## Regular Security Activities

- **Daily:** Monitor logs for errors; check health endpoints
- **Weekly:** Review auth logs; check dependency notifications
- **Monthly:** Security log analysis; vulnerability scanning
- **Quarterly:** Full security audit; penetration testing prep
- **Annually:** Third-party pen testing; compliance verification

## References

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [ASP.NET Core Security](https://learn.microsoft.com/aspnet/core/security)
- [JWT Best Practices](https://tools.ietf.org/html/rfc7519)
</file>

<file path="src/DnDMapBuilder.Application/Mappings/MappingExtensions.cs">
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Application.Mappings;
public static class MappingExtensions
{
    public static UserDto ToDto(this User user)
    {
        return new UserDto(
            user.Id,
            user.Username,
            user.Email,
            user.Role,
            user.Status,
            user.OAuthProvider,
            user.ProfilePictureUrl,
            user.EmailVerified
        );
    }
    public static TokenDefinitionDto ToDto(this TokenDefinition token)
    {
        return new TokenDefinitionDto(
            token.Id,
            token.Name,
            token.ImageUrl,
            token.Size,
            token.Type,
            token.UserId,
            token.ImageFileId,
            token.ImageContentType,
            token.ImageFileSize
        );
    }
    public static MapTokenInstanceDto ToDto(this MapTokenInstance instance)
    {
        return new MapTokenInstanceDto(
            instance.Id,
            instance.TokenId,
            instance.X,
            instance.Y
        );
    }
    public static GameMapDto ToDto(this GameMap map)
    {
        return new GameMapDto(
            map.Id,
            map.Name,
            map.ImageUrl,
            map.Rows,
            map.Cols,
            map.Tokens.Select(t => t.ToDto()).ToList(),
            map.GridColor,
            map.GridOpacity,
            map.MissionId,
            map.ImageFileId,
            map.ImageContentType,
            map.ImageFileSize
        );
    }
    public static MissionDto ToDto(this Mission mission)
    {
        return new MissionDto(
            mission.Id,
            mission.Name,
            mission.Description,
            mission.Maps.Select(m => m.ToDto()).ToList(),
            mission.CampaignId
        );
    }
    public static CampaignDto ToDto(this Campaign campaign)
    {
        return new CampaignDto(
            campaign.Id,
            campaign.Name,
            campaign.Description,
            campaign.Missions.Select(m => m.ToDto()).ToList(),
            campaign.OwnerId,
            campaign.CreatedAt,
            campaign.UpdatedAt
        );
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/CampaignService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class CampaignService : ICampaignService
{
    private readonly ICampaignRepository _campaignRepository;
    public CampaignService(ICampaignRepository campaignRepository)
    {
        _campaignRepository = campaignRepository;
    }
    public async Task<CampaignDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetCompleteAsync(id, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }
        return campaign.ToDto();
    }
    public async Task<IEnumerable<CampaignDto>> GetUserCampaignsAsync(string userId, CancellationToken cancellationToken = default)
    {
        var campaigns = await _campaignRepository.GetByOwnerIdAsync(userId, cancellationToken);
        return campaigns.Select(c => c.ToDto());
    }
    public async Task<CampaignDto> CreateAsync(CreateCampaignRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = new Campaign
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            Description = request.Description,
            OwnerId = userId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        await _campaignRepository.AddAsync(campaign, cancellationToken);
        return campaign.ToDto();
    }
    public async Task<CampaignDto?> UpdateAsync(string id, UpdateCampaignRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(id, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }
        campaign.Name = request.Name;
        campaign.Description = request.Description;
        campaign.UpdatedAt = DateTime.UtcNow;
        await _campaignRepository.UpdateAsync(campaign, cancellationToken);
        return campaign.ToDto();
    }
    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(id, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return false;
        }
        await _campaignRepository.DeleteAsync(id, cancellationToken);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/Services/MissionService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Mappings;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class MissionService : IMissionService
{
    private readonly IMissionRepository _missionRepository;
    private readonly ICampaignRepository _campaignRepository;
    public MissionService(IMissionRepository missionRepository, ICampaignRepository campaignRepository)
    {
        _missionRepository = missionRepository;
        _campaignRepository = campaignRepository;
    }
    public async Task<MissionDto?> GetByIdAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetWithMapsAsync(id, cancellationToken);
        if (mission == null)
        {
            return null;
        }
        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }
        return mission.ToDto();
    }
    public async Task<IEnumerable<MissionDto>> GetByCampaignIdAsync(string campaignId, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(campaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return Enumerable.Empty<MissionDto>();
        }
        var missions = await _missionRepository.GetByCampaignIdAsync(campaignId, cancellationToken);
        return missions.Select(m => m.ToDto());
    }
    public async Task<MissionDto> CreateAsync(CreateMissionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var campaign = await _campaignRepository.GetByIdAsync(request.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            throw new UnauthorizedAccessException("You don't have permission to add missions to this campaign.");
        }
        var mission = new Mission
        {
            Id = Guid.NewGuid().ToString(),
            Name = request.Name,
            Description = request.Description,
            CampaignId = request.CampaignId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        await _missionRepository.AddAsync(mission, cancellationToken);
        return mission.ToDto();
    }
    public async Task<MissionDto?> UpdateAsync(string id, UpdateMissionRequest request, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetByIdAsync(id, cancellationToken);
        if (mission == null)
        {
            return null;
        }
        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return null;
        }
        mission.Name = request.Name;
        mission.Description = request.Description;
        mission.UpdatedAt = DateTime.UtcNow;
        await _missionRepository.UpdateAsync(mission, cancellationToken);
        return mission.ToDto();
    }
    public async Task<bool> DeleteAsync(string id, string userId, CancellationToken cancellationToken = default)
    {
        var mission = await _missionRepository.GetByIdAsync(id, cancellationToken);
        if (mission == null)
        {
            return false;
        }
        var campaign = await _campaignRepository.GetByIdAsync(mission.CampaignId, cancellationToken);
        if (campaign == null || campaign.OwnerId != userId)
        {
            return false;
        }
        await _missionRepository.DeleteAsync(id, cancellationToken);
        return true;
    }
}
</file>

<file path="src/DnDMapBuilder.Application/DnDMapBuilder.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
    <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="8.15.0" />
    <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.15.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Data/Repositories/CampaignRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Data.Repositories;
public class CampaignRepository : GenericRepository<Campaign>, ICampaignRepository
{
    public CampaignRepository(DnDMapBuilderDbContext context) : base(context) { }
    public async Task<IEnumerable<Campaign>> GetByOwnerIdAsync(string ownerId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(c => c.OwnerId == ownerId)
            .Include(c => c.Missions)
            .ToListAsync(cancellationToken);
    }
    public async Task<Campaign?> GetWithMissionsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(c => c.Missions)
            .FirstOrDefaultAsync(c => c.Id == id, cancellationToken);
    }
    public async Task<Campaign?> GetCompleteAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(c => c.Missions)
                .ThenInclude(m => m.Maps)
                    .ThenInclude(map => map.Tokens)
            .FirstOrDefaultAsync(c => c.Id == id, cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/GameMapRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Data.Repositories;
public class GameMapRepository : GenericRepository<GameMap>, IGameMapRepository
{
    public GameMapRepository(DnDMapBuilderDbContext context) : base(context) { }
    public async Task<IEnumerable<GameMap>> GetByMissionIdAsync(string missionId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(m => m.MissionId == missionId)
            .Include(m => m.Tokens)
            .ToListAsync(cancellationToken);
    }
    public async Task<GameMap?> GetWithTokensAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(m => m.Tokens)
            .FirstOrDefaultAsync(m => m.Id == id, cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/MapTokenInstanceRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Data.Repositories;
public class MapTokenInstanceRepository : GenericRepository<MapTokenInstance>, IMapTokenInstanceRepository
{
    public MapTokenInstanceRepository(DnDMapBuilderDbContext context) : base(context) { }
    public async Task<IEnumerable<MapTokenInstance>> GetByMapIdAsync(string mapId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(t => t.MapId == mapId)
            .Include(t => t.Token)
            .ToListAsync(cancellationToken);
    }
    public async Task DeleteByMapIdAsync(string mapId, CancellationToken cancellationToken = default)
    {
        var tokens = await _dbSet.Where(t => t.MapId == mapId).ToListAsync(cancellationToken);
        _dbSet.RemoveRange(tokens);
        await _context.SaveChangesAsync(cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/MissionRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Data.Repositories;
public class MissionRepository : GenericRepository<Mission>, IMissionRepository
{
    public MissionRepository(DnDMapBuilderDbContext context) : base(context) { }
    public async Task<IEnumerable<Mission>> GetByCampaignIdAsync(string campaignId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(m => m.CampaignId == campaignId)
            .Include(m => m.Maps)
            .ToListAsync(cancellationToken);
    }
    public async Task<Mission?> GetWithMapsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Include(m => m.Maps)
            .FirstOrDefaultAsync(m => m.Id == id, cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/TokenDefinitionRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Data.Repositories;
public class TokenDefinitionRepository : GenericRepository<TokenDefinition>, ITokenDefinitionRepository
{
    public TokenDefinitionRepository(DnDMapBuilderDbContext context) : base(context) { }
    public async Task<IEnumerable<TokenDefinition>> GetByUserIdAsync(string userId, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(t => t.UserId == userId)
            .ToListAsync(cancellationToken);
    }
    public async Task<IEnumerable<TokenDefinition>> GetByTypeAsync(string type, CancellationToken cancellationToken = default)
    {
        return await _dbSet
            .AsNoTracking()
            .Where(t => t.Type == type)
            .ToListAsync(cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/MigrationRunner.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
namespace DnDMapBuilder.Data;
public class MigrationRunner
{
    private readonly DnDMapBuilderDbContext _context;
    private readonly ILogger<MigrationRunner> _logger;
    public MigrationRunner(DnDMapBuilderDbContext context, ILogger<MigrationRunner> logger)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
    public async Task<bool> MigrateAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("Starting database migration...");
            var pendingMigrations = (await _context.Database.GetPendingMigrationsAsync(cancellationToken)).ToList();
            if (pendingMigrations.Any())
            {
                _logger.LogInformation("Found {PendingMigrationCount} pending migrations: {Migrations}",
                    pendingMigrations.Count,
                    string.Join(", ", pendingMigrations));
                await _context.Database.MigrateAsync(cancellationToken);
                _logger.LogInformation(" Database migrations completed successfully");
            }
            else
            {
                _logger.LogInformation(" Database is up to date. No migrations to apply.");
            }
            _logger.LogInformation("Initializing database with seed data...");
            await DbInitializer.InitializeAsync(_context);
            _logger.LogInformation(" Database initialization completed successfully");
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error occurred during database migration");
            return false;
        }
    }
    public async Task<bool> MigrateOnlyAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("Starting database migration (migration only, no seeding)...");
            var pendingMigrations = (await _context.Database.GetPendingMigrationsAsync(cancellationToken)).ToList();
            if (pendingMigrations.Any())
            {
                _logger.LogInformation("Found {PendingMigrationCount} pending migrations: {Migrations}",
                    pendingMigrations.Count,
                    string.Join(", ", pendingMigrations));
                await _context.Database.MigrateAsync(cancellationToken);
                _logger.LogInformation("Database migrations completed successfully");
            }
            else
            {
                _logger.LogInformation("Database is up to date. No migrations to apply.");
            }
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error occurred during database migration");
            return false;
        }
    }
    public async Task<DatabaseInfo> GetDatabaseInfoAsync(CancellationToken cancellationToken = default)
    {
        var appliedMigrations = (await _context.Database.GetAppliedMigrationsAsync(cancellationToken)).ToList();
        var pendingMigrations = (await _context.Database.GetPendingMigrationsAsync(cancellationToken)).ToList();
        return new DatabaseInfo
        {
            AppliedMigrationsCount = appliedMigrations.Count,
            AppliedMigrations = appliedMigrations,
            PendingMigrationsCount = pendingMigrations.Count,
            PendingMigrations = pendingMigrations,
            IsDatabaseCreated = await _context.Database.CanConnectAsync(cancellationToken)
        };
    }
}
public class DatabaseInfo
{
    public int AppliedMigrationsCount { get; set; }
    public List<string> AppliedMigrations { get; set; } = new();
    public int PendingMigrationsCount { get; set; }
    public List<string> PendingMigrations { get; set; } = new();
    public bool IsDatabaseCreated { get; set; }
    public override string ToString()
    {
        return $"Database Info:\n" +
               $"  - Is Created: {IsDatabaseCreated}\n" +
               $"  - Applied Migrations: {AppliedMigrationsCount}\n" +
               $"    {string.Join("\n    ", AppliedMigrations.Select(m => $"{m}"))}\n" +
               $"  - Pending Migrations: {PendingMigrationsCount}\n" +
               $"    {string.Join("\n    ", PendingMigrations.Select(m => $"{m}"))}";
    }
}
</file>

<file path="src/DnDMapBuilder.IntegrationTests/DnDMapBuilder.IntegrationTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- xUnit Testing Framework -->
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />

    <!-- Assertion Library -->
    <PackageReference Include="FluentAssertions" Version="8.8.0" />

    <!-- ASP.NET Core Testing -->
    <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="10.0.2" />

    <!-- Database Testing -->
    <PackageReference Include="Testcontainers" Version="4.10.0" />
    <PackageReference Include="Testcontainers.MsSql" Version="4.10.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="10.0.2" />

    <!-- Test Data Generation -->
    <PackageReference Include="AutoFixture.Xunit2" Version="4.18.1" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.UnitTests/Repositories/GenericRepositoryTests.cs">
using Microsoft.EntityFrameworkCore;
using Xunit;
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories;
namespace DnDMapBuilder.UnitTests.Repositories;
public class GenericRepositoryTests
{
    private DnDMapBuilderDbContext CreateInMemoryDbContext()
    {
        var options = new DbContextOptionsBuilder<DnDMapBuilderDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
        return new DnDMapBuilderDbContext(options);
    }
    [Fact]
    public async Task AddAsync_ShouldAddEntity_WhenCalledWithValidEntity()
    {
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);
        var user = new User
        {
            Id = Guid.NewGuid().ToString(),
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        await repository.AddAsync(user);
        await context.SaveChangesAsync();
        var addedUser = await repository.GetByIdAsync(user.Id);
        Assert.NotNull(addedUser);
        Assert.Equal("testuser", addedUser.Username);
    }
    [Fact]
    public async Task GetByIdAsync_ShouldReturnEntity_WhenEntityExists()
    {
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();
        var repository = new GenericRepository<User>(context);
        var retrievedUser = await repository.GetByIdAsync(userId);
        Assert.NotNull(retrievedUser);
        Assert.Equal(userId, retrievedUser.Id);
        Assert.Equal("testuser", retrievedUser.Username);
    }
    [Fact]
    public async Task GetByIdAsync_ShouldReturnNull_WhenEntityDoesNotExist()
    {
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);
        var result = await repository.GetByIdAsync("non-existent-id");
        Assert.Null(result);
    }
    [Fact]
    public async Task GetAllAsync_ShouldReturnAllEntities()
    {
        using var context = CreateInMemoryDbContext();
        var user1 = new User { Id = "1", Username = "user1", Email = "u1@test.com", PasswordHash = "hash", Role = "user", Status = "pending", CreatedAt = DateTime.UtcNow, UpdatedAt = DateTime.UtcNow };
        var user2 = new User { Id = "2", Username = "user2", Email = "u2@test.com", PasswordHash = "hash", Role = "user", Status = "pending", CreatedAt = DateTime.UtcNow, UpdatedAt = DateTime.UtcNow };
        context.Users.AddRange(user1, user2);
        await context.SaveChangesAsync();
        var repository = new GenericRepository<User>(context);
        var users = await repository.GetAllAsync();
        Assert.NotNull(users);
        Assert.Equal(2, users.Count());
    }
    [Fact]
    public async Task UpdateAsync_ShouldUpdateEntity_WhenCalledWithValidEntity()
    {
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "originalname",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();
        var repository = new GenericRepository<User>(context);
        user.Username = "updatedname";
        await repository.UpdateAsync(user);
        await context.SaveChangesAsync();
        var updatedUser = await repository.GetByIdAsync(userId);
        Assert.NotNull(updatedUser);
        Assert.Equal("updatedname", updatedUser.Username);
    }
    [Fact]
    public async Task DeleteAsync_ShouldDeleteEntity_WhenCalledWithValidId()
    {
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();
        var repository = new GenericRepository<User>(context);
        await repository.DeleteAsync(userId);
        var deletedUser = await repository.GetByIdAsync(userId);
        Assert.Null(deletedUser);
    }
    [Fact]
    public async Task ExistsAsync_ShouldReturnTrue_WhenEntityExists()
    {
        using var context = CreateInMemoryDbContext();
        var userId = Guid.NewGuid().ToString();
        var user = new User
        {
            Id = userId,
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        context.Users.Add(user);
        await context.SaveChangesAsync();
        var repository = new GenericRepository<User>(context);
        var exists = await repository.ExistsAsync(userId);
        Assert.True(exists);
    }
    [Fact]
    public async Task ExistsAsync_ShouldReturnFalse_WhenEntityDoesNotExist()
    {
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);
        var exists = await repository.ExistsAsync("non-existent-id");
        Assert.False(exists);
    }
    [Fact]
    public async Task AddAsync_ShouldRespectCancellationToken()
    {
        using var context = CreateInMemoryDbContext();
        var repository = new GenericRepository<User>(context);
        var user = new User
        {
            Id = Guid.NewGuid().ToString(),
            Username = "testuser",
            Email = "test@example.com",
            PasswordHash = "hash",
            Role = "user",
            Status = "pending",
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
        var cts = new CancellationTokenSource();
        cts.Cancel();
        try
        {
            await repository.AddAsync(user, cts.Token);
        }
        catch (OperationCanceledException)
        {
        }
    }
}
</file>

<file path=".claude/commands/execute_prompt_plan.md">
## You are a senior .NET engineer implementing refactorings 
- Read the @prompt_plan.md file and identify pending steps
- Create a new branch with the feature name from the context session if it does not exist. You only work on this branch
- Implement the step using TDD following DRY and SRP practices. 
- Run all tests and build the solution
- If both succeed  update the step status to done. Else fix the errors
- continue with the next step.
</file>

<file path="src/DnDMapBuilder.Application/Services/AuthService.cs">
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Application.Services;
public class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IJwtService _jwtService;
    private readonly IPasswordService _passwordService;
    public AuthService(IUserRepository userRepository, IJwtService jwtService, IPasswordService passwordService)
    {
        _userRepository = userRepository;
        _jwtService = jwtService;
        _passwordService = passwordService;
    }
    public async Task<AuthResponse?> LoginAsync(LoginRequest request, CancellationToken cancellationToken = default)
    {
        var user = await _userRepository.GetByEmailAsync(request.Email, cancellationToken);
        if (user == null)
        {
            return null;
        }
        if (!_passwordService.VerifyPassword(request.Password, user.PasswordHash))
        {
            return null;
        }
        if (user.Status != "approved" && user.Role != "admin")
        {
            return null;
        }
        var token = _jwtService.GenerateToken(user.Id, user.Email, user.Role);
        return new AuthResponse(
            token,
            user.Id,
            user.Username,
            user.Email,
            user.Role,
            user.Status
        );
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/Interfaces/IUserRepository.cs">
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Data.Repositories.Interfaces;
public interface IUserRepository : IGenericRepository<User>
{
    Task<User?> GetByEmailAsync(string email, CancellationToken cancellationToken = default);
    Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default);
    Task<IEnumerable<User>> GetPendingUsersAsync(CancellationToken cancellationToken = default);
    Task<IEnumerable<User>> GetActiveUsersAsync(CancellationToken cancellationToken = default);
    Task<IEnumerable<User>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default);
    Task<User?> GetByOAuthProviderAsync(string provider, string providerId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/DnDMapBuilder.UnitTests/DnDMapBuilder.UnitTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- xUnit Testing Framework -->
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.5">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />

    <!-- Assertion Library -->
    <PackageReference Include="FluentAssertions" Version="8.8.0" />

    <!-- Mocking Framework -->
    <PackageReference Include="Moq" Version="4.20.72" />
    <PackageReference Include="NSubstitute" Version="5.1.0" />

    <!-- Test Data Generation -->
    <PackageReference Include="AutoFixture.Xunit2" Version="4.18.1" />

    <!-- Entity Framework Core In-Memory Database for Unit Tests -->
    <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="10.0.0" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Api\DnDMapBuilder.Api.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Api/Controllers/CampaignsController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
namespace DnDMapBuilder.Api.Controllers;
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class CampaignsController : ControllerBase
{
    private readonly ICampaignService _campaignService;
    public CampaignsController(ICampaignService campaignService)
    {
        _campaignService = campaignService;
    }
    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();
    [HttpGet]
    [ResponseCache(CacheProfileName = "Default60")]
    public async Task<ActionResult<ApiResponse<IEnumerable<CampaignDto>>>> GetUserCampaigns(CancellationToken cancellationToken)
    {
        var campaigns = await _campaignService.GetUserCampaignsAsync(GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<CampaignDto>>(true, campaigns));
    }
    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "Default60")]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> GetCampaign(string id, CancellationToken cancellationToken)
    {
        var campaign = await _campaignService.GetByIdAsync(id, GetUserId(), cancellationToken);
        if (campaign == null)
        {
            return NotFound(new ApiResponse<CampaignDto>(false, null, "Campaign not found."));
        }
        return Ok(new ApiResponse<CampaignDto>(true, campaign));
    }
    [HttpPost]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> CreateCampaign([FromBody] CreateCampaignRequest request, CancellationToken cancellationToken)
    {
        var campaign = await _campaignService.CreateAsync(request, GetUserId(), cancellationToken);
        return CreatedAtAction(nameof(GetCampaign), new { id = campaign.Id }, new ApiResponse<CampaignDto>(true, campaign, "Campaign created."));
    }
    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<CampaignDto>>> UpdateCampaign(string id, [FromBody] UpdateCampaignRequest request, CancellationToken cancellationToken)
    {
        var campaign = await _campaignService.UpdateAsync(id, request, GetUserId(), cancellationToken);
        if (campaign == null)
        {
            return NotFound(new ApiResponse<CampaignDto>(false, null, "Campaign not found."));
        }
        return Ok(new ApiResponse<CampaignDto>(true, campaign, "Campaign updated."));
    }
    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteCampaign(string id, CancellationToken cancellationToken)
    {
        var result = await _campaignService.DeleteAsync(id, GetUserId(), cancellationToken);
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Campaign not found."));
        }
        return Ok(new ApiResponse<bool>(true, true, "Campaign deleted."));
    }
}
</file>

<file path="src/DnDMapBuilder.Api/Controllers/MissionsController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
namespace DnDMapBuilder.Api.Controllers;
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class MissionsController : ControllerBase
{
    private readonly IMissionService _missionService;
    public MissionsController(IMissionService missionService)
    {
        _missionService = missionService;
    }
    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();
    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "Default60")]
    public async Task<ActionResult<ApiResponse<MissionDto>>> GetMission(string id, CancellationToken cancellationToken)
    {
        var mission = await _missionService.GetByIdAsync(id, GetUserId(), cancellationToken);
        if (mission == null)
        {
            return NotFound(new ApiResponse<MissionDto>(false, null, "Mission not found."));
        }
        return Ok(new ApiResponse<MissionDto>(true, mission));
    }
    [HttpGet("campaign/{campaignId}")]
    [ResponseCache(CacheProfileName = "Default60")]
    public async Task<ActionResult<ApiResponse<IEnumerable<MissionDto>>>> GetMissionsByCampaign(string campaignId, CancellationToken cancellationToken)
    {
        var missions = await _missionService.GetByCampaignIdAsync(campaignId, GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<MissionDto>>(true, missions));
    }
    [HttpPost]
    public async Task<ActionResult<ApiResponse<MissionDto>>> CreateMission([FromBody] CreateMissionRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var mission = await _missionService.CreateAsync(request, GetUserId(), cancellationToken);
            return CreatedAtAction(nameof(GetMission), new { id = mission.Id }, new ApiResponse<MissionDto>(true, mission, "Mission created."));
        }
        catch (UnauthorizedAccessException ex)
        {
            return Forbid(ex.Message);
        }
    }
    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<MissionDto>>> UpdateMission(string id, [FromBody] UpdateMissionRequest request, CancellationToken cancellationToken)
    {
        var mission = await _missionService.UpdateAsync(id, request, GetUserId(), cancellationToken);
        if (mission == null)
        {
            return NotFound(new ApiResponse<MissionDto>(false, null, "Mission not found."));
        }
        return Ok(new ApiResponse<MissionDto>(true, mission, "Mission updated."));
    }
    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteMission(string id, CancellationToken cancellationToken)
    {
        var result = await _missionService.DeleteAsync(id, GetUserId(), cancellationToken);
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Mission not found."));
        }
        return Ok(new ApiResponse<bool>(true, true, "Mission deleted."));
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Migrations/DnDMapBuilderDbContextModelSnapshot.cs">
using System;
using DnDMapBuilder.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
#nullable disable
namespace DnDMapBuilder.Data.Migrations
{
    [DbContext(typeof(DnDMapBuilderDbContext))]
    partial class DnDMapBuilderDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "10.0.2")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);
            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<string>("OwnerId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("OwnerId");
                    b.ToTable("Campaigns");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("Cols")
                        .HasColumnType("int");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("GridColor")
                        .IsRequired()
                        .HasMaxLength(20)
                        .HasColumnType("nvarchar(20)");
                    b.Property<double>("GridOpacity")
                        .HasColumnType("float");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("MissionId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Rows")
                        .HasColumnType("int");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("MissionId");
                    b.ToTable("GameMaps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("MapId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("TokenId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<int>("X")
                        .HasColumnType("int");
                    b.Property<int>("Y")
                        .HasColumnType("int");
                    b.HasKey("Id");
                    b.HasIndex("MapId");
                    b.HasIndex("TokenId");
                    b.ToTable("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<string>("CampaignId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Description")
                        .IsRequired()
                        .HasMaxLength(2000)
                        .HasColumnType("nvarchar(2000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.HasKey("Id");
                    b.HasIndex("CampaignId");
                    b.ToTable("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("ImageContentType")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ImageFileId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<long>("ImageFileSize")
                        .HasColumnType("bigint");
                    b.Property<string>("ImageUrl")
                        .IsRequired()
                        .HasMaxLength(1000)
                        .HasColumnType("nvarchar(1000)");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("nvarchar(200)");
                    b.Property<int>("Size")
                        .HasColumnType("int");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("TokenDefinitions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");
                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("nvarchar(255)");
                    b.Property<bool>("EmailVerified")
                        .HasColumnType("bit");
                    b.Property<string>("OAuthProvider")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("OAuthProviderId")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("ProfilePictureUrl")
                        .HasColumnType("nvarchar(max)");
                    b.Property<string>("Role")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<string>("Status")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("nvarchar(50)");
                    b.Property<DateTime>("UpdatedAt")
                        .HasColumnType("datetime2");
                    b.Property<string>("Username")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("nvarchar(100)");
                    b.HasKey("Id");
                    b.HasIndex("Email")
                        .IsUnique();
                    b.HasIndex("Username")
                        .IsUnique();
                    b.ToTable("Users");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "Owner")
                        .WithMany("Campaigns")
                        .HasForeignKey("OwnerId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("Owner");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Mission", "Mission")
                        .WithMany("Maps")
                        .HasForeignKey("MissionId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Mission");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.MapTokenInstance", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.GameMap", "Map")
                        .WithMany("Tokens")
                        .HasForeignKey("MapId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("DnDMapBuilder.Data.Entities.TokenDefinition", "Token")
                        .WithMany("MapTokenInstances")
                        .HasForeignKey("TokenId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Map");
                    b.Navigation("Token");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.Campaign", "Campaign")
                        .WithMany("Missions")
                        .HasForeignKey("CampaignId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Campaign");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.HasOne("DnDMapBuilder.Data.Entities.User", "User")
                        .WithMany("TokenDefinitions")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Campaign", b =>
                {
                    b.Navigation("Missions");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.GameMap", b =>
                {
                    b.Navigation("Tokens");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.Mission", b =>
                {
                    b.Navigation("Maps");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.TokenDefinition", b =>
                {
                    b.Navigation("MapTokenInstances");
                });
            modelBuilder.Entity("DnDMapBuilder.Data.Entities.User", b =>
                {
                    b.Navigation("Campaigns");
                    b.Navigation("TokenDefinitions");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Data/Repositories/UserRepository.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
using DnDMapBuilder.Data.Repositories.Interfaces;
namespace DnDMapBuilder.Data.Repositories;
public class UserRepository : GenericRepository<User>, IUserRepository
{
    public UserRepository(DnDMapBuilderDbContext context) : base(context) { }
    public async Task<User?> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().FirstOrDefaultAsync(u => u.Email == email, cancellationToken);
    }
    public async Task<User?> GetByUsernameAsync(string username, CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().FirstOrDefaultAsync(u => u.Username == username, cancellationToken);
    }
    public async Task<IEnumerable<User>> GetPendingUsersAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().Where(u => u.Status == "pending").ToListAsync(cancellationToken);
    }
    public async Task<IEnumerable<User>> GetActiveUsersAsync(CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().Where(u => u.Status == "approved").ToListAsync(cancellationToken);
    }
    public async Task<IEnumerable<User>> GetUsersByRoleAsync(string role, CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking().Where(u => u.Role == role).ToListAsync(cancellationToken);
    }
    public async Task<User?> GetByOAuthProviderAsync(string provider, string providerId, CancellationToken cancellationToken = default)
    {
        return await _dbSet.AsNoTracking()
            .FirstOrDefaultAsync(u => u.OAuthProvider == provider && u.OAuthProviderId == providerId, cancellationToken);
    }
}
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilder.Data.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="10.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="10.0.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="10.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <!-- Prevent MSB3552 error by explicitly excluding .resx files -->
  <ItemGroup>
    <EmbeddedResource Remove="**/*.resx" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Data/DnDMapBuilderDbContext.cs">
using Microsoft.EntityFrameworkCore;
using DnDMapBuilder.Data.Entities;
namespace DnDMapBuilder.Data;
public class DnDMapBuilderDbContext : DbContext
{
    public DnDMapBuilderDbContext(DbContextOptions<DnDMapBuilderDbContext> options)
        : base(options)
    {
    }
    public DbSet<User> Users { get; set; } = null!;
    public DbSet<Campaign> Campaigns { get; set; } = null!;
    public DbSet<Mission> Missions { get; set; } = null!;
    public DbSet<GameMap> GameMaps { get; set; } = null!;
    public DbSet<TokenDefinition> TokenDefinitions { get; set; } = null!;
    public DbSet<MapTokenInstance> MapTokenInstances { get; set; } = null!;
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
#if DEBUG
        optionsBuilder.EnableSensitiveDataLogging();
        optionsBuilder.EnableDetailedErrors();
#endif
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.HasIndex(e => e.Email).IsUnique();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.Property(e => e.Username).IsRequired().HasMaxLength(100);
            entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
            entity.Property(e => e.PasswordHash).IsRequired();
            entity.Property(e => e.Role).IsRequired().HasMaxLength(50);
            entity.Property(e => e.Status).IsRequired().HasMaxLength(50);
        });
        modelBuilder.Entity<Campaign>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Description).HasMaxLength(2000);
            entity.HasOne(e => e.Owner)
                .WithMany(u => u.Campaigns)
                .HasForeignKey(e => e.OwnerId)
                .OnDelete(DeleteBehavior.Restrict);
        });
        modelBuilder.Entity<Mission>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Description).HasMaxLength(2000);
            entity.HasOne(e => e.Campaign)
                .WithMany(c => c.Missions)
                .HasForeignKey(e => e.CampaignId)
                .OnDelete(DeleteBehavior.Cascade);
        });
        modelBuilder.Entity<GameMap>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.ImageUrl).HasMaxLength(1000);
            entity.Property(e => e.GridColor).IsRequired().HasMaxLength(20);
            entity.HasOne(e => e.Mission)
                .WithMany(m => m.Maps)
                .HasForeignKey(e => e.MissionId)
                .OnDelete(DeleteBehavior.Cascade);
        });
        modelBuilder.Entity<TokenDefinition>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
            entity.Property(e => e.ImageUrl).IsRequired().HasMaxLength(1000);
            entity.Property(e => e.Type).IsRequired().HasMaxLength(50);
            entity.HasOne(e => e.User)
                .WithMany(u => u.TokenDefinitions)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });
        modelBuilder.Entity<MapTokenInstance>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.HasOne(e => e.Token)
                .WithMany(t => t.MapTokenInstances)
                .HasForeignKey(e => e.TokenId)
                .OnDelete(DeleteBehavior.Cascade);
            entity.HasOne(e => e.Map)
                .WithMany(m => m.Tokens)
                .HasForeignKey(e => e.MapId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
}
</file>

<file path="docker-compose.yml">
version: '3.8'
services:
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2022-latest
    container_name: dnd-sqlserver
    restart: unless-stopped
    environment:
      - ACCEPT_EULA=Y
      - MSSQL_SA_PASSWORD=${SA_PASSWORD:-s_2.Z6NWn*Jj17esJD6p+E}
      - MSSQL_PID=Developer
    ports:
      - "1433:1433"
    volumes:
      - sqlserver_data:/var/opt/mssql
    networks:
      - dnd-network
    healthcheck:
      test: ["CMD", "/opt/mssql-tools18/bin/sqlcmd", "-S", "localhost", "-U", "sa", "-P", "${SA_PASSWORD:-s_2.Z6NWn*Jj17esJD6p+E}", "-Q", "SELECT 1"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 20s
  api:
    build:
      context: .
      dockerfile: src/DnDMapBuilder.Api/Dockerfile
    container_name: dnd-api
    restart: unless-stopped
    depends_on:
      sqlserver:
        condition: service_healthy
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:8080;https://+:8443
      - ConnectionStrings__DefaultConnection=Server=sqlserver;Database=dndmapbuilder;User Id=sa;Password=${SA_PASSWORD:-s_2.Z6NWn*Jj17esJD6p+E};TrustServerCertificate=True;
      - ASPNETCORE_Kestrel__Certificates__Default__Path=/app/certs/aspnetapp.pfx
      - ASPNETCORE_Kestrel__Certificates__Default__Password=crypticpassword
    ports:
      - "5000:8080"
      - "5001:8443"
    volumes:
      - ./certs:/app/certs:ro
      - ${UPLOADS_PATH:-./uploads}:/app/wwwroot/uploads
    networks:
      - dnd-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health/live"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s
volumes:
  sqlserver_data:
    driver: local
networks:
  dnd-network:
    driver: bridge
</file>

<file path="src/DnDMapBuilder.Api/Controllers/GameMapsController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
namespace DnDMapBuilder.Api.Controllers;
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class GameMapsController : ControllerBase
{
    private readonly IGameMapService _mapService;
    private readonly IFileStorageService _fileStorageService;
    public GameMapsController(IGameMapService mapService, IFileStorageService fileStorageService)
    {
        _mapService = mapService;
        _fileStorageService = fileStorageService;
    }
    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();
    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "NoCache")]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> GetMap(string id, CancellationToken cancellationToken)
    {
        var map = await _mapService.GetByIdAsync(id, GetUserId(), cancellationToken);
        if (map == null)
        {
            return NotFound(new ApiResponse<GameMapDto>(false, null, "Map not found."));
        }
        return Ok(new ApiResponse<GameMapDto>(true, map));
    }
    [HttpGet("mission/{missionId}")]
    [ResponseCache(CacheProfileName = "Default60")]
    public async Task<ActionResult<ApiResponse<IEnumerable<GameMapDto>>>> GetMapsByMission(string missionId, CancellationToken cancellationToken)
    {
        var maps = await _mapService.GetByMissionIdAsync(missionId, GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<GameMapDto>>(true, maps));
    }
    [HttpPost]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> CreateMap([FromBody] CreateMapRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var map = await _mapService.CreateAsync(request, GetUserId(), cancellationToken);
            return CreatedAtAction(nameof(GetMap), new { id = map.Id }, new ApiResponse<GameMapDto>(true, map, "Map created."));
        }
        catch (UnauthorizedAccessException ex)
        {
            return Forbid(ex.Message);
        }
    }
    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<GameMapDto>>> UpdateMap(string id, [FromBody] UpdateMapRequest request, CancellationToken cancellationToken)
    {
        var map = await _mapService.UpdateAsync(id, request, GetUserId(), cancellationToken);
        if (map == null)
        {
            return NotFound(new ApiResponse<GameMapDto>(false, null, "Map not found."));
        }
        return Ok(new ApiResponse<GameMapDto>(true, map, "Map updated."));
    }
    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteMap(string id, CancellationToken cancellationToken)
    {
        var result = await _mapService.DeleteAsync(id, GetUserId(), cancellationToken);
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Map not found."));
        }
        return Ok(new ApiResponse<bool>(true, true, "Map deleted."));
    }
    [EnableRateLimiting("fileUpload")]
    [HttpPost("{id}/image")]
    [Consumes("multipart/form-data")]
    public async Task<ActionResult<ApiResponse<ImageUploadResponse>>> UploadMapImage(string id, IFormFile image, CancellationToken cancellationToken)
    {
        try
        {
            if (image == null || image.Length == 0)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "No file provided."));
            const long maxFileSize = 5 * 1024 * 1024;
            if (image.Length > maxFileSize)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "File size exceeds 5MB limit."));
            var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
            if (!allowedMimeTypes.Contains(image.ContentType?.ToLower() ?? ""))
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "Invalid file format. Allowed: PNG, JPEG, WebP."));
            // Get map to verify ownership
            var map = await _mapService.GetByIdAsync(id, GetUserId(), cancellationToken);
            if (map == null)
                return NotFound(new ApiResponse<ImageUploadResponse>(false, null, "Map not found."));
            // Upload file
            var fileId = await _fileStorageService.UploadAsync(
                image.OpenReadStream(),
                image.FileName,
                image.ContentType,
                "maps",
                cancellationToken
            );
            var updatedMap = map with
            {
                ImageFileId = fileId,
                ImageContentType = image.ContentType,
                ImageFileSize = image.Length,
                ImageUrl = _fileStorageService.GetPublicUrl(fileId, "maps")
            };
            var tokenRequests = updatedMap.Tokens
                .Select(t => new MapTokenInstanceRequest(t.TokenId, t.X, t.Y))
                .ToList();
            var result = await _mapService.UpdateAsync(id, new UpdateMapRequest(
                updatedMap.Name,
                updatedMap.ImageUrl,
                updatedMap.Rows,
                updatedMap.Cols,
                tokenRequests,
                updatedMap.GridColor,
                updatedMap.GridOpacity
            ), GetUserId(), cancellationToken);
            var response = new ImageUploadResponse(fileId, result.ImageUrl ?? "", image.ContentType ?? "application/octet-stream", image.Length);
            return Ok(new ApiResponse<ImageUploadResponse>(true, response, "Image uploaded successfully."));
        }
        catch (Exception ex)
        {
            return StatusCode(500, new ApiResponse<ImageUploadResponse>(false, null, $"Error uploading image: {ex.Message}"));
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Api/Controllers/TokensController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using System.Security.Claims;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
namespace DnDMapBuilder.Api.Controllers;
[ApiVersion("1.0")]
[Authorize]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class TokensController : ControllerBase
{
    private readonly ITokenDefinitionService _tokenService;
    private readonly IFileStorageService _fileStorageService;
    public TokensController(ITokenDefinitionService tokenService, IFileStorageService fileStorageService)
    {
        _tokenService = tokenService;
        _fileStorageService = fileStorageService;
    }
    private string GetUserId() => User.FindFirstValue(ClaimTypes.NameIdentifier) ?? throw new UnauthorizedAccessException();
    [HttpGet]
    [ResponseCache(CacheProfileName = "Default60")]
    public async Task<ActionResult<ApiResponse<IEnumerable<TokenDefinitionDto>>>> GetUserTokens(CancellationToken cancellationToken)
    {
        var tokens = await _tokenService.GetUserTokensAsync(GetUserId(), cancellationToken);
        return Ok(new ApiResponse<IEnumerable<TokenDefinitionDto>>(true, tokens));
    }
    [HttpGet("{id}")]
    [ResponseCache(CacheProfileName = "Long300")]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> GetToken(string id, CancellationToken cancellationToken)
    {
        var token = await _tokenService.GetByIdAsync(id, GetUserId(), cancellationToken);
        if (token == null)
        {
            return NotFound(new ApiResponse<TokenDefinitionDto>(false, null, "Token not found."));
        }
        return Ok(new ApiResponse<TokenDefinitionDto>(true, token));
    }
    [HttpPost]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> CreateToken([FromBody] CreateTokenDefinitionRequest request, CancellationToken cancellationToken)
    {
        var token = await _tokenService.CreateAsync(request, GetUserId(), cancellationToken);
        return CreatedAtAction(nameof(GetToken), new { id = token.Id }, new ApiResponse<TokenDefinitionDto>(true, token, "Token created."));
    }
    [HttpPut("{id}")]
    public async Task<ActionResult<ApiResponse<TokenDefinitionDto>>> UpdateToken(string id, [FromBody] UpdateTokenDefinitionRequest request, CancellationToken cancellationToken)
    {
        var token = await _tokenService.UpdateAsync(id, request, GetUserId(), cancellationToken);
        if (token == null)
        {
            return NotFound(new ApiResponse<TokenDefinitionDto>(false, null, "Token not found."));
        }
        return Ok(new ApiResponse<TokenDefinitionDto>(true, token, "Token updated."));
    }
    [HttpDelete("{id}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteToken(string id, CancellationToken cancellationToken)
    {
        var result = await _tokenService.DeleteAsync(id, GetUserId(), cancellationToken);
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "Token not found."));
        }
        return Ok(new ApiResponse<bool>(true, true, "Token deleted."));
    }
    [EnableRateLimiting("fileUpload")]
    [HttpPost("{id}/image")]
    [Consumes("multipart/form-data")]
    public async Task<ActionResult<ApiResponse<ImageUploadResponse>>> UploadTokenImage(string id, IFormFile image, CancellationToken cancellationToken)
    {
        try
        {
            if (image == null || image.Length == 0)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "No file provided."));
            const long maxFileSize = 2 * 1024 * 1024;
            if (image.Length > maxFileSize)
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "File size exceeds 2MB limit."));
            var allowedMimeTypes = new[] { "image/png", "image/jpeg", "image/webp" };
            if (!allowedMimeTypes.Contains(image.ContentType?.ToLower() ?? ""))
                return BadRequest(new ApiResponse<ImageUploadResponse>(false, null, "Invalid file format. Allowed: PNG, JPEG, WebP."));
            // Get token to verify ownership
            var token = await _tokenService.GetByIdAsync(id, GetUserId(), cancellationToken);
            if (token == null)
                return NotFound(new ApiResponse<ImageUploadResponse>(false, null, "Token not found."));
            // Upload file
            var fileId = await _fileStorageService.UploadAsync(
                image.OpenReadStream(),
                image.FileName,
                image.ContentType,
                "tokens",
                cancellationToken
            );
            var updatedToken = token with
            {
                ImageFileId = fileId,
                ImageContentType = image.ContentType,
                ImageFileSize = image.Length,
                ImageUrl = _fileStorageService.GetPublicUrl(fileId, "tokens")
            };
            var result = await _tokenService.UpdateAsync(id, new UpdateTokenDefinitionRequest(
                updatedToken.Name,
                updatedToken.ImageUrl,
                updatedToken.Size,
                updatedToken.Type
            ), GetUserId(), cancellationToken);
            var response = new ImageUploadResponse(fileId, result.ImageUrl ?? "", image.ContentType ?? "application/octet-stream", image.Length);
            return Ok(new ApiResponse<ImageUploadResponse>(true, response, "Image uploaded successfully."));
        }
        catch (Exception ex)
        {
            return StatusCode(500, new ApiResponse<ImageUploadResponse>(false, null, $"Error uploading image: {ex.Message}"));
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Api/appsettings.json">
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=sqlserver;Database=dndmapbuilder;User Id=sa;Password=s_2.Z6NWn*Jj17esJD6p+E;TrustServerCertificate=True;"
  },
  "JwtSettings": {
    "SecretKey": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!",
    "Issuer": "DnDMapBuilderApi",
    "Audience": "DnDMapBuilderClient",
    "ExpirationMinutes": "1440"
  },
  "CorsSettings": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "https://localhost:3000",
      "http://dnd-frontend:3000",
      "https://dnd-frontend:3000",
      "https://dndmaps.mikehosting.gr"
    ]
  },
  "OAuth": {
    "Google": {
      "ClientId": "",
      "ClientSecret": ""
    },
    "Apple": {
      "ClientId": "",
      "TeamId": "",
      "KeyId": "",
      "PrivateKey": ""
    },
    "RedirectUri": "https://localhost:5001/api/v1/auth/oauth/callback",
    "FrontendRedirectUri": "https://localhost:3000/auth/callback"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  },
  "AllowedHosts": "*"
}
</file>

<file path="src/DnDMapBuilder.Api/Controllers/AuthController.cs">
using Asp.Versioning;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Contracts.DTOs;
using DnDMapBuilder.Contracts.Requests;
using DnDMapBuilder.Contracts.Responses;
namespace DnDMapBuilder.Api.Controllers;
[ApiVersion("1.0")]
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
public class AuthController : ControllerBase
{
    private readonly IAuthService _authService;
    private readonly IUserManagementService _userManagementService;
    private readonly IOAuthService _oAuthService;
    public AuthController(IAuthService authService, IUserManagementService userManagementService, IOAuthService oAuthService)
    {
        _authService = authService;
        _userManagementService = userManagementService;
        _oAuthService = oAuthService;
    }
    [HttpPost("register")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> Register([FromBody] RegisterRequest request, CancellationToken cancellationToken)
    {
        var userDto = await _userManagementService.RegisterAsync(request, cancellationToken);
        if (userDto == null)
        {
            return BadRequest(new ApiResponse<AuthResponse>(
                false,
                null,
                "Registration failed. User may already exist."
            ));
        }
        var loginRequest = new LoginRequest(request.Email, request.Password);
        var authResponse = await _authService.LoginAsync(loginRequest, cancellationToken);
        if (authResponse == null)
        {
            return Ok(new ApiResponse<AuthResponse>(
                true,
                null,
                "Registration successful. Awaiting admin approval."
            ));
        }
        return Ok(new ApiResponse<AuthResponse>(true, authResponse, "Registration successful. Token generated."));
    }
    [HttpPost("login")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> Login([FromBody] LoginRequest request, CancellationToken cancellationToken)
    {
        var result = await _authService.LoginAsync(request, cancellationToken);
        if (result == null)
        {
            return Unauthorized(new ApiResponse<AuthResponse>(
                false,
                null,
                "Invalid credentials or account not approved."
            ));
        }
        return Ok(new ApiResponse<AuthResponse>(true, result, "Login successful."));
    }
    [Authorize(Roles = "admin")]
    [HttpGet("pending-users")]
    [ResponseCache(CacheProfileName = "Short10")]
    public async Task<ActionResult<ApiResponse<IEnumerable<UserDto>>>> GetPendingUsers(CancellationToken cancellationToken)
    {
        var users = await _userManagementService.GetPendingUsersAsync(cancellationToken);
        return Ok(new ApiResponse<IEnumerable<UserDto>>(true, users));
    }
    [Authorize(Roles = "admin")]
    [HttpGet("active-users")]
    [ResponseCache(CacheProfileName = "Short10")]
    public async Task<ActionResult<ApiResponse<IEnumerable<UserDto>>>> GetActiveUsers(CancellationToken cancellationToken)
    {
        var users = await _userManagementService.GetActiveUsersAsync(cancellationToken);
        return Ok(new ApiResponse<IEnumerable<UserDto>>(true, users));
    }
    [Authorize(Roles = "admin")]
    [HttpPost("approve-user")]
    public async Task<ActionResult<ApiResponse<bool>>> ApproveUser([FromBody] ApproveUserRequest request, CancellationToken cancellationToken)
    {
        var result = await _userManagementService.ApproveUserAsync(request.UserId, request.Approved, cancellationToken);
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "User not found."));
        }
        return Ok(new ApiResponse<bool>(true, true, "User status updated."));
    }
    [Authorize(Roles = "admin")]
    [HttpDelete("delete-user/{userId}")]
    public async Task<ActionResult<ApiResponse<bool>>> DeleteUser(string userId, CancellationToken cancellationToken)
    {
        var result = await _userManagementService.DeleteUserAsync(userId, cancellationToken);
        if (!result)
        {
            return NotFound(new ApiResponse<bool>(false, false, "User not found."));
        }
        return Ok(new ApiResponse<bool>(true, true, "User deleted successfully."));
    }
    [HttpGet("oauth/{provider}/url")]
    public async Task<ActionResult<ApiResponse<OAuthUrlResponse>>> GetOAuthUrl(string provider, [FromQuery] string? redirectUri)
    {
        try
        {
            var effectiveRedirectUri = redirectUri ?? $"{Request.Scheme}://{Request.Host}/api/v1/auth/oauth/callback";
            var response = await _oAuthService.GetAuthorizationUrlAsync(provider, effectiveRedirectUri);
            return Ok(new ApiResponse<OAuthUrlResponse>(true, response, $"{provider} authorization URL generated."));
        }
        catch (ArgumentException ex)
        {
            return BadRequest(new ApiResponse<OAuthUrlResponse>(false, null, ex.Message));
        }
    }
    [HttpPost("oauth/callback")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> OAuthCallback([FromBody] OAuthLoginRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _oAuthService.HandleOAuthCallbackAsync(request, cancellationToken);
            if (result == null)
            {
                return Unauthorized(new ApiResponse<AuthResponse>(false, null, "OAuth authentication failed."));
            }
            return Ok(new ApiResponse<AuthResponse>(true, result, "OAuth login successful."));
        }
        catch (ArgumentException ex)
        {
            return BadRequest(new ApiResponse<AuthResponse>(false, null, ex.Message));
        }
    }
    [HttpPost("oauth/token")]
    public async Task<ActionResult<ApiResponse<AuthResponse>>> OAuthToken([FromBody] OAuthTokenRequest request, CancellationToken cancellationToken)
    {
        try
        {
            var result = await _oAuthService.ValidateIdTokenAsync(request, cancellationToken);
            if (result == null)
            {
                return Unauthorized(new ApiResponse<AuthResponse>(false, null, "OAuth token validation failed."));
            }
            return Ok(new ApiResponse<AuthResponse>(true, result, "OAuth authentication successful."));
        }
        catch (ArgumentException ex)
        {
            return BadRequest(new ApiResponse<AuthResponse>(false, null, ex.Message));
        }
    }
}
</file>

<file path="src/DnDMapBuilder.Infrastructure/DnDMapBuilder.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <!-- Logging & ASP.NET Core -->
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
    <PackageReference Include="Serilog.AspNetCore" Version="10.0.0" />
    <PackageReference Include="Serilog.Enrichers.Environment" Version="3.0.1" />
    <PackageReference Include="Serilog.Enrichers.Thread" Version="4.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="6.1.1" />
    <PackageReference Include="Serilog.Sinks.File" Version="7.0.0" />
    <PackageReference Include="Serilog.Sinks.Seq" Version="9.0.0" />

    <!-- Telemetry/Observability -->
    <PackageReference Include="OpenTelemetry" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.SqlClient" Version="1.14.0-rc.1" />

    <!-- Health Checks -->
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" Version="9.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" Version="9.0.0" />

    <!-- Project References -->
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
  </ItemGroup>

</Project>
</file>

<file path="src/DnDMapBuilder.Api/DnDMapBuilder.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <GenerateBindingRedirectsOutputType>true</GenerateBindingRedirectsOutputType>
    <!-- XML Documentation Generation -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Asp.Versioning.Mvc.ApiExplorer" Version="8.1.1" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.Google" Version="10.0.2" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="10.0.2" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="10.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.RateLimiting" Version="7.0.0-rc.2.22476.2" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="10.1.0" />
    <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.15.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DnDMapBuilder.Application\DnDMapBuilder.Application.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Aspire.ServiceDefaults\DnDMapBuilder.Aspire.ServiceDefaults.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Contracts\DnDMapBuilder.Contracts.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Data\DnDMapBuilder.Data.csproj" />
    <ProjectReference Include="..\DnDMapBuilder.Infrastructure\DnDMapBuilder.Infrastructure.csproj" />
  </ItemGroup>

</Project>
</file>

<file path=".github/workflows/main.yml">
name: CI/CD Pipeline
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
env:
  DOTNET_VERSION: '10.0.x'
  REGISTRY: ghcr.io
jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    - name: Restore dependencies
      run: dotnet restore DnDMapBuilder.sln
    - name: Build
      run: dotnet build DnDMapBuilder.sln --configuration Release --no-restore
    - name: Test
      run: dotnet test DnDMapBuilder.sln --configuration Release --no-build --verbosity normal
  build-docker:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    outputs:
      image-name: ${{ steps.image-name.outputs.lowercase }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Convert repository name to lowercase
      id: image-name
      run: echo "lowercase=${GITHUB_REPOSITORY@L}" >> $GITHUB_OUTPUT
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Extract metadata (tags, labels)
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.lowercase }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./src/DnDMapBuilder.Api/Dockerfile
        platforms: linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
  deploy:
    needs: build-docker
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Deploy to server via SSH
      env:
        IMAGE_NAME: ${{ needs.build-docker.outputs.image-name }}
        DB_CONNECTION_STRING: ${{ secrets.DB_CONNECTION_STRING }}
        ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        ADMIN_DEFAULT_PASSWORD: ${{ secrets.ADMIN_DEFAULT_PASSWORD }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
        JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
        GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
        GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        envs: IMAGE_NAME,DB_CONNECTION_STRING,ADMIN_EMAIL,ADMIN_DEFAULT_PASSWORD,JWT_SECRET,JWT_ISSUER,JWT_AUDIENCE,GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET
        script: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker network create dnd-network 2>/dev/null || true
          docker pull ghcr.io/${IMAGE_NAME}:latest
          docker stop dnd-api || true
          docker rm dnd-api || true
          mkdir -p ~/dnd-api-uploads
          sudo chown -R 1001:1001 ~/dnd-api-uploads
          sudo chmod -R 755 ~/dnd-api-uploads
          docker run -d \
            --name dnd-api \
            --restart unless-stopped \
            -p 5000:8080 \
            -e ASPNETCORE_ENVIRONMENT=Production \
            -e ASPNETCORE_URLS="http://+:8080" \
            -e ConnectionStrings__DefaultConnection="${DB_CONNECTION_STRING}" \
            -e ADMIN_EMAIL="${ADMIN_EMAIL}" \
            -e ADMIN_DEFAULT_PASSWORD="${ADMIN_DEFAULT_PASSWORD}" \
            -e JwtSettings__Secret="${JWT_SECRET}" \
            -e JwtSettings__Issuer="${JWT_ISSUER}" \
            -e JwtSettings__Audience="${JWT_AUDIENCE}" \
            -e OAuth__Google__ClientId="${GOOGLE_CLIENT_ID}" \
            -e OAuth__Google__ClientSecret="${GOOGLE_CLIENT_SECRET}" \
            -e DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=false \
            -v ~/dnd-api-uploads:/app/wwwroot/uploads \
            --network dnd-network \
            --health-cmd="wget -q --spider http://localhost:8080/health/live || exit 1" \
            --health-interval=30s \
            --health-timeout=3s \
            --health-retries=3 \
            --health-start-period=10s \
            ghcr.io/${IMAGE_NAME}:latest
          docker image prune -f
    - name: Verify deployment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USERNAME }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        port: ${{ secrets.SERVER_PORT || 22 }}
        script: |
          echo "Waiting for API container to be healthy..."
          for i in {1..30}; do
            if docker exec dnd-api wget -q --spider http://localhost:8080/health/live 2>/dev/null; then
              echo "✓ API container is healthy"
              break
            fi
            echo "Attempt $i/30: Waiting for API..."
            sleep 2
          done
          echo ""
          echo "Checking container status..."
          docker ps --filter "name=dnd-api" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          echo ""
          echo "Testing health check endpoints..."
          echo "Testing /health/live..."
          curl -s -f http://localhost:5000/health/live > /dev/null && echo "✓ /health/live - OK" || echo "✗ /health/live - FAILED"
          echo "Testing /health..."
          curl -s -f http://localhost:5000/health > /dev/null && echo "✓ /health - OK" || echo "✗ /health - FAILED"
          echo ""
          echo "Recent API container logs:"
          docker logs dnd-api --tail 30
</file>

<file path="src/DnDMapBuilder.Api/Program.cs">
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Http.Features;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Hosting;
using Microsoft.IdentityModel.Tokens;
using DnDMapBuilder.Application.Interfaces;
using DnDMapBuilder.Application.Services;
using DnDMapBuilder.Contracts.Configuration;
using DnDMapBuilder.Data;
using DnDMapBuilder.Data.Repositories;
using DnDMapBuilder.Data.Repositories.Interfaces;
using DnDMapBuilder.Infrastructure.Configuration;
using DnDMapBuilder.Infrastructure.Middleware;
var builder = WebApplication.CreateBuilder(args);
builder.AddServiceDefaults();
builder.Services.Configure<FormOptions>(options =>
{
    options.MultipartBodyLengthLimit = 10 * 1024 * 1024;
});
builder.Services.Configure<HostOptions>(options =>
{
    options.ShutdownTimeout = TimeSpan.FromSeconds(30);
});
var controllerBuilder = builder.Services.AddControllers();
controllerBuilder.ConfigureCacheProfiles();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddResponseCachingConfiguration();
builder.Services.AddApiVersioning(options =>
{
    options.DefaultApiVersion = new Asp.Versioning.ApiVersion(1, 0);
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.ReportApiVersions = true;
})
.AddMvc()
.AddApiExplorer(options =>
{
    options.GroupNameFormat = "'v'VVV";
    options.SubstituteApiVersionInUrl = true;
});
builder.Services.AddSwaggerGen(options =>
{
    options.SwaggerDoc("v1", new() { Title = "DnD Map Builder API", Version = "v1" });
});
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<DnDMapBuilderDbContext>(options =>
    options.UseSqlServer(connectionString));
var jwtSettings = builder.Configuration.GetSection("JwtSettings");
var secretKey = jwtSettings["SecretKey"] ?? throw new InvalidOperationException("JWT SecretKey not configured");
builder.Services.AddSingleton<IJwtService>(sp =>
    new JwtService(
        secretKey,
        jwtSettings["Issuer"] ?? "DnDMapBuilderApi",
        jwtSettings["Audience"] ?? "DnDMapBuilderClient",
        int.Parse(jwtSettings["ExpirationMinutes"] ?? "1440")
    ));
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey)),
        ValidateIssuer = true,
        ValidIssuer = jwtSettings["Issuer"],
        ValidateAudience = true,
        ValidAudience = jwtSettings["Audience"],
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero
    };
});
builder.Services.AddAuthorization();
builder.Services.Configure<JwtSettings>(builder.Configuration.GetSection(JwtSettings.SectionName));
builder.Services.Configure<CorsSettings>(builder.Configuration.GetSection(CorsSettings.SectionName));
builder.Services.Configure<OAuthSettings>(builder.Configuration.GetSection("OAuth"));
builder.Services.AddRateLimitingConfiguration();
var corsSettings = builder.Configuration.GetSection(CorsSettings.SectionName).Get<CorsSettings>();
builder.Services.AddCors(options =>
{
    options.AddPolicy(CorsSettings.SectionName, policy =>
    {
        if (corsSettings?.AllowedOrigins?.Length > 0)
        {
            policy.WithOrigins(corsSettings.AllowedOrigins)
                  .AllowAnyMethod()
                  .AllowAnyHeader()
                  .AllowCredentials();
        }
        else
        {
            policy.AllowAnyOrigin()
                  .AllowAnyMethod()
                  .AllowAnyHeader();
        }
    });
});
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<ICampaignRepository, CampaignRepository>();
builder.Services.AddScoped<IMissionRepository, MissionRepository>();
builder.Services.AddScoped<IGameMapRepository, GameMapRepository>();
builder.Services.AddScoped<ITokenDefinitionRepository, TokenDefinitionRepository>();
builder.Services.AddScoped<IMapTokenInstanceRepository, MapTokenInstanceRepository>();
builder.Services.AddSingleton<IPasswordService, PasswordService>();
builder.Services.AddScoped<IUserManagementService, UserManagementService>();
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<ICampaignService, CampaignService>();
builder.Services.AddScoped<IMissionService, MissionService>();
builder.Services.AddScoped<IGameMapService, GameMapService>();
builder.Services.AddScoped<ITokenDefinitionService, TokenDefinitionService>();
builder.Services.AddSingleton<IFileValidationService, FileValidationService>();
builder.Services.AddHttpClient<GoogleOAuthService>();
builder.Services.AddHttpClient<AppleOAuthService>();
builder.Services.AddScoped<IOAuthService, OAuthService>();
var baseStoragePath = Path.Combine(builder.Environment.ContentRootPath, "wwwroot", "uploads");
var basePublicUrl = "/uploads";
builder.Services.AddSingleton<IFileStorageService>(sp =>
    new LocalFileStorageService(baseStoragePath, basePublicUrl, sp.GetRequiredService<ILogger<LocalFileStorageService>>()));
var app = builder.Build();
app.MapDefaultEndpoints();
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<DnDMapBuilderDbContext>();
    await DbInitializer.InitializeAsync(db);
}
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/swagger/v1/swagger.json", "DnD Map Builder API v1");
    });
    app.UseHttpsRedirection();
}
app.UseResponseCachingConfiguration();
app.UseCacheControlHeaders();
app.UseSecurityHeaders();
app.UseRequestResponseLogging();
app.UseRateLimitingConfiguration();
var wwwrootPath = Path.Combine(app.Environment.ContentRootPath, "wwwroot");
if (!Directory.Exists(wwwrootPath))
{
    Directory.CreateDirectory(wwwrootPath);
}
app.UseStaticFiles(new StaticFileOptions
{
    FileProvider = new Microsoft.Extensions.FileProviders.PhysicalFileProvider(wwwrootPath),
    RequestPath = "/api/v1"
});
app.UseCors(CorsSettings.SectionName);
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.Run();
</file>

</files>
